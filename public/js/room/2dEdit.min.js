'use strict';

THREE.LegacyJSONLoader = ( function () {

    function LegacyJSONLoader( manager ) {

        if ( typeof manager === 'boolean' ) {

            console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
            manager = undefined;

        }

        THREE.Loader.call( this, manager );

        this.withCredentials = false;

    }

    LegacyJSONLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {

        constructor: LegacyJSONLoader,

        load: function ( url, onLoad, onProgress, onError ) {

            var scope = this;

            var path = ( this.path === '' ) ? THREE.LoaderUtils.extractUrlBase( url ) : this.path;

            var loader = new THREE.FileLoader( this.manager );
            loader.setPath( this.path );
            loader.setWithCredentials( this.withCredentials );
            loader.load( url, function ( text ) {

                var json = JSON.parse( text );
                var metadata = json.metadata;

                if ( metadata !== undefined ) {

                    var type = metadata.type;

                    if ( type !== undefined ) {

                        if ( type.toLowerCase() === 'object' ) {

                            console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
                            return;

                        }

                    }

                }

                var object = scope.parse( json, path );
                onLoad( object.geometry, object.materials );

            }, onProgress, onError );

        },

        parse: ( function () {

            var _BlendingMode = {
                NoBlending: THREE.NoBlending,
                NormalBlending: THREE.NormalBlending,
                AdditiveBlending: THREE.AdditiveBlending,
                SubtractiveBlending: THREE.SubtractiveBlending,
                MultiplyBlending: THREE.MultiplyBlending,
                CustomBlending: THREE.CustomBlending
            };

            var _color = new THREE.Color();
            var _textureLoader = new THREE.TextureLoader();
            var _materialLoader = new THREE.MaterialLoader();

            function initMaterials( materials, texturePath, crossOrigin, manager ) {

                var array = [];

                for ( var i = 0; i < materials.length; ++ i ) {

                    array[ i ] = createMaterial( materials[ i ], texturePath, crossOrigin, manager );

                }

                return array;

            }

            function createMaterial( m, texturePath, crossOrigin, manager ) {

                // convert from old material format

                var textures = {};

                //

                var json = {
                    uuid: THREE.Math.generateUUID(),
                    type: 'MeshLambertMaterial'
                };

                for ( var name in m ) {

                    var value = m[ name ];

                    switch ( name ) {

                        case 'DbgColor':
                        case 'DbgIndex':
                        case 'opticalDensity':
                        case 'illumination':
                            break;
                        case 'DbgName':
                            json.name = value;
                            break;
                        case 'blending':
                            json.blending = _BlendingMode[ value ];
                            break;
                        case 'colorAmbient':
                        case 'mapAmbient':
                            console.warn( 'THREE.LegacyJSONLoader.createMaterial:', name, 'is no longer supported.' );
                            break;
                        case 'colorDiffuse':
                            json.color = _color.fromArray( value ).getHex();
                            break;
                        case 'colorSpecular':
                            json.specular = _color.fromArray( value ).getHex();
                            break;
                        case 'colorEmissive':
                            json.emissive = _color.fromArray( value ).getHex();
                            break;
                        case 'specularCoef':
                            json.shininess = value;
                            break;
                        case 'shading':
                            if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
                            if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
                            if ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';
                            break;
                        case 'mapDiffuse':
                            json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy, textures, texturePath, crossOrigin, manager );
                            break;
                        case 'mapDiffuseRepeat':
                        case 'mapDiffuseOffset':
                        case 'mapDiffuseWrap':
                        case 'mapDiffuseAnisotropy':
                            break;
                        case 'mapEmissive':
                            json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy, textures, texturePath, crossOrigin, manager );
                            break;
                        case 'mapEmissiveRepeat':
                        case 'mapEmissiveOffset':
                        case 'mapEmissiveWrap':
                        case 'mapEmissiveAnisotropy':
                            break;
                        case 'mapLight':
                            json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy, textures, texturePath, crossOrigin, manager );
                            break;
                        case 'mapLightRepeat':
                        case 'mapLightOffset':
                        case 'mapLightWrap':
                        case 'mapLightAnisotropy':
                            break;
                        case 'mapAO':
                            json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy, textures, texturePath, crossOrigin, manager );
                            break;
                        case 'mapAORepeat':
                        case 'mapAOOffset':
                        case 'mapAOWrap':
                        case 'mapAOAnisotropy':
                            break;
                        case 'mapBump':
                            json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy, textures, texturePath, crossOrigin, manager );
                            break;
                        case 'mapBumpScale':
                            json.bumpScale = value;
                            break;
                        case 'mapBumpRepeat':
                        case 'mapBumpOffset':
                        case 'mapBumpWrap':
                        case 'mapBumpAnisotropy':
                            break;
                        case 'mapNormal':
                            json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy, textures, texturePath, crossOrigin, manager );
                            break;
                        case 'mapNormalFactor':
                            json.normalScale = value;
                            break;
                        case 'mapNormalRepeat':
                        case 'mapNormalOffset':
                        case 'mapNormalWrap':
                        case 'mapNormalAnisotropy':
                            break;
                        case 'mapSpecular':
                            json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy, textures, texturePath, crossOrigin, manager );
                            break;
                        case 'mapSpecularRepeat':
                        case 'mapSpecularOffset':
                        case 'mapSpecularWrap':
                        case 'mapSpecularAnisotropy':
                            break;
                        case 'mapMetalness':
                            json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy, textures, texturePath, crossOrigin, manager );
                            break;
                        case 'mapMetalnessRepeat':
                        case 'mapMetalnessOffset':
                        case 'mapMetalnessWrap':
                        case 'mapMetalnessAnisotropy':
                            break;
                        case 'mapRoughness':
                            json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy, textures, texturePath, crossOrigin, manager );
                            break;
                        case 'mapRoughnessRepeat':
                        case 'mapRoughnessOffset':
                        case 'mapRoughnessWrap':
                        case 'mapRoughnessAnisotropy':
                            break;
                        case 'mapAlpha':
                            json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy, textures, texturePath, crossOrigin, manager );
                            break;
                        case 'mapAlphaRepeat':
                        case 'mapAlphaOffset':
                        case 'mapAlphaWrap':
                        case 'mapAlphaAnisotropy':
                            break;
                        case 'flipSided':
                            json.side = THREE.BackSide;
                            break;
                        case 'doubleSided':
                            json.side = THREE.DoubleSide;
                            break;
                        case 'transparency':
                            console.warn( 'THREE.LegacyJSONLoader.createMaterial: transparency has been renamed to opacity' );
                            json.opacity = value;
                            break;
                        case 'depthTest':
                        case 'depthWrite':
                        case 'colorWrite':
                        case 'opacity':
                        case 'reflectivity':
                        case 'transparent':
                        case 'visible':
                        case 'wireframe':
                            json[ name ] = value;
                            break;
                        case 'vertexColors':
                            if ( value === true ) json.vertexColors = THREE.VertexColors;
                            if ( value === 'face' ) json.vertexColors = THREE.FaceColors;
                            break;
                        default:
                            console.error( 'THREE.LegacyJSONLoader.createMaterial: Unsupported', name, value );
                            break;

                    }

                }

                if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;
                if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;

                if ( json.opacity < 1 ) json.transparent = true;

                _materialLoader.setTextures( textures );

                return _materialLoader.parse( json );

            }

            function loadTexture( path, repeat, offset, wrap, anisotropy, textures, texturePath, crossOrigin, manager ) {

                var fullPath = texturePath + path;
                var loader = manager.getHandler( fullPath );

                var texture;

                if ( loader !== null ) {

                    texture = loader.load( fullPath );

                } else {

                    _textureLoader.setCrossOrigin( crossOrigin );
                    texture = _textureLoader.load( fullPath );

                }

                if ( repeat !== undefined ) {

                    texture.repeat.fromArray( repeat );

                    if ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
                    if ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;

                }

                if ( offset !== undefined ) {

                    texture.offset.fromArray( offset );

                }

                if ( wrap !== undefined ) {

                    if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = THREE.RepeatWrapping;
                    if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = THREE.MirroredRepeatWrapping;

                    if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = THREE.RepeatWrapping;
                    if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = THREE.MirroredRepeatWrapping;

                }

                if ( anisotropy !== undefined ) {

                    texture.anisotropy = anisotropy;

                }

                var uuid = THREE.Math.generateUUID();

                textures[ uuid ] = texture;

                return uuid;

            }

            function parseModel( json, geometry ) {

                function isBitSet( value, position ) {

                    return value & ( 1 << position );

                }

                var i, j, fi,

                    offset, zLength,

                    colorIndex, normalIndex, uvIndex, materialIndex,

                    type,
                    isQuad,
                    hasMaterial,
                    hasFaceVertexUv,
                    hasFaceNormal, hasFaceVertexNormal,
                    hasFaceColor, hasFaceVertexColor,

                    vertex, face, faceA, faceB, hex, normal,

                    uvLayer, uv, u, v,

                    faces = json.faces,
                    vertices = json.vertices,
                    normals = json.normals,
                    colors = json.colors,

                    scale = json.scale,

                    nUvLayers = 0;


                if ( json.uvs !== undefined ) {

                    // disregard empty arrays

                    for ( i = 0; i < json.uvs.length; i ++ ) {

                        if ( json.uvs[ i ].length ) nUvLayers ++;

                    }

                    for ( i = 0; i < nUvLayers; i ++ ) {

                        geometry.faceVertexUvs[ i ] = [];

                    }

                }

                offset = 0;
                zLength = vertices.length;

                while ( offset < zLength ) {

                    vertex = new THREE.Vector3();

                    vertex.x = vertices[ offset ++ ] * scale;
                    vertex.y = vertices[ offset ++ ] * scale;
                    vertex.z = vertices[ offset ++ ] * scale;

                    geometry.vertices.push( vertex );

                }

                offset = 0;
                zLength = faces.length;

                while ( offset < zLength ) {

                    type = faces[ offset ++ ];

                    isQuad = isBitSet( type, 0 );
                    hasMaterial = isBitSet( type, 1 );
                    hasFaceVertexUv = isBitSet( type, 3 );
                    hasFaceNormal = isBitSet( type, 4 );
                    hasFaceVertexNormal = isBitSet( type, 5 );
                    hasFaceColor = isBitSet( type, 6 );
                    hasFaceVertexColor = isBitSet( type, 7 );

                    // console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

                    if ( isQuad ) {

                        faceA = new THREE.Face3();
                        faceA.a = faces[ offset ];
                        faceA.b = faces[ offset + 1 ];
                        faceA.c = faces[ offset + 3 ];

                        faceB = new THREE.Face3();
                        faceB.a = faces[ offset + 1 ];
                        faceB.b = faces[ offset + 2 ];
                        faceB.c = faces[ offset + 3 ];

                        offset += 4;

                        if ( hasMaterial ) {

                            materialIndex = faces[ offset ++ ];
                            faceA.materialIndex = materialIndex;
                            faceB.materialIndex = materialIndex;

                        }

                        // to get face <=> uv index correspondence

                        fi = geometry.faces.length;

                        if ( hasFaceVertexUv ) {

                            for ( i = 0; i < nUvLayers; i ++ ) {

                                uvLayer = json.uvs[ i ];

                                geometry.faceVertexUvs[ i ][ fi ] = [];
                                geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

                                for ( j = 0; j < 4; j ++ ) {

                                    uvIndex = faces[ offset ++ ];

                                    u = uvLayer[ uvIndex * 2 ];
                                    v = uvLayer[ uvIndex * 2 + 1 ];

                                    uv = new THREE.Vector2( u, v );

                                    if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
                                    if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

                                }

                            }

                        }

                        if ( hasFaceNormal ) {

                            normalIndex = faces[ offset ++ ] * 3;

                            faceA.normal.set(
                                normals[ normalIndex ++ ],
                                normals[ normalIndex ++ ],
                                normals[ normalIndex ]
                            );

                            faceB.normal.copy( faceA.normal );

                        }

                        if ( hasFaceVertexNormal ) {

                            for ( i = 0; i < 4; i ++ ) {

                                normalIndex = faces[ offset ++ ] * 3;

                                normal = new THREE.Vector3(
                                    normals[ normalIndex ++ ],
                                    normals[ normalIndex ++ ],
                                    normals[ normalIndex ]
                                );


                                if ( i !== 2 ) faceA.vertexNormals.push( normal );
                                if ( i !== 0 ) faceB.vertexNormals.push( normal );

                            }

                        }


                        if ( hasFaceColor ) {

                            colorIndex = faces[ offset ++ ];
                            hex = colors[ colorIndex ];

                            faceA.color.setHex( hex );
                            faceB.color.setHex( hex );

                        }


                        if ( hasFaceVertexColor ) {

                            for ( i = 0; i < 4; i ++ ) {

                                colorIndex = faces[ offset ++ ];
                                hex = colors[ colorIndex ];

                                if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
                                if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );

                            }

                        }

                        geometry.faces.push( faceA );
                        geometry.faces.push( faceB );

                    } else {

                        face = new THREE.Face3();
                        face.a = faces[ offset ++ ];
                        face.b = faces[ offset ++ ];
                        face.c = faces[ offset ++ ];

                        if ( hasMaterial ) {

                            materialIndex = faces[ offset ++ ];
                            face.materialIndex = materialIndex;

                        }

                        // to get face <=> uv index correspondence

                        fi = geometry.faces.length;

                        if ( hasFaceVertexUv ) {

                            for ( i = 0; i < nUvLayers; i ++ ) {

                                uvLayer = json.uvs[ i ];

                                geometry.faceVertexUvs[ i ][ fi ] = [];

                                for ( j = 0; j < 3; j ++ ) {

                                    uvIndex = faces[ offset ++ ];

                                    u = uvLayer[ uvIndex * 2 ];
                                    v = uvLayer[ uvIndex * 2 + 1 ];

                                    uv = new THREE.Vector2( u, v );

                                    geometry.faceVertexUvs[ i ][ fi ].push( uv );

                                }

                            }

                        }

                        if ( hasFaceNormal ) {

                            normalIndex = faces[ offset ++ ] * 3;

                            face.normal.set(
                                normals[ normalIndex ++ ],
                                normals[ normalIndex ++ ],
                                normals[ normalIndex ]
                            );

                        }

                        if ( hasFaceVertexNormal ) {

                            for ( i = 0; i < 3; i ++ ) {

                                normalIndex = faces[ offset ++ ] * 3;

                                normal = new THREE.Vector3(
                                    normals[ normalIndex ++ ],
                                    normals[ normalIndex ++ ],
                                    normals[ normalIndex ]
                                );

                                face.vertexNormals.push( normal );

                            }

                        }


                        if ( hasFaceColor ) {

                            colorIndex = faces[ offset ++ ];
                            face.color.setHex( colors[ colorIndex ] );

                        }


                        if ( hasFaceVertexColor ) {

                            for ( i = 0; i < 3; i ++ ) {

                                colorIndex = faces[ offset ++ ];
                                face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );

                            }

                        }

                        geometry.faces.push( face );

                    }

                }

            }

            function parseSkin( json, geometry ) {

                var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

                if ( json.skinWeights ) {

                    for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

                        var x = json.skinWeights[ i ];
                        var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
                        var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
                        var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

                        geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );

                    }

                }

                if ( json.skinIndices ) {

                    for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

                        var a = json.skinIndices[ i ];
                        var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
                        var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
                        var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

                        geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );

                    }

                }

                geometry.bones = json.bones;

                if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

                    console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
                        geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

                }

            }

            function parseMorphing( json, geometry ) {

                var scale = json.scale;

                if ( json.morphTargets !== undefined ) {

                    for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {

                        geometry.morphTargets[ i ] = {};
                        geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
                        geometry.morphTargets[ i ].vertices = [];

                        var dstVertices = geometry.morphTargets[ i ].vertices;
                        var srcVertices = json.morphTargets[ i ].vertices;

                        for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

                            var vertex = new THREE.Vector3();
                            vertex.x = srcVertices[ v ] * scale;
                            vertex.y = srcVertices[ v + 1 ] * scale;
                            vertex.z = srcVertices[ v + 2 ] * scale;

                            dstVertices.push( vertex );

                        }

                    }

                }

                if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {

                    console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );

                    var faces = geometry.faces;
                    var morphColors = json.morphColors[ 0 ].colors;

                    for ( var i = 0, l = faces.length; i < l; i ++ ) {

                        faces[ i ].color.fromArray( morphColors, i * 3 );

                    }

                }

            }

            function parseAnimations( json, geometry ) {

                var outputAnimations = [];

                // parse old style Bone/Hierarchy animations
                var animations = [];

                if ( json.animation !== undefined ) {

                    animations.push( json.animation );

                }

                if ( json.animations !== undefined ) {

                    if ( json.animations.length ) {

                        animations = animations.concat( json.animations );

                    } else {

                        animations.push( json.animations );

                    }

                }

                for ( var i = 0; i < animations.length; i ++ ) {

                    var clip = THREE.AnimationClip.parseAnimation( animations[ i ], geometry.bones );
                    if ( clip ) outputAnimations.push( clip );

                }

                // parse implicit morph animations
                if ( geometry.morphTargets ) {

                    // TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
                    var morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
                    outputAnimations = outputAnimations.concat( morphAnimationClips );

                }

                if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;

            }

            return function parse( json, path ) {

                if ( json.data !== undefined ) {

                    // Geometry 4.0 spec
                    json = json.data;

                }

                if ( json.scale !== undefined ) {

                    json.scale = 1.0 / json.scale;

                } else {

                    json.scale = 1.0;

                }

                var geometry = new THREE.Geometry();

                parseModel( json, geometry );
                parseSkin( json, geometry );
                parseMorphing( json, geometry );
                parseAnimations( json, geometry );

                geometry.computeFaceNormals();
                geometry.computeBoundingSphere();

                if ( json.materials === undefined || json.materials.length === 0 ) {

                    return { geometry: geometry };

                } else {

                    var materials = initMaterials( json.materials, this.resourcePath || path, this.crossOrigin, this.manager );

                    return { geometry: geometry, materials: materials };

                }

            };

        } )()

    } );

    return LegacyJSONLoader;

} )();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };



var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();



function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }



function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }



function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }



(function () {

    'use strict';



    /**

     * DressingRoom App

     *

     * by Tracing Idea

     *

     * @author ilya

     *

     * Version 2.0.1.1

     *

     * Copyright (c) 2017

     *

     **/



    var Engine2D = function () {

        function Engine2D(canvas, width, height) {

            _classCallCheck(this, Engine2D);



            this.canvas = canvas;

            this.canvasContext = canvas.getContext('2d');

            this.width = Number(width) || 2000;

            this.height = Number(height) || 1250;



            this._surfaceCanvas = document.createElement('canvas');

            this._surfaceCanvasCtx = this._surfaceCanvas.getContext('2d');



            this._foreground = null;

            this._shadowGlossy = null;

            this._shadowMatt = null;

        }



        _createClass(Engine2D, [{

            key: '_drawSurfaceCanvas',

            value: function _drawSurfaceCanvas(surface) {

                // Clear canvas

                this._surfaceCanvas.width = this.width;

                this._surfaceCanvas.height = this.height;

                // this._surfaceCanvasCtx.clearRect(0, 0, this.width, this.height);



                // Draw surface color

                this._surfaceCanvasCtx.fillStyle = surface.color;

                this._surfaceCanvasCtx.fillRect(0, 0, this.width, this.height);



                // Draw surface tiles

                surface.projection.render(undefined, this._cameraDirection);

                this._surfaceCanvasCtx.drawImage(surface.projection.canvas, 0, 0, this.width, this.height);



                // Draw surface tiles BackLight for hovered surface

                if (Array.isArray(this._backLightSurfaces) && this._backLightSurfaces.indexOf(surface) !== -1) {

                    this._surfaceCanvasCtx.fillStyle = window.JsConstants.config.surfaceBacklightColor;

                    this._surfaceCanvasCtx.fillRect(0, 0, this.width, this.height);

                }



                // Draw shadow

                var shadow = surface.getFinish() === 'matt' || surface.getFinish() === 'textured' ? this._shadowMatt : this._shadowGlossy;



                this._surfaceCanvasCtx.globalCompositeOperation = 'multiply';

                this._surfaceCanvasCtx.drawImage(shadow, 0, 0, this.width, this.height);

                this._surfaceCanvasCtx.globalCompositeOperation = 'source-over';

            }

        }, {

            key: '_drawTiledShape',

            value: function _drawTiledShape(surface) {

                var _this2 = this;



                if (surface) {

                    surface.projection.setSize(this.width, this.height);



                    this.canvasContext.save();



                    this.canvasContext.beginPath();

                    surface[11].forEach(function (maskPoint) {

                        _this2.canvasContext.lineTo(maskPoint[0], maskPoint[1]);

                    });

                    this.canvasContext.closePath();

                    this.canvasContext.clip();



                    this._drawSurfaceCanvas(surface);

                    this.canvasContext.drawImage(this._surfaceCanvas, 0, 0, this.width, this.height);



                    this.canvasContext.restore();

                }

            }

        }, {

            key: '_drawTiledSurfaces',

            value: function _drawTiledSurfaces(surfaces) {

                var _this3 = this;



                if (Array.isArray(surfaces)) {

                    surfaces.forEach(function (surface) {

                        return _this3._drawTiledShape(surface);

                    });

                }

            }

        }, {

            key: '_render',

            value: function _render(surfaces) {

                if (this._foreground && this._shadowMatt && this._shadowGlossy) {

                    this.canvas.width = this.width;

                    this.canvas.height = this.height;



                    this.canvasContext.drawImage(this._shadowGlossy, 0, 0, this.width, this.height); // Background



                    this._drawTiledSurfaces(surfaces);



                    this.canvasContext.drawImage(this._foreground, 0, 0, this.width, this.height);

                }

            }

        }, {

            key: '_loadImage',

            value: function _loadImage(imageUrl, onLoad, onProgress, setSize) {

                var _this4 = this;



                if (imageUrl) {

                    var img = new Image();

                    img.onload = function () {

                        if (setSize) {

                            _this4.width = img.naturalWidth || img.width;

                            _this4.height = img.naturalHeight || img.height;

                        }



                        _this4._imagesLoadedCount += 1;

                        if (_this4._imagesLoadedCount >= _this4._imagesTotalCount) {

                            _this4._render();

                            if (onLoad) onLoad();

                        }

                        if (onProgress) onProgress(_this4._imagesLoadedCount, _this4._imagesTotalCount);

                    };

                    img.src = imageUrl;

                    return img;

                }

            }

        }, {

            key: 'render',

            value: function render(surfaces, backLightSurfaces, cameraDirection) {

                this._cameraDirection = cameraDirection;

                this._backLightSurfaces = backLightSurfaces;

                this._render(surfaces);

            }

        }, {

            key: 'loadImages',

            value: function loadImages(urls, onLoad, onProgress) {

                this._imagesTotalCount = 0;

                this._imagesLoadedCount = 0;

                if (urls.image) this._imagesTotalCount += 1;

                if (urls.shadow) this._imagesTotalCount += 1;

                if (urls.shadow_matt) this._imagesTotalCount += 1;



                this._foreground = this._loadImage(urls.image, onLoad, onProgress, true);



                var shadowGlossy = this._loadImage(urls.shadow, onLoad, onProgress);

                var shadowMatt = this._loadImage(urls.shadow_matt, onLoad, onProgress);

                this._shadowGlossy = shadowGlossy || shadowMatt;

                this._shadowMatt = shadowMatt || shadowGlossy;

            }

        }, {

            key: 'setImages',

            value: function setImages(images) {

                this._foreground = images.foreground;

                this._shadowGlossy = images.shadow || images.shadowMatt;

                this._shadowMatt = images.shadowMatt || images.shadow;

            }

        }, {

            key: 'isPointOnShape',

            value: function isPointOnShape(point, shapePoints) {

                var _this5 = this;



                if (Array.isArray(shapePoints) && shapePoints.length > 2) {

                    // this.canvasContext.save();

                    this.canvasContext.beginPath();

                    shapePoints.forEach(function (shapePoint) {

                        return _this5.canvasContext.lineTo(shapePoint[0], shapePoint[1]);

                    });

                    this.canvasContext.closePath();



                    if (this.canvasContext.isPointInPath(point.x, point.y) || this.canvasContext.isPointInStroke(point.x, point.y)) {

                        return true;

                    }

                    // this.canvasContext.restore();

                }

            }

        }]);



        return Engine2D;

    }();



    // todo optimize



    var Locale = {

        'shapes': {

            'square': 'Square',

            'rectangle': 'Rectangle',

            'diamond': 'Diamond',

            'hexagon': 'Hexagonal'

        }

    };



    var locale = window.JsConstants && window.JsConstants.lang || {};

    Object.assign(Locale, locale.default); // todo fix



    function replace(text, inlineText) {

        if (typeof inlineText !== 'undefined') {

            if (text.indexOf('{s}') !== -1) {

                return text.replace('{s}', inlineText);

            }



            return text + ': ' + inlineText;

        }



        return text;

    }



    Locale.lang = function (text, inlineText) {

        if (!text) return '';



        if (locale.current) {

            var translation = locale.current[text];

            if (typeof translation === 'string') return replace(translation, inlineText);

        }



        if (locale.default) {

            var defaultText = locale.default[text];

            if (typeof defaultText === 'string') return replace(defaultText, inlineText);

        }



        return replace(text, inlineText);

    };



    function UI(room) {

        this.tiles = [];



        var _this = this;



        var topPanelVisible = false;



        /**

         * Show alerts for user

         *

         * @method showAlert

         * @param {string} message

         * @param {?string} type - 'warning', 'success', 'danger', 'error' or 'info'

         */

        this.showAlert = function (message, type) {

            if (message) {

                switch (type) {

                    case 'warning':

                        this.alertWarning(message);

                        break;

                    case 'success':

                        this.alertSuccess(message);

                        break;

                    case 'danger':

                        this.alertDanger(message);

                        break;

                    case 'error':

                        this.alertError(message);

                        break;



                    default:

                        this.alert(message);

                        break;

                }

            }

        };



        this.alertWarning = function (message) {

            window.$('#warningAlertBox').html('<strong>Warning!</strong> ' + message);

            window.$('#warningAlertBox').fadeIn();

        };



        this.alertSuccess = function (message) {

            window.$('#successAlertBox').html('<strong>Success!</strong> ' + message);

            window.$('#successAlertBox').fadeIn();

        };



        this.alertDanger = function (message) {

            window.$('#dangerAlertBox').html('<strong>Danger!</strong> ' + message);

            window.$('#dangerAlertBox').fadeIn();

        };



        this.alertError = function (message) {

            window.$('#dangerAlertBox').html('<strong>Error!</strong> ' + message);

            window.$('#dangerAlertBox').fadeIn();

        };



        this.alert = function (message) {

            window.$('#infoAlertBox').html('<strong>Info!</strong> ' + message);

            window.$('#infoAlertBox').fadeIn();

        };



        this.isMobileDevice = function () {

            return UI.isMobileDevice();

        };



        /**

         * Show or hide tiles panel

         *

         * @method topPanelSlide

         * @param {?boolean} show - true to show panel, false|undefined to hide it

         */

        this.topPanelSlide = function (show) {

            if (show === true) {

                if (!topPanelVisible) {

                    topPanelVisible = true;

                    window.$('#topPanel').animate({ 'right': 0 }, 'fast');

                    window.$('#topPanelHideIcon').removeClass('glyphicon-triangle-left').addClass('glyphicon-triangle-right');

                }

            } else if (topPanelVisible) {

                topPanelVisible = false;



                var width = window.$('#topPanel').width();

                window.$('#topPanel').animate({ 'right': -width }, 'fast');

                window.$('#topPanelHideIcon').removeClass('glyphicon-triangle-right').addClass('glyphicon-triangle-left');

            }

        };



        this.topPanelToggle = function () {

            _this.topPanelSlide(!topPanelVisible);

        };



        this.topPanelHide = function () {

            _this.topPanelSlide(false);

        };



        this.topPanelShow = function () {

            _this.topPanelSlide(true);

        };



        /**

         * Switch tiles panel

         *

         * @method switchTopPanel

         * @param {string} panel - Panel HTMLElement ID

         * @param {?string} display - CSS display value

         */

        this.switchTopPanel = function (panel) {

            var display = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';



            var panelHtmlElement = document.getElementById(panel);

            if (panelHtmlElement.style.display !== display) {

                panelHtmlElement.style.display = display;

            }



            var panels = ['topPanel', 'topPanelCeilingColor', 'productInfoPanel'];

            panels.forEach(function (otherPanel) {

                var otherPanelHtmlElement = document.getElementById(otherPanel);

                if (otherPanelHtmlElement && otherPanelHtmlElement !== panelHtmlElement) {

                    otherPanelHtmlElement.style.display = 'none';

                }

            });

        };



        /**

         * Change grout size text on grout panel

         *

         * @method changeGroutSizeText

         * @param {HTMLElementEvent} event - not used

         * @param {?number} value - Grout size value or {HTMLElement input value

         */

        this.changeGroutSizeText = function (event, value) {

            if (value === undefined) {

                value = event && event.currentTarget && event.currentTarget.value;

            }

            document.getElementById('topPanelGroutSizeText').innerHTML = value + ' mm';

        };



        /**

         * Hide productInfoPanel for iorena layout

         */

        this.hideProductInfoPanel = function () {

            if (window.JsConstants.config.layout === 'iorena.') {

                var productInfoButton = document.getElementById('bottomMenuRoomInfo');

                var productInfoPanel = document.getElementById('productInfoPanel');

                if (productInfoButton && productInfoPanel && productInfoPanel.classList.contains('show')) {

                    productInfoButton.click();

                }

            }

        };



        this.changeGroutSize = function (value) {

            var groutSizeRange = document.getElementById('topPanelGroutSizeRange');

            if (Number(groutSizeRange.value) !== Number(value)) {

                groutSizeRange.value = value;

                this.changeGroutSizeText(undefined, value);

            }

        };



        function tilesSort(field, order) {

            // field: name, created_at, price, size;  order: 1 = asc, -1 = desc

            if (Array.isArray(_this.tiles) && _this.tiles.length) {

                var tilesListUl = document.getElementById('topPanelTilesListUl');



                var values = _this.tiles.map(function (tile, index) {

                    var value = '';

                    if (typeof tile[field] === 'string') {

                        value = tile[field].trim().toLowerCase();

                    } else if (typeof tile[field] === 'number') {

                        value = tile[field];

                    }



                    return { value: value, index: index };

                });



                values.sort(function (a, b) {

                    if (a.value > b.value) return order;else if (a.value < b.value) return -order;

                    return 0;

                });



                values.forEach(function (value) {

                    var tile = _this.tiles[value.index];

                    if (tile.custom) {

                        tilesListUl.insertBefore(tile.li, tilesListUl.firstChild);

                    } else {

                        tilesListUl.appendChild(tile.li);

                    }

                });



                _this.tiles.showIcons();

            }

        }



        this.addTilesToList = function (sortType) {

            switch (sortType) {

                case 'z-a':

                    tilesSort('name', -1);

                    break;

                case 'newest first':

                    tilesSort('created_at', -1);

                    break;

                case 'oldest first':

                    tilesSort('created_at', 1);

                    break;



                default:

                    // 'a-z'

                    tilesSort('name', 1);

            }

        };



        this.changeTilesSort = function () {

            _this.addTilesToList(this.value);

        };



        this.hideTilesPreloader = function () {

            document.getElementById('loadTilesAnimationContainer').style.display = 'none';

        };



        function getSurfaceGroups(surfaces) {

            var groupIds = [];

            var surfaceGroups = [];



            surfaces.forEach(function (surface) {

                if (!surface.group || groupIds.indexOf(surface.group) === -1) {

                    groupIds.push(surface.group);

                    surfaceGroups.push(surface);

                }

            });



            return surfaceGroups;

        }



        function getProductInfoElement(tile) {

            var tileItem = document.createElement('div');

            tileItem.className = 'top-panel-content-tiles-list-item';

            tileItem.innerHTML = '<div class="tile-list-thumbnail-image-holder">\n                <img src="' + tile.file + '" class="tile-list-thumbnail">\n            </div>\n            ' + tile.getInfoText();

            return tileItem;

        }



        this.addProductInfo = function (room, tiles) {

            var productInfoTilesList = document.getElementById('productInfoTilesList');

            productInfoTilesList.innerHTML = ''; // '<div class="top-panel-label">Used product information</div>';

            if (room.size) {

                productInfoTilesList.innerHTML = '<div class="top-panel-label">Room size: ' + room.size.x / 1000 + 'm \xD7 ' + room.size.z / 1000 + 'm, Height: ' + room.size.y / 1000 + 'm</div>';

            }



            var surfaceGroups = getSurfaceGroups(room.tiledSurfaces);



            surfaceGroups.forEach(function (tiledSurface, index) {

                var tileApplied = tiledSurface.tileIndex !== undefined || tiledSurface.tile2Index !== undefined || tiledSurface.freeDesignTiles && tiledSurface.freeDesignTiles.length > 0;



                if (tileApplied) {

                    var surfaceProductInfo = document.createElement('p');

                    var usedTileIds = [];



                    if (!tiledSurface.name) {

                        // todo move to surfaces init

                        if (room.surfaceTypes && tiledSurface.type) {

                            tiledSurface.name = room.surfaceTypes[tiledSurface.type];

                        } else if (tiledSurface.type) {

                            tiledSurface.name = tiledSurface.type;

                        } else {

                            tiledSurface.name = 'Surface ' + (1 + index);

                        }

                    }

                    surfaceProductInfo.className = 'top-panel-label';

                    surfaceProductInfo.textContent = Locale.lang(tiledSurface.name);

                    productInfoTilesList.appendChild(surfaceProductInfo);



                    if (tiledSurface.tileIndex !== undefined) {

                        productInfoTilesList.appendChild(getProductInfoElement(tiles[tiledSurface.tileIndex]));

                        usedTileIds.push({

                            id: tiles[tiledSurface.tileIndex].id,

                            custom: tiles[tiledSurface.tileIndex].custom

                        });

                    }



                    if (tiledSurface.tile2Index !== undefined && tiledSurface.tile2Index !== tiledSurface.tileIndex) {

                        productInfoTilesList.appendChild(getProductInfoElement(tiles[tiledSurface.tile2Index]));

                        usedTileIds.push({

                            id: tiles[tiledSurface.tile2Index].id,

                            custom: tiles[tiledSurface.tile2Index].custom

                        });

                    }



                    if (tiledSurface.freeDesignTiles) {

                        tiledSurface.freeDesignTiles.forEach(function (freeDesignTile) {

                            var tileUsed = usedTileIds.some(function (usedTile) {

                                return freeDesignTile.id === usedTile.id && freeDesignTile.custom === usedTile.custom;

                            });

                            if (!tileUsed) {

                                var tile = tiles.getById(freeDesignTile.id, freeDesignTile.custom);

                                productInfoTilesList.appendChild(getProductInfoElement(tile));

                                usedTileIds.push({

                                    id: freeDesignTile.id,

                                    custom: freeDesignTile.custom

                                });

                            }

                        });

                    }

                }

            });

        };



        this.changeFullScreenMode = function (fullScreen) {

            if (!document.fullscreenElement && !document.mozFullScreenElement && !document.webkitFullscreenElement && fullScreen !== false || fullScreen === true) {

                if (document.documentElement.requestFullscreen) {

                    document.documentElement.requestFullscreen();

                } else if (document.documentElement.mozRequestFullScreen) {

                    document.documentElement.mozRequestFullScreen();

                } else if (document.documentElement.webkitRequestFullscreen) {

                    document.documentElement.webkitRequestFullscreen(window.Element.ALLOW_KEYBOARD_INPUT);

                }

            } else if (document.cancelFullScreen) {

                document.cancelFullScreen();

            } else if (document.mozCancelFullScreen) {

                document.mozCancelFullScreen();

            } else if (document.webkitCancelFullScreen) {

                document.webkitCancelFullScreen();

            }

        };



        this.showAdditionalOptions = function (event) {

            if (!room || !room.currentTiledSurface) {

                _this.showAlert('Surface not selected. To select surface click on wall or floor.', 'warning');

                return;

            }



            var show = !$(event.currentTarget).hasClass('top-panel-button-active');



            $('.top-panel-button').removeClass('top-panel-button-active');

            $('.top-panel-option-box').hide();



            if (show) {

                $(event.currentTarget).addClass('top-panel-button-active');



                switch (event.currentTarget.id) {

                    case 'btnLayout':

                        $('#topPanelLayout').show();

                        break;

                    case 'btnGrout':

                        $('#topPanelGrout').show();

                        break;

                    case 'btnRefine':

                        if (typeof _this.filtersShow === 'function') {

                            $('#topPanelFilter').show();

                            _this.filtersShow();

                        }

                        break;

                }

            }

        };



        this.updateSkewSizeButtons = function (fillTypeIndex) {

            var skewPattern = fillTypeIndex === 2 || fillTypeIndex === 3;

            $('.radio-skew-size input').attr('disabled', !skewPattern);

        };



        this.updateSkewSize = function (value) {

            $('.radio-skew-size input').each(function (i, button) {

                button.checked = button.value === String(value);

            });

        };



        this.updateValues = function (surface) {

            _this.changeGroutSize(surface.groutSize);

            document.getElementById('topPanelCheckFreeDesign').checked = surface.freeDesign;

            document.getElementById('topPanelSurfaceRotation_' + surface.rotation).checked = true;

            document.getElementById('topPanelSurfacePattern_' + surface.fillTypeIndex).checked = true;



            _this.updateSkewSize(surface.skewSize);

            _this.updateSkewSizeButtons(surface.fillTypeIndex);

        };



        function bookmarkLink() {

            var url = $('#dialogSavedRoomUrlInput').val();

            if (url) {

                if (window.sidebar && window.sidebar.addPanel) {

                    // Mozilla Firefox Bookmark

                    window.sidebar.addPanel(document.title, url, '');

                } else if (window.external && window.external.hasOwnProperty('AddFavorite')) {

                    // IE Favorite

                    window.external.AddFavorite(url, document.title); // eslint-disable-line new-cap

                } else if (window.opera && window.print) {

                    // Opera Hotlist

                    var a = document.createElement('a');

                    a.setAttribute('href', url);

                    a.setAttribute('title', document.title);

                    a.setAttribute('rel', 'sidebar');

                    a.click(); // this.title=document.title;

                } else {

                    // webkit - safari/chrome

                    var ctrlButton = navigator.userAgent.toLowerCase().indexOf('mac') === -1 ? 'CTRL' : 'Command/Cmd';

                    _this.showAlert('Press ' + ctrlButton + ' + D to bookmark this page.');

                }

            }

        }



        this.share = function (event) {

            event.preventDefault();



            var width = 400;

            var height = 400;

            var left = Math.floor(($(window).width() - width) / 2);

            var top = Math.floor(($(window).height() - height) / 2);



            var roomUrl = window.location.href;



            if (window.JsConstants.room.url) {

                roomUrl = window.location.origin + '/room/url/' + window.JsConstants.room.url;



                if (window.JsConstants.config.urlFilters) {

                    var currentUrl = new URL(window.location.href);

                    var _url = new URL(roomUrl);

                    _url.searchParams.set('filters', currentUrl.searchParams.get('filters'));



                    roomUrl = _url.href;

                }

            }



            var href = event.currentTarget.href || event.currentTarget.dataset.href;

            var url = href + encodeURIComponent(roomUrl);



            var windowFeatures = 'width=' + width + ',height=' + height + ',left=' + left + ',top=' + top + ',location=0,menubar=0,toolbar=0,status=0,scrollbars=1,resizable=1';



            var popup = window.open(url, 'Social Share', windowFeatures);



            if (popup) popup.focus();

        };



        // this.addEventListener = function (elementId, event, func) {

        //     const element = document.getElementById(elementId);

        //     if (element) {

        //         element.addEventListener(event, func);

        //     }

        // };



        // @jscrambler define domainLock {domains:[app001.3droomvisualizer.com, visualizer.restile.com, visualiser.sandstoneworks.com.au, simulator.stoneline.com.tr, visualizer2d.globalquartz.in, tilevisualizer.designtiles.com.au, tiledepot.3droomvisualizer.com, visualizer.metztiles.com.au, visualizer.metztiles.com.au, visualizer.alkhaleejceramics.com, 8ba86c312c.mbapp.wnpower.host, visualiser.floorsdirectltd.co.uk, tilevisualizer.kimgres.com, www.wissam.tilescarreaux.com, vis.florexceramic.in, app.niceramics.com, facciatavision.viva.co.in, visualizer.mahalaxmitiles.com, stoneline.3droomvisualizer.com, stonecash.visualizer.live, tilevisualizer.pavits.com, app.conceptvisualizer.com, facciatavision.viva.co.in, tilescarreaux.3droomvisualizer.com, tiledesigner.stile.com.pk, diy.saifurnitureindia.co.in, floorvisualizer.welspunflooring.com, simulator.machucatile.com, visualizer.topcarpetsandfloors.co.za, visualizer.ashhalan.online, visualizer.clubceramic.com, tilevisualizer.himflor.in, floorsdirect.3droomvisualizer.com, tdcc2.3dtilevisualizer.com, app.simuladorfv.com, tilevisualiser.colortile.com.au, visualizer.cletile.com, floorvisualizer.welspunflooring.com]} as dL

        // @jscrambler enable dL

        function init() {

            $('#topPanelHideBtn').click(_this.topPanelToggle);

            $('#topPanelCloseBtn').click(_this.topPanelToggle);



            $('#topPanelGroutSizeRange').on('input', _this.changeGroutSizeText);

            $('#topPanelTilesSort').change(_this.changeTilesSort);

            $('#bottomMenuFullScreen').click(_this.changeFullScreenMode);



            $('.top-panel-button').click(_this.showAdditionalOptions);



            $('#bookmarkSavedRoomLink').click(bookmarkLink);



            if (_this.isMobileDevice()) $('.copyright').remove();

        }



        init();

    }



    UI.roomCanvas = document.getElementById('roomCanvas'); // todo optimize



    UI.updateCanvasStyle = function (title) {

        if (title && typeof title === 'string') {

            UI.roomCanvas.title = 'Change ' + title;

            UI.roomCanvas.style.cursor = 'url("/img/icons/brush.png") 18 46, pointer';

        } else {

            UI.roomCanvas.title = '';

            UI.roomCanvas.style.cursor = 'unset';

        }

    };



    /**

     * Returns true if page opened on mobile device

     *

     * @method isMobileDevice

     * @returns {boolean}

     */

    UI.isMobileDevice = function () {

        if (navigator.userAgent.match(/Android/i) || navigator.userAgent.match(/webOS/i) || navigator.userAgent.match(/BlackBerry/i) || navigator.userAgent.match(/iPhone/i) || navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPod/i) || navigator.userAgent.match(/Opera Mini/i) || navigator.userAgent.match(/IEMobile/i) || navigator.userAgent.match(/Windows Phone/i)) {

            return true;

        }

        return false;

    };



    var LoadingAnimation = function () {

        function LoadingAnimation() {

            _classCallCheck(this, LoadingAnimation);



            this.loadingItems = 0;

            this.preLoader = false;

        }



        _createClass(LoadingAnimation, [{

            key: 'show',

            value: function show() {

                this.loadingItems += 1;

                if (!this.preLoader) {

                    this.preLoader = true;

                    document.getElementById('container').style.cursor = 'wait';

                    window.$('#loadAnimationContainer').show();

                }

            }

        }, {

            key: 'hide',

            value: function hide() {

                this.loadingItems -= 1;

                if (this.loadingItems <= 0 && this.preLoader) {

                    this.loadingItems = 0;

                    this.preLoader = false;

                    document.getElementById('container').style.cursor = 'unset';

                    window.$('#loadAnimationContainer').hide();

                }

            }

        }]);



        return LoadingAnimation;

    }();



    var loadingAnimation = new LoadingAnimation();



    var RoomLoadProgress = {

        start: function start() {

            window.$('#sourceLoadProgressBarContainer').show();



            var progressBar = document.getElementById('sourceLoadProgressBar');

            if (!progressBar) return;



            progressBar.textContent = '10%';

            if (progressBar.classList.contains('progress-bar-striped')) {

                progressBar.style.width = '10%';

            }

        },

        progress: function progress(itemsLoaded, itemsTotal) {

            var progressBar = document.getElementById('sourceLoadProgressBar');

            if (!progressBar) return;



            var value = Math.floor(itemsLoaded / itemsTotal * 80 + 10) + '%';

            progressBar.textContent = value;

            if (progressBar.classList.contains('progress-bar-striped')) {

                progressBar.style.width = value;

            }

        },

        end: function end() {

            // window.$('#sourceLoadProgressBarContainer').hide();

            window.$('#sourceLoadProgressBarContainer').remove();



            var progressBar = document.getElementById('sourceLoadProgressBar');

            if (!progressBar) return;



            progressBar.textContent = '90%';

            if (progressBar.classList.contains('progress-bar-striped')) {

                progressBar.style.width = '90%';

            }

        },

        setBackground: function setBackground(image, smallImage) {

            // TODO move to PHP

            var roomLoaderBackground = document.getElementById('roomLoaderBackground');



            if (smallImage) {

                var img = new Image();

                img.src = smallImage;

                roomLoaderBackground.appendChild(img);

            }



            if (image) {

                var _img = new Image();

                _img.src = image;

                roomLoaderBackground.appendChild(_img);

            }

        }

    };



    var API = function (window) {

        var vendor = 'TracingIdea';

        var app = 'TileVisualizer';



        if (!window[vendor]) window[vendor] = {};

        if (!window[vendor][app]) window[vendor][app] = {};



        var api = window[vendor][app];



        return {

            addMethod: function addMethod(name, method) {

                api[name] = method;

            }

        };

    }(window);



    // // import { UI } from '../InteriorUI.js';



    var tiles = [];



    var onTileClick = void 0;



    function Tile(tileData, index) {

        this.id = Number(tileData.id);

        this.index = index;

        this.custom = Boolean(tileData.custom);



        this.name = tileData.name || '';



        this.file = tileData.file || '';

        this.icon = tileData.icon || tileData.file;

        this.width = Number(tileData.width) || 400;

        this.height = Number(tileData.height) || 400;

        this.size = this.width + 'x' + this.height;

        this.shape = tileData.shape || 'square';

        this.surface = tileData.surface;

        this.grout = Number(tileData.grout) || 0;



        this.price = tileData.price;

        this.url = tileData.url;



        this.rotoPrintSetName = tileData.rotoPrintSetName || '';

        if (window.JsConstants.config.Product.rotoPrintSetAsName && this.rotoPrintSetName) {

            this.name = this.rotoPrintSetName;

        }



        this.created_at = tileData.created_at;



        this.shapePreparedSet = this.shape === 'preparedSet' || this.shape === 'notionHerringbon' || this.shape === 'riverstoneRohmboid' || this.shape === 'rivertsoneChevron' || this.shape === 'stoneSystemCombo';



        this.parseExpandableProperties(tileData.expProps);



        this.finish = tileData.finish || ''; // glossy

        this.usedColors = tileData.usedColors || '';



        this.needsRotate = tileData.needsRotate;



        // this.highlighted = Boolean(this.buildersRange);



        if (tileData.li) {

            this.li = tileData.li;

        } else {

            this.createTileLi();

        }

    }

    (function () {

        this.preparedSetOffset = { x: 0, y: 0 };



        var rotoPrintSets = [];



        rotoPrintSets.add = function (setName, surface) {

            var name = setName.trim().toLowerCase();

            var itemExist = rotoPrintSets.some(function (rotoPrintSet) {

                return rotoPrintSet.name === name && rotoPrintSet.surface === surface;

            });

            if (!itemExist) {

                rotoPrintSets.push({ name: name, surface: surface });

                return true;

            }

            return false;

        };



        function selectTile(event, secondLayerTileIndex, secondLayer) {

            var tileIndex = secondLayer ? secondLayerTileIndex : this.dataset.index;



            if (typeof onTileClick === 'function') {

                onTileClick(tileIndex, secondLayer);

            }

        }



        function setSecondLayerTile(event) {

            event.stopPropagation();

            selectTile(event, this.dataset.index, true);

        }



        this.parseExpandableProperties = function (expProps) {

            if (expProps) {

                var expandableProperties = JSON.parse(expProps);

                for (var propertyName in expandableProperties) {

                    if (expandableProperties.hasOwnProperty(propertyName) && !this.hasOwnProperty(propertyName)) {

                        this[propertyName] = expandableProperties[propertyName];

                    }

                }

            }

        };



        this.getExtraOptionsText = function () {

            var _this6 = this;



            var htmlString = '';

            var options = window.JsConstants.config.tileExtraOptions;

            if (Array.isArray(options)) {

                options.forEach(function (option) {

                    if (option && _this6.hasOwnProperty(option) && _this6[option]) {

                        var optionText = Locale.lang(option, _this6[option]);

                        htmlString += '<p>' + optionText + '</p>';

                    }

                });

            }

            return htmlString;

        };



        this.getPriceText = function () {

            if (window.JsConstants.config.ProductInfo.price && this.price) {

                var priceText = Locale.lang('PRICE_TEMPLATE', this.price);

                return '<p class="-price">' + priceText + '</p>';

            }

            return '';

        };



        this.getInfoText = function () {

            var config = window.JsConstants.config.ProductInfo;



            var size = config.size ? '<p>' + Locale.lang('Size') + ': ' + this.width + 'mm x ' + this.height + 'mm</p>' : '';



            var finish = config.finish && this.finish ? '<p>' + Locale.lang('Finish') + ': ' + Locale.lang(this.finish) + '</p>' : '';



            var url = config.url && this.url ? '<p><a href="' + this.url + '" target="blank">' + Locale.lang('PRODUCT_URL') + '</a></p>' : '';



            var usedColors = config.colors && this.usedColors ? '<p>' + Locale.lang('COLORS_USED') + ': ' + this.usedColors + '</p>' : '';



            var shape = config.shape ? '<p>' + Locale.lang('Shape') + ': ' + Locale.lang(this.shape) + '</p>' : '';



            var rotoPrintSet = config.rotoPrintSet && this.rotoPrintSetName ? '<p>' + Locale.lang('Roto Print Set') + ': ' + Locale.lang(this.rotoPrintSetName) + '</p>' : '';



            if (config.style === 'Client3') {

                var urlBtn = url ? '<div class="-url"><p>Order Sample</p>' + url + '</div>' : '';

                return '<div class="tile-list-text">\n                    <p class="-caption">' + this.name + '</p>\n                    <div>' + this.getExtraOptionsText() + ' ' + this.getPriceText() + '</div>\n                    ' + urlBtn + '\n                </div>';

            }



            return '<div class="tile-list-text">\n                <p class="-caption">' + this.name + '</p>\n                ' + this.getExtraOptionsText() + '\n                ' + size + ' ' + shape + ' ' + finish + ' ' + rotoPrintSet + '\n                ' + this.getPriceText() + ' ' + url + ' ' + usedColors + '\n            </div>';

        };



        this.createTileLi = function () {

            this.iconImage = document.createElement('img');

            this.iconImage.class = 'tile-list-thumbnail';



            var $imageHolder = $('<div class="tile-list-thumbnail-image-holder"></div>').append(this.iconImage);



            var $tileText = $(this.getInfoText());



            var liClass = 'top-panel-content-tiles-list-item';

            if (this.highlighted) liClass += ' top-panel-content-tiles-list-item-highlighted';



            var $li = $('<li id="tile_' + this.index + '" data-index="' + this.index + '"  class="' + liClass + '" style="display: none;"></li>').click(selectTile).append($imageHolder, $tileText);



            var li = $li[0];



            if (this.rotoPrintSetName) {

                var rotoPrintSetAdded = rotoPrintSets.add(this.rotoPrintSetName, this.surface);

                if (!rotoPrintSetAdded) {

                    li.rotoHidden = true;

                    li.style.display = 'none';

                }

            }



            if (this.shape === 'square' || this.shape === 'rectangle' || this.shape === 'diamond') {

                var $btnLayer1 = $('<button type="button" class="button-tile-list-choose-tile">1</button>');



                var $btnLayer2 = $('<button type="button" data-index="' + this.index + '" class="button-tile-list-choose-tile">2</button>').click(setSecondLayerTile);

                li.layer2btn = $btnLayer2[0];



                $li.append($('<div class="buttons-holder-tile-list-choose-tile" style="display: none;"></div>').append($btnLayer1, $btnLayer2));

            }



            this.li = li;

        };



        this.getRotoPrintSet = function () {

            var _this7 = this;



            // return tiles.getRotoPrintSet(this);

            if (this.rotoPrintSetName && typeof this.rotoPrintSetName === 'string') {

                var rotoPrintTiles = [];

                tiles.forEach(function (tile) {

                    if (tile.rotoPrintSetName === _this7.rotoPrintSetName) {

                        rotoPrintTiles.push(tile);

                    }

                });

                return rotoPrintTiles;

            }

            return [this];

        };



        this.getRandomInSet = function () {

            // return tiles.getRotoPrintSet(this);

            var tilesSet = this.getRotoPrintSet();

            if (tilesSet.length > 1) {

                return tilesSet[Math.floor(Math.random() * tilesSet.length)];

            }

            return this;

        };



        this.hide = function () {

            if (this.li.style.display !== 'none') this.li.style.display = 'none';

        };



        this.show = function () {

            if (this.li.style.display !== '') this.li.style.display = '';

        };



        this.remove = function () {

            this.hide();

            this.removed = true;

            // todo clear surfaces

        };

    }).call(Tile.prototype);



    tiles.getById = function (tileId, custom) {

        var foundTile = void 0;

        var id = Number(tileId);

        if (!isNaN(id)) {

            this.some(function (tile) {

                if (tile.id === id && Boolean(tile.custom) === Boolean(custom)) {

                    foundTile = tile;

                    return true;

                }

            });

        }

        return foundTile;

    };



    tiles.getIndexById = function (id, custom) {

        var tile = tiles.getById(id, custom);

        return tile && tile.index;

    };



    tiles.isExist = function (id, custom) {

        return Boolean(tiles.getById(id, custom));

    };



    tiles.add = function (tileData) {

        if (tiles.isExist(tileData.id, tileData.custom)) return;



        var tile = new Tile(tileData, tiles.length);

        tiles.push(tile);



        return tile;

    };



    tiles.remove = function (id, custom) {

        var tile = tiles.getById(id, custom);



        if (tile) tile.remove();

    };



    tiles.getRotoPrintSet = function (tile) {

        return tile && tile.getRotoPrintSet();

    };



    tiles.getRandomInSet = function (tile) {

        return tile && tile.getRandomInSet();

    };



    tiles.updateLayerButtons = function (tileIndex) {

        tiles.forEach(function (tile) {

            if (tile.li.layer2btn) {

                if (tileIndex === undefined || tiles[tileIndex].shape !== 'hexagon' && tiles[tileIndex].width === tile.width && tiles[tileIndex].height === tile.height) {

                    tile.li.layer2btn.disabled = '';

                } else {

                    tile.li.layer2btn.disabled = 'disabled';

                }

            }

        });

    };



    tiles.showHideLayerButtons = function (surface, fillTypeIndex) {

        var display = 'none';

        if (fillTypeIndex === 1) {

            display = '';

            tiles.updateLayerButtons(surface.tileIndex);

        } else {

            surface.tile2Index = undefined;

        }

        $('.buttons-holder-tile-list-choose-tile').css('display', display);

    };



    // isTilesSame

    tiles.isSame = function (item1, item2) {

        var tile1 = typeof item1 === 'number' ? tiles[item1] : (typeof item1 === 'undefined' ? 'undefined' : _typeof(item1)) === 'object' ? item1 : undefined;



        var tile2 = typeof item2 === 'number' ? tiles[item2] : (typeof item2 === 'undefined' ? 'undefined' : _typeof(item2)) === 'object' ? item2 : undefined;



        if (tile1 && tile2 && tile1.shape === tile2.shape && tile1.width === tile2.width && tile1.height === tile2.height) {

            return true;

        }

        return false;

    };



    tiles.enabledPatternButtons = function (surface) {

        var tile = {};

        if (surface.tileIndex !== undefined) {

            tile = tiles[surface.tileIndex];

        }



        switch (tile.shape) {

            case 'square':

            case 'rectangle':

                document.getElementById('topPanelSurfacePattern_1').disabled = '';

                document.getElementById('topPanelSurfacePattern_2').disabled = '';

                document.getElementById('topPanelSurfacePattern_3').disabled = '';

                break;



            case 'diamond':

                if (surface.fillTypeIndex > 1) {

                    surface.fillTypeIndex = 0;

                    tiles.showHideLayerButtons(surface, 0);

                    document.getElementById('topPanelSurfacePattern_0').checked = true;

                }

                document.getElementById('topPanelSurfacePattern_1').disabled = '';

                document.getElementById('topPanelSurfacePattern_2').disabled = 'disabled';

                document.getElementById('topPanelSurfacePattern_3').disabled = 'disabled';

                break;



            default:

                // hexagon and etc

                if (surface.fillTypeIndex > 0) {

                    surface.fillTypeIndex = 0;

                    tiles.showHideLayerButtons(surface, 0);

                    document.getElementById('topPanelSurfacePattern_0').checked = true;

                }

                document.getElementById('topPanelSurfacePattern_1').disabled = 'disabled';

                document.getElementById('topPanelSurfacePattern_2').disabled = 'disabled';

                document.getElementById('topPanelSurfacePattern_3').disabled = 'disabled';

                break;

        }



        if (tile.shapePreparedSet) {

            if (surface.rotation === 45 || surface.rotation === 135) surface.rotate(0);

            document.getElementById('topPanelSurfaceRotation_0').checked = true;

            document.getElementById('topPanelSurfaceRotation_45').disabled = 'disabled';

            document.getElementById('topPanelSurfaceRotationLabel_45').classList.add('disabled');

            document.getElementById('topPanelSurfaceRotation_135').disabled = 'disabled';

            document.getElementById('topPanelSurfaceRotationLabel_135').classList.add('disabled');

        } else {

            document.getElementById('topPanelSurfaceRotation_45').disabled = '';

            document.getElementById('topPanelSurfaceRotationLabel_45').classList.remove('disabled');

            document.getElementById('topPanelSurfaceRotation_135').disabled = '';

            document.getElementById('topPanelSurfaceRotationLabel_135').classList.remove('disabled');

        }

    };



    function showTileIcons() {

        // const indexes = tiles.map((tile, index) => index);

        var tilesListBox = document.getElementById('topPanelTilesListBox');



        var showIcons = function showIcons() {

            tiles.forEach(function (tile) {

                if (tile.iconImage && !tile.iconImage.src && tile.li.style.display !== 'none' && tile.li.offsetTop - tilesListBox.scrollTop < window.innerHeight + 1000 && tile.li.offsetTop - tilesListBox.scrollTop > -1000) {

                    tile.iconImage.src = tile.icon;

                }

            });

        };



        tilesListBox.addEventListener('scroll', showIcons);



        showIcons();



        return showIcons;

    }



    function fillTilesList(tilesData) {

        if (Array.isArray(tilesData)) {

            tilesData.forEach(function (tileData) {

                return tiles.add(tileData);

            });

        }

    }



    function fillCustomTiles(loadedTiles) {

        function parseTileName(url) {

            if (url && typeof url === 'string') {

                var fileName = url.match(/[^/]+(?=\.\w+$)/)[0].replace('_', ' ');

                return fileName.charAt(0).toUpperCase() + fileName.slice(1);

            }

            return 'Tile';

        }



        if (Array.isArray(loadedTiles)) {

            loadedTiles.forEach(function (tileData) {

                var settings = JSON.parse(tileData.settings);



                tiles.add({

                    id: tileData.id,

                    custom: true,

                    name: parseTileName(settings.baseTileUrl),

                    width: tileData.width,

                    height: tileData.height,

                    shape: tileData.shape,

                    file: tileData.file,

                    usedColors: settings.usedColorNames.join(' / '),

                    needsRotate: tileData.shape === 'hexagon'

                });

            });

        }

    }



    // @jscrambler define domainLock {domains:[app001.3droomvisualizer.com, visualizer.restile.com, visualiser.sandstoneworks.com.au, simulator.stoneline.com.tr, visualizer2d.globalquartz.in, tilevisualizer.designtiles.com.au, tiledepot.3droomvisualizer.com, visualizer.metztiles.com.au, visualizer.metztiles.com.au, visualizer.alkhaleejceramics.com, 8ba86c312c.mbapp.wnpower.host, visualiser.floorsdirectltd.co.uk, tilevisualizer.kimgres.com, www.wissam.tilescarreaux.com, vis.florexceramic.in, app.niceramics.com, facciatavision.viva.co.in, visualizer.mahalaxmitiles.com, stoneline.3droomvisualizer.com, stonecash.visualizer.live, tilevisualizer.pavits.com, app.conceptvisualizer.com, facciatavision.viva.co.in, tilescarreaux.3droomvisualizer.com, tiledesigner.stile.com.pk, diy.saifurnitureindia.co.in, floorvisualizer.welspunflooring.com, simulator.machucatile.com, visualizer.topcarpetsandfloors.co.za, visualizer.ashhalan.online, visualizer.clubceramic.com, tilevisualizer.himflor.in, floorsdirect.3droomvisualizer.com, tdcc2.3dtilevisualizer.com, app.simuladorfv.com, tilevisualiser.colortile.com.au, visualizer.cletile.com, floorvisualizer.welspunflooring.com, poplar.3dtilevisualizer.com]} as dL

    // @jscrambler enable dL

    tiles.load = function (onLoad, onClick) {

        $.ajax({

            url: '/get/tiles',

            success: function success(tilesData) {

                fillTilesList(tilesData);



                tiles.showIcons = showTileIcons();



                onLoad();

                onTileClick = onClick;

            }

        });

    };



    tiles.fill = function (onClick, loadedData) {

        fillTilesList(loadedData.tiles);

        fillCustomTiles(loadedData.userCustomTiles);

        fillCustomTiles(loadedData.roomCustomTiles);

        onTileClick = onClick;



        tiles.showIcons = showTileIcons();

    };



    /**

     * Receive custom tile data and add it to Tiles list

     */

    API.addMethod('addTile', function (tileData) {

        var tile = tiles.add(tileData);

        tile.show();

        tile.iconImage.src = tile.icon;



        var list = document.getElementById('topPanelTilesListUl');

        list.insertBefore(tile.li, list.firstChild); // todo move to UI.js

    });



    /**

     * Remove custom tile data by id

     */

    API.addMethod('removeTile', tiles.remove);



    var TilesList = tiles;



    /* global THREE */



    var SURFACE_DEFAULTS = {

        color: '#ffffff',

        groutSize: Number(window.JsConstants.config.TiledSurface.groutSize) || 0,

        groutColor: '#ffffff',

        rotation: 0,

        fillTypeIndex: 0,

        freeDesign: false,

        // tile: undefined,

        // tileIndex: undefined,

        // tile2: undefined,

        // tile2Index: undefined,

        // texture: undefined,

        textureIndex: 0,

        skewSize: Number(window.JsConstants.config.TiledSurface.skewSize) || 0.5

    };



    var TiledSurface = function () {

        function TiledSurface(surfaceData) {

            _classCallCheck(this, TiledSurface);



            Object.assign(this, SURFACE_DEFAULTS);



            this.type = surfaceData.type;

            this.group = Number(surfaceData.group) || 0;



            // this.setGroutColor();

        }



        _createClass(TiledSurface, [{

            key: 'setColor',

            value: function setColor() {

                var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0xffffff;



                this.mesh.material.color.set(color);

                this.color = '#' + this.mesh.material.color.getHexString();

            }

        }, {

            key: 'setGroutColor',

            value: function setGroutColor() {

                var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0xffffff;



                if (this.groutMaterial) {

                    this.groutMaterial.color.set(color);

                } else {

                    this.groutMaterial = new THREE.MeshBasicMaterial({

                        color: color,

                        // depthWrite: false,

                        polygonOffset: true

                        // polygonOffsetFactor: -1,

                    });

                }

                this.groutColor = '#' + this.groutMaterial.color.getHexString();

                // this._update();

            }

        }, {

            key: '_useGrout',

            value: function _useGrout(tile) {

                if (tile && tile.grout) {

                    if (!this.groutSize && this._reservedGroutSize) {

                        this.groutSize = this._reservedGroutSize;

                    }

                } else if (this.groutSize) {

                    this._reservedGroutSize = this.groutSize;

                    this.groutSize = 0;

                }

            }

        }, {

            key: 'setGroutSize',

            value: function setGroutSize(value) {

                var groutSize = value === undefined ? SURFACE_DEFAULTS.groutSize : value;

                this.groutSize = Math.max(0, Math.min(24, groutSize)) || 0;

                // this._update();

                // this._updateMask();

            }

        }, {

            key: 'setFillType',

            value: function setFillType(value) {

                // this.clear();

                this.fillTypeIndex = Number(value) || 0;

                // const drawEver = this.fillTypeIndex === 1 ? 0 : undefined; // Chess

                // this._tiles.fill(drawEver);

                // this._updateMask();

            }

        }, {

            key: 'setSkewSize',

            value: function setSkewSize(value) {

                this.skewSize = Math.max(0.1, Math.min(0.9, Number(value) || SURFACE_DEFAULTS.skewSize));

            }

        }, {

            key: 'rotate',

            value: function rotate(angle) {

                this.rotation = Number(angle) || 0;

                // this.rotationRadians = THREE.Math.degToRad(this.rotation);

                // this._update();

                // this._updateMask();

            }

        }, {

            key: 'getSettings',

            value: function getSettings() {

                return {

                    color: this.color,

                    groutSize: this.groutSize || undefined,

                    groutColor: this.groutColor,

                    rotation: this.rotation || undefined,

                    fillTypeIndex: this.fillTypeIndex || undefined,

                    tileId: this.tile ? this.tile.id : undefined,

                    tileCustom: this.tile ? this.tile.custom : undefined,

                    tile2Id: this.tile2 ? this.tile2.id : undefined,

                    tile2Custom: this.tile2 ? this.tile2.custom : undefined,

                    skewSize: this.skewSize,

                    freeDesign: this.freeDesign || undefined,

                    freeDesignTiles: this.freeDesign ? this._getFreeDesignTilesSettings() : undefined

                };

            }

        }, {

            key: 'restoreSettings',

            value: function restoreSettings(sets) {

                if ((typeof sets === 'undefined' ? 'undefined' : _typeof(sets)) === 'object') {

                    if (sets.color) this.color = sets.color;

                    if (sets.groutSize) this.groutSize = sets.groutSize;

                    if (sets.groutColor) this.setGroutColor(sets.groutColor);

                    if (sets.rotation) this.rotate(sets.rotation);

                    if (sets.fillTypeIndex) this.fillTypeIndex = sets.fillTypeIndex;

                    if (sets.skewSize) this.skewSize = sets.skewSize;



                    if (sets.tileId) {

                        var tile = TilesList.getById(sets.tileId, sets.tileCustom);

                        this.setTile(tile);

                    }

                    if (sets.tile2Id) {

                        var _tile = TilesList.getById(sets.tile2Id, sets.tile2Custom);

                        this.setTile2(_tile);

                    }



                    if (sets.freeDesign) {

                        this.freeDesign = sets.freeDesign;

                        this._restoreFreeDesignTiles(sets.freeDesignTiles);

                    }



                    // this._update();

                    // this._updateMask();

                }

            }

        }, {

            key: 'setTile',

            value: function setTile(tile) {

                this._useGrout(tile);

                if ((typeof tile === 'undefined' ? 'undefined' : _typeof(tile)) === 'object') {

                    this.tile = tile;

                    this.tileIndex = tile.index;

                } else {

                    this.tile = undefined;

                    this.tileIndex = undefined;

                }

            }



            /**

             * Set tile for second layer of chess pattern

             * @param {Object} tile

             */



        }, {

            key: 'setTile2',

            value: function setTile2(tile) {

                if ((typeof tile === 'undefined' ? 'undefined' : _typeof(tile)) === 'object') {

                    this.tile2 = tile;

                    this.tile2Index = tile.index;

                } else {

                    this.tile2 = undefined;

                    this.tile2Index = undefined;

                }

            }

        }, {

            key: 'clearTile2',

            value: function clearTile2() {

                this.tile2 = undefined;

                this.tile2Index = undefined;

            }

        }, {

            key: 'setFreeDesign',

            value: function setFreeDesign(value) {

                this.freeDesign = Boolean(value); // value === true

                // this._freeDesignTiles.clear();

                // this._updateMask();

            }

        }, {

            key: '_getFreeDesignTilesSettings',

            value: function _getFreeDesignTilesSettings() {

                return this.freeDesignTiles;

            }

        }, {

            key: '_restoreFreeDesignTiles',

            value: function _restoreFreeDesignTiles(tilesSettings) {

                this.freeDesignTiles = tilesSettings;

            }

        }, {

            key: 'isTiledSurface',

            get: function get() {

                return true;

            }

        }]);



        return TiledSurface;

    }();



    /* global THREE */



    var Tile3d = function () {

        function Tile3d(anisotropy) {

            _classCallCheck(this, Tile3d);



            this._anisotropy = anisotropy || 1;

        }



        _createClass(Tile3d, [{

            key: '_nextPowerOf2',

            value: function _nextPowerOf2(x) {

                return Math.min(Math.pow(2, Math.ceil(Math.log(x) / Tile3d.Log2)), Tile3d.MaxTextureSize);

            }

        }, {

            key: '_resizeImageToPowerOfTwo',

            value: function _resizeImageToPowerOfTwo(image) {

                var canvas = document.createElement('canvas');

                var ctx = canvas.getContext('2d');

                canvas.width = this._nextPowerOf2(image.width);

                canvas.height = this._nextPowerOf2(image.height);

                ctx.drawImage(image, 0, 0, canvas.width, canvas.height);

                return canvas;

            }

        }, {

            key: '_rotateImage',

            value: function _rotateImage(image) {

                if (!image) return;



                var canvas = document.createElement('canvas');

                canvas.width = image.height;

                canvas.height = image.width;



                var ctx = canvas.getContext('2d');

                ctx.rotate(1.5707963267948966); // 90 * Math.PI / 180

                ctx.drawImage(image, 0, -image.height, image.width, image.height);

                ctx.setTransform(1, 0, 0, 1, 0, 0);



                return canvas;

            }

        }, {

            key: '_getGeometry',

            value: function _getGeometry(shape) {

                if (!Tile3d.Shapes[shape].geometry) {

                    var loader = new THREE.LegacyJSONLoader();

                    var newTile = loader.parse(Tile3d.Shapes[shape].meshData);

                    Tile3d.Shapes[shape].geometry = newTile.geometry;

                }

                return Tile3d.Shapes[shape].geometry;

            }



            // _htmlHexToColor(htmlHex) {

            //     const hex = htmlHex.replace('#', '0x');

            //     return new THREE.Color(0xffffff).setHex(hex);

            // }



        }, {

            key: '_getGroutMesh',

            value: function _getGroutMesh(geometry, size, material) {

                // const material = new THREE.MeshBasicMaterial({

                //     color: this._htmlHexToColor(color),

                //     polygonOffset: true,

                //     // polygonOffsetFactor: 2

                // });

                var mesh = new THREE.Mesh(geometry, material);

                mesh.position.y = -0.02;

                mesh.scale.x = this._tileMesh.scale.x + size * 2;

                mesh.scale.z = this._tileMesh.scale.z + size * 2;



                return mesh;

            }

        }, {

            key: '_getTexture',

            value: function _getTexture(image) {

                var canvas = this._resizeImageToPowerOfTwo(image);

                this.texture = new THREE.Texture(canvas);

                this.texture.premultiplyAlpha = false;

                this.texture.needsUpdate = true;

                this.texture.anisotropy = this._anisotropy;

                return this.texture;

            }

        }, {

            key: 'updateGrout',

            value: function updateGrout(size) {

                // , color

                if (this._groutMesh) {

                    // this._groutMesh.material.color.set(this._htmlHexToColor(color));

                    this._groutMesh.scale.x = this._tileMesh.scale.x + size * 2;

                    this._groutMesh.scale.z = this._tileMesh.scale.z + size * 2;

                }

            }

        }, {

            key: 'make',

            value: function make(tileImage, tile, groutSize, groutColor) {

                if (this.mesh) return this.mesh;



                var image = tile.needsRotate ? this._rotateImage(tileImage) : tileImage;



                var geometry = this._getGeometry(tile.shape);



                this.mesh = new THREE.Group();

                this.mesh.rotation.x = Tile3d.HalfPI;



                this.material = new THREE.MeshBasicMaterial({ map: this._getTexture(image) });

                if (tile.shapePreparedSet) {

                    this.material.transparent = true;

                    this.material.depthWrite = false;

                }

                this._tileMesh = new THREE.Mesh(geometry, this.material);



                this._tileMesh.scale.x = tile.width;

                this._tileMesh.scale.z = tile.height;

                this.mesh.add(this._tileMesh);



                if (!tile.shapePreparedSet) {

                    this._groutMesh = this._getGroutMesh(geometry, groutSize, groutColor);

                    this.mesh.add(this._groutMesh);

                }



                return this.mesh;

            }

        }, {

            key: 'makePlane',

            value: function makePlane(plane) {

                if (this.mesh) {

                    return this.mesh;

                }



                var geometry = this._getGeometry(plane.shape);

                var material = new THREE.MeshBasicMaterial();



                this.mesh = new THREE.Mesh(geometry, material);



                this.mesh.rotation.x = Tile3d.HalfPI;

                this.mesh.scale.x = plane.width;

                this.mesh.scale.z = plane.height;



                return this.mesh;

            }

        }]);



        return Tile3d;

    }();



    var SQUARE_PLANE_CORNERS_POINTS = [[0, 0], [1, 0], [1, 1], [0, 1]];

    var SQUARE_PLANE_MESH_DATA = {

        'metadata': {

            'type': 'Geometry',

            'normals': 1,

            'version': 3,

            'faces': 1,

            'vertices': 4,

            'uvs': 1,

            'generator': 'io_three'

        },

        'faces': [41, 0, 1, 3, 2, 0, 1, 2, 3, 0, 0, 0, 0],

        'vertices': [-0.5, 0, 0.5, 0.5, 0, 0.5, -0.5, 0, -0.5, 0.5, 0, -0.5],

        'uvs': [[0, 0, 1, 0, 1, 1, 0, 1]],

        'normals': [0, 1, 0]

    };



    Tile3d.Log2 = Math.log(2);

    Tile3d.HalfPI = Math.PI / 2;

    Tile3d.MaxTextureSize = 1024;

    Tile3d.Shapes = {

        square: {

            name: 'square',

            cornersPoints: SQUARE_PLANE_CORNERS_POINTS,

            meshData: SQUARE_PLANE_MESH_DATA,

            rotationStep: Math.PI / 2

        },



        rectangle: {

            name: 'rectangle',

            cornersPoints: SQUARE_PLANE_CORNERS_POINTS,

            meshData: SQUARE_PLANE_MESH_DATA,

            rotationStep: Math.PI

        },



        hexagon: {

            name: 'hexagon',

            cornersPoints: [[0.25, 0], [0.75, 0], [1, 0.5], [0.75, 1], [0.25, 1], [0, 0.5]],

            meshData: {

                'metadata': {

                    'type': 'Geometry',

                    'normals': 4,

                    'version': 3,

                    'faces': 4,

                    'vertices': 6,

                    'uvs': 1,

                    'generator': 'io_three'

                },

                'faces': [40, 0, 1, 2, 5, 0, 1, 0, 0, 0, 40, 2, 3, 4, 1, 2, 3, 1, 1, 1, 40, 4, 5, 0, 3, 4, 5, 2, 2, 2, 40, 2, 4, 0, 1, 3, 5, 3, 3, 3],

                'vertices': [0.5, 0, 0, 0.25, 0, -0.5, -0.25, 0, -0.5, -0.5, 0, 0, -0.25, 0, 0.5, 0.25, 0, 0.5],

                'uvs': [[0.75, 1, 0.25, 1, 0, 0.5, 0.25, 0, 0.75, 0, 1, 0.5]],

                'normals': [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0]

            },

            rotationStep: Math.PI / 3

        },



        diamond: {

            name: 'diamond',

            cornersPoints: [[0.5, 0], [1, 0.5], [0.5, 1], [0, 0.5]],

            meshData: {

                'metadata': {

                    'type': 'Geometry',

                    'normals': 1,

                    'version': 3,

                    'faces': 1,

                    'vertices': 4,

                    'uvs': 1,

                    'generator': 'io_three'

                },

                'faces': [41, 0, 1, 3, 2, 0, 1, 2, 3, 0, 0, 0, 0],

                'vertices': [-0.5, 0, 0, 0, 0, 0.5, 0, -0, -0.5, 0.5, 0, 0],

                'uvs': [[0, 0.5, 0.5, 0, 1, 0.5, 0.5, 1]],

                'normals': [0, 1, 0]

            },

            rotationStep: Math.PI

        },



        quadSet: {

            name: 'quadSet',

            cornersPoints: SQUARE_PLANE_CORNERS_POINTS,

            meshData: SQUARE_PLANE_MESH_DATA,

            rotationStep: Math.PI / 2

        },



        preparedSet: {

            name: 'preparedSet',

            cornersPoints: SQUARE_PLANE_CORNERS_POINTS,

            meshData: SQUARE_PLANE_MESH_DATA

        },



        notionHerringbon: {

            name: 'notionHerringbon',

            title: 'Notion Herringbon',

            cornersPoints: SQUARE_PLANE_CORNERS_POINTS,

            meshData: SQUARE_PLANE_MESH_DATA

            // width: 302,

            // height: 294,

            // offsetX: 20,

            // offsetY: 68,

        },



        riverstoneRohmboid: {

            name: 'riverstoneRohmboid',

            title: 'Riverstone Rohmboid',

            cornersPoints: SQUARE_PLANE_CORNERS_POINTS,

            meshData: SQUARE_PLANE_MESH_DATA

            // width: 328,

            // height: 264,

            // offsetX: 65,

            // offsetY: 37,

        },



        rivertsoneChevron: {

            name: 'rivertsoneChevron',

            title: 'Rivertsone Chevron',

            cornersPoints: SQUARE_PLANE_CORNERS_POINTS,

            meshData: SQUARE_PLANE_MESH_DATA

            // width: 238,

            // height: 298,

            // offsetX: 0,

            // offsetY: 55,

        },



        stoneSystemCombo: {

            name: 'stoneSystemCombo',

            title: 'Stone System Combo',

            cornersPoints: SQUARE_PLANE_CORNERS_POINTS,

            meshData: SQUARE_PLANE_MESH_DATA

            // width: 711,

            // height: 416, // 306

            // offsetX: 60,

            // offsetY: 0,

        }

    };



    // @ts-check

    var NEAR = 0.1;

    var FAR = 20000;

    var FOV = 30;

    var MAX_FOV = 170;

    var WIDTH = 2000;

    var HEIGHT = 1250;

    var CAMERA_POSITION = 100;

    var MAX_CAMERA_LAYERS = 32;



    var SurfaceProjection = function () {

        function SurfaceProjection(fov, horizontalOffset, verticalOffset) {

            _classCallCheck(this, SurfaceProjection);



            var viewAngle = Number(fov) || FOV;

            this.width = WIDTH;

            this.height = HEIGHT;

            this._renderer = new THREE.WebGLRenderer({

                alpha: true,

                antialias: true,

                preserveDrawingBuffer: true

            });

            this._renderer.setSize(this.width, this.height);

            var aspectRatio = this.width / this.height;

            this.maxAnisotropy = this._renderer.capabilities.getMaxAnisotropy();

            this._camera = new THREE.PerspectiveCamera(viewAngle, aspectRatio, NEAR, FAR);

            this._camera.position.set(0, 0, CAMERA_POSITION);

            this.setViewOffset(horizontalOffset, verticalOffset);

            this._scene = new THREE.Scene();

            this.canvas = this._renderer.domElement;

        }



        _createClass(SurfaceProjection, [{

            key: 'addObject',

            value: function addObject(object) {

                this._scene.add(object);

            }

        }, {

            key: 'getIntersect',

            value: function getIntersect(point, object, direction) {

                this._changeCameraDirection(direction);

                return this._getRaycaster(point).intersectObject(object);

            }

        }, {

            key: 'getIntersects',

            value: function getIntersects(point, objects, direction) {

                this._changeCameraDirection(direction);

                return this._getRaycaster(point).intersectObjects(objects, true);

            }

        }, {

            key: 'render',

            value: function render(layers, direction) {

                this._setCameraLayers(layers);

                this._changeCameraDirection(direction);

                this._render();

            }

        }, {

            key: 'setCameraFov',

            value: function setCameraFov(value) {

                var fov = Number(value) || FOV;

                if (fov > 0) {

                    this._camera.fov = Math.max(1, Math.min(MAX_FOV, fov));

                    this._camera.updateProjectionMatrix();

                }

            }

        }, {

            key: 'setSize',

            value: function setSize(width, height) {

                if (this.width === width && this.height === height) {

                    return;

                }

                this.width = width;

                this.height = height;

                this._renderer.setSize(width, height);

                this._camera.aspect = width / height;

                this._camera.updateProjectionMatrix();

            }

        }, {

            key: 'setViewOffset',

            value: function setViewOffset(horizontalOffset, verticalOffset) {

                var hOffset = Number(horizontalOffset) || 0;

                var fullWidth = this.width + Math.abs(hOffset) * 2;

                var left = hOffset >= 0 ? 0 : fullWidth - this.width;

                var vOffset = Number(verticalOffset) || 0;

                var fullHeight = this.height + Math.abs(vOffset) * 2;

                var top = vOffset >= 0 ? 0 : fullHeight - this.height;

                this._camera.setViewOffset(fullWidth, fullHeight, left, top, this.width, this.height);

            }

        }, {

            key: '_changeCameraDirection',

            value: function _changeCameraDirection(direction) {

                if (direction && this._sideDirection !== direction) {

                    this._sideDirection = direction;

                    this._camera.position.set(0, 0, 0);

                    this._camera.lookAt(direction.position);

                }

            }

        }, {

            key: '_getRaycaster',

            value: function _getRaycaster(point) {

                if (!this._raycaster) {

                    this._raycaster = new THREE.Raycaster();

                }

                this._render();

                this._raycaster.setFromCamera(point, this._camera);

                return this._raycaster;

            }

        }, {

            key: '_render',

            value: function _render() {

                this._renderer.render(this._scene, this._camera);

            }

        }, {

            key: '_setCameraLayers',

            value: function _setCameraLayers(value) {

                if (value !== undefined) {

                    var layers = Math.floor(Number(value) || 0);

                    this._camera.layers.set(Math.max(0, Math.min(MAX_CAMERA_LAYERS, layers)));

                }

            }

        }]);



        return SurfaceProjection;

    }();



    var DEG = Math.PI / 180;

    var ROTATION_90_DEG = Math.PI / 2;

    var ROTATION_180_DEG = Math.PI;

    var ROTATION_270_DEG = Math.PI * 3 / 2;



    var MAX_TILED_PLANE_SIZE = 10000; // mm

    var PLANE_SIZE = 200000;

    var HEXAGON_ASPECT_RATIO = 0.866;

    var DIAMOND_ASPECT_RATIO = 0.707;



    var fillTypes = [{ name: 'Standard' }, { name: 'Chess', drawEver: 0 }, // 0 or 1 for even or odd

        { name: 'Horizontal Skew' }, { name: 'Vertical Skew' }];



    var TiledSurface2d = function (_TiledSurface) {

        _inherits(TiledSurface2d, _TiledSurface);



        function TiledSurface2d(surfaceData, render) {

            _classCallCheck(this, TiledSurface2d);



            var _this8 = _possibleConstructorReturn(this, (TiledSurface2d.__proto__ || Object.getPrototypeOf(TiledSurface2d)).call(this, surfaceData));



            _this8._surfaceData = surfaceData;

            _this8._render = render;



            _this8._gridHelper = false;



            _this8.layers = undefined;



            _this8._tilePositions();

            _this8._freeDesignTileApproxPositions();



            _this8.setGroutColor();



            _this8._init();

            return _this8;

        }



        _createClass(TiledSurface2d, [{

            key: 'clear',

            value: function clear() {

                // Object.assign(this, SURFACE_DEFAULTS);



                this.freeDesignTiles = [];

            }

        }, {

            key: '_createIntersectsPlane',

            value: function _createIntersectsPlane() {

                var geometry = new window.THREE.PlaneGeometry(PLANE_SIZE, PLANE_SIZE); // plane size 200x200 meters actual size 100x100 meters

                var material = new window.THREE.MeshBasicMaterial({

                    color: 0xff0000,

                    transparent: true,

                    opacity: 0

                });

                var mesh = new window.THREE.Mesh(geometry, material);

                // mesh.position.z = -0.02;

                return mesh;

            }

        }, {

            key: '_setData',

            value: function _setData(data) {

                this[0] = data[0]; //  : 1, // tile_type

                this[1] = data[1]; //  : -64,   // Position(xyz)

                this[2] = data[2]; //  : -17.4, // Position(xyz)

                this[3] = data[3]; //  : 22,    // Position(xyz)

                this[4] = data[4]; //  : 0, // Rotation(xyz axises)

                this[5] = data[5]; //  : 0, // Rotation(xyz axises)

                this[6] = data[6]; //  : 0, // Rotation(xyz axises)

                this[7] = data[7]; //  : 70,    // Plane Size(height-width)

                this[8] = data[8]; //  : 150,   // Plane Size(height-width)

                this[9] = data[9]; //  : 12,    // Scaling(height-width)

                this[10] = data[10]; //  : 12,   // Scaling(height-width)

                this[11] = data[11]; //  : [] =  // Mask Path Points

                this[12] = data[12]; //  : 2,    // Grout v-Width !!! Unused !!!

                this[13] = data[13]; //  : 2,    // Grout h-Width !!! Unused !!!

                this[14] = data[14]; //  : 0,    // Skew(vertical-horizontal) !!! Unused !!!

                this[15] = data[15]; //  : 0,    // Skew(vertical-horizontal) !!! Unused !!!

                this[177] = data[177]; //  : 0,   // !!! Unused !!!

                this[176] = data[176]; //  : 'Wall'  // type

                this.cameraFov = data.cameraFov;

                this.viewVerticalOffset = data.viewVerticalOffset;

                this.viewHorizontalOffset = data.viewHorizontalOffset;

                this.sidesMaskPathPoints = data.sidesMaskPathPoints;



                this.type = this._surfaceData['176'].trim().toLowerCase();



                this.width = this[8];

                this.height = this[7];



                this.maxScale = Math.max(this[9], this[10]) / 1000;

                this.maxSize = Math.min(Math.max(this.width, this.height), MAX_TILED_PLANE_SIZE);



                this.container.position.x = this[1];

                this.container.position.y = this[2];

                this.container.position.z = this[3];

                this.container.rotation.x = this[4] * DEG;

                this.container.rotation.y = this[5] * DEG;

                this.container.rotation.z = this[6] * DEG;

                this.container.scale.set(this.maxScale, this.maxScale, 1);

            }



            // @jscrambler define domainLock {domains:[app001.3droomvisualizer.com, visualizer.restile.com, visualiser.sandstoneworks.com.au, simulator.stoneline.com.tr, visualizer2d.globalquartz.in, tilevisualizer.designtiles.com.au, tiledepot.3droomvisualizer.com, visualizer.metztiles.com.au, visualizer.metztiles.com.au, visualizer.alkhaleejceramics.com, 8ba86c312c.mbapp.wnpower.host, visualiser.floorsdirectltd.co.uk, tilevisualizer.kimgres.com, www.wissam.tilescarreaux.com, vis.florexceramic.in, app.niceramics.com, facciatavision.viva.co.in, visualizer.mahalaxmitiles.com, stoneline.3droomvisualizer.com, stonecash.visualizer.live, tilevisualizer.pavits.com, app.conceptvisualizer.com, facciatavision.viva.co.in, tilescarreaux.3droomvisualizer.com, tiledesigner.stile.com.pk, diy.saifurnitureindia.co.in, floorvisualizer.welspunflooring.com, simulator.machucatile.com, visualizer.topcarpetsandfloors.co.za, visualizer.ashhalan.online, visualizer.clubceramic.com, tilevisualizer.himflor.in, floorsdirect.3droomvisualizer.com, tdcc2.3dtilevisualizer.com, app.simuladorfv.com, tilevisualiser.colortile.com.au, visualizer.cletile.com, floorvisualizer.welspunflooring.com, poplar.3dtilevisualizer.com]} as dL

            // @jscrambler enable dL



        }, {

            key: '_init',

            value: function _init() {

                this.clear();



                this.container = new window.THREE.Group();



                this._setData(this._surfaceData);



                this.tilesContainer = new window.THREE.Group();

                this.container.add(this.tilesContainer);



                this.freeDesignTilesContainer = new window.THREE.Group();

                this.container.add(this.freeDesignTilesContainer);

                this.freeDesignTilesContainer.position.z = 0.04;



                this.intersectsPlane = this._createIntersectsPlane();

                this.container.add(this.intersectsPlane);



                this.projection = new SurfaceProjection(this.cameraFov, this.viewHorizontalOffset, this.viewVerticalOffset);

                this.projection.addObject(this.container);



                // this._render();

            }

        }, {

            key: 'update',

            value: function update(data) {

                this._setData(data);

                this.projection.setCameraFov(data.cameraFov);

                this.projection.setViewOffset(data.viewHorizontalOffset, data.viewVerticalOffset);

            }

        }, {

            key: '_isEven',

            value: function _isEven(number) {

                if (Math.round(number % 2) === 0) {

                    return true;

                }

                return false;

            }

        }, {

            key: '_isOdd',

            value: function _isOdd(number) {

                if (Math.round(Math.abs(number % 2)) === 1) {

                    return true;

                }

                return false;

            }

        }, {

            key: '_getRandomTile',

            value: function _getRandomTile(tilesArray, tiles$$1, i, j) {

                if (Array.isArray(tiles$$1) && tiles$$1.length > 1) {

                    var tile = tiles$$1[Math.floor(Math.random() * tiles$$1.length)];

                    if (tile.shape === 'square' || tile.shape === 'rectangle') {

                        if (tiles$$1.length > 2 && (tile === tilesArray[j][i - 1] || j > 0 && tile === tilesArray[j - 1][i])) {

                            return this._getRandomTile(tilesArray, tiles$$1, i, j);

                        }

                    } else if (tile.shape === 'hexagon') {

                        if (tiles$$1.length > 3) {

                            if (this._isEven(j)) {

                                if (j > 0 && tile === tilesArray[j - 1][i - 1] || j > 1 && tile === tilesArray[j - 2][i] || j > 0 && tile === tilesArray[j - 1][i]) {

                                    return this._getRandomTile(tilesArray, tiles$$1, i, j);

                                }

                            } else if (j > 0 && tile === tilesArray[j - 1][i + 1] || j > 0 && tile === tilesArray[j - 1][i] || j > 1 && tile === tilesArray[j - 2][i]) {

                                return this._getRandomTile(tilesArray, tiles$$1, i, j);

                            }

                        }

                    } else if (tile.shape === 'diamond') {

                        if (tiles$$1.length > 2) {

                            if (this._isEven(j)) {

                                if (j > 0 && tile === tilesArray[j - 1][i - 1] || j > 0 && tile === tilesArray[j - 1][i]) {

                                    return this._getRandomTile(tilesArray, tiles$$1, i, j);

                                }

                            } else if (j > 0 && tile === tilesArray[j - 1][i + 1] || j > 0 && tile === tilesArray[j - 1][i]) {

                                return this._getRandomTile(tilesArray, tiles$$1, i, j);

                            }

                        }

                    }

                    return tile;

                }

                return tiles$$1[0];

            }



            // getTilesSet(currentTile) {

            //     if (currentTile && currentTile.rotoPrintSetName) {

            //         var rotoPrintTiles = [];

            //         TilesList.forEach(tile => {

            //             if (tile.rotoPrintSetName === currentTile.rotoPrintSetName) {

            //                 rotoPrintTiles.push(tile);

            //             }

            //         });

            //         return rotoPrintTiles;

            //     }

            //     return [currentTile];

            // }



        }, {

            key: 'removeAllTiles',

            value: function removeAllTiles() {

                this._gridHelper = false;

                while (this.tilesContainer.children.length > 0) {

                    this.tilesContainer.remove(this.tilesContainer.children[0]);

                }

                while (this.freeDesignTilesContainer.children.length > 0) {

                    this.freeDesignTilesContainer.remove(this.freeDesignTilesContainer.children[0]);

                }

            }

        }, {

            key: '_setLayers',

            value: function _setLayers(object) {

                var _this9 = this;



                if (this.layers !== undefined && object) {

                    object.layers.set(this.layers);

                    if (Array.isArray(object.children)) {

                        object.children.forEach(function (child) {

                            child.layers.set(_this9.layers);

                            _this9._setLayers(child);

                        });

                    }

                }

            }

        }, {

            key: '_addTileToContainer',

            value: function _addTileToContainer(tile, container, position) {

                var mesh = tile.tile3d.mesh.clone();

                mesh.tile = tile;

                mesh.position.x = position.x + tile.width / 2;

                mesh.position.y = -(position.y + tile.height / 2);

                if (position.rotation) mesh.rotation.y = position.rotation;

                container.add(mesh);

                this._setLayers(mesh);

                return mesh;

            }

        }, {

            key: '_tilePositions',

            value: function _tilePositions() {

                var _this10 = this;



                this._getTilePosition = {

                    square: function square(options, tile) {

                        var x = options.xIndex * (tile.width + _this10.groutSize);

                        var y = options.yIndex * (tile.height + _this10.groutSize);



                        if (options.skew) {

                            if (options.skew.x > 0) {

                                x += (tile.width + _this10.groutSize) * options.skew.x;

                            }

                            if (options.skew.y > 0) {

                                y += (tile.height + _this10.groutSize) * options.skew.y;

                            }

                        }

                        return { x: x, y: y };

                    },



                    hexagon: function hexagon(options, tile) {

                        var x = void 0;

                        var groutSizeX = _this10.groutSize * HEXAGON_ASPECT_RATIO;



                        if (_this10._isEven(options.yIndex)) {

                            x = options.xIndex * (tile.width * 1.5 + groutSizeX * 2);

                        } else {

                            x = options.xIndex * (tile.width * 1.5 + groutSizeX * 2) + tile.width * 0.75 + groutSizeX;

                        }

                        var y = options.yIndex * (tile.height + _this10.groutSize) / 2;



                        return { x: x, y: y };

                    },



                    diamond: function diamond(options, tile) {

                        var x = void 0;

                        var groutSizeX = _this10.groutSize * DIAMOND_ASPECT_RATIO;



                        if (_this10._isEven(options.yIndex)) {

                            x = options.xIndex * (tile.width + groutSizeX * 2);

                        } else {

                            x = options.xIndex * (tile.width + groutSizeX * 2) + (tile.width / 2 + groutSizeX);

                        }

                        var y = options.yIndex * (tile.height + _this10.groutSize - tile.height / 2);



                        return { x: x, y: y };

                    },



                    preparedSet: function preparedSet(options, tile) {

                        var x = options.xIndex * (tile.width + _this10.groutSize - tile.preparedSetOffset.x);

                        var y = options.yIndex * (tile.height + _this10.groutSize - tile.preparedSetOffset.y);



                        return { x: x, y: y };

                    },



                    quadSet: function quadSet(options, tile) {

                        var x = options.xIndex * (tile.width + _this10.groutSize);

                        var y = options.yIndex * (tile.height + _this10.groutSize);



                        var rotation = 0;

                        if (_this10._isOdd(options.xIndex) && _this10._isEven(options.yIndex)) {

                            rotation = ROTATION_270_DEG;

                        } else if (_this10._isEven(options.xIndex) && _this10._isOdd(options.yIndex)) {

                            rotation = ROTATION_90_DEG;

                        } else if (_this10._isOdd(options.xIndex) && _this10._isOdd(options.yIndex)) {

                            rotation = ROTATION_180_DEG;

                        }



                        return { x: x, y: y, rotation: rotation };

                    }

                };

                this._getTilePosition.rectangle = this._getTilePosition.square;



                this._getTilePosition.notionHerringbon = this._getTilePosition.preparedSet;

                this._getTilePosition.riverstoneRohmboid = this._getTilePosition.preparedSet;

                this._getTilePosition.rivertsoneChevron = this._getTilePosition.preparedSet;

                this._getTilePosition.stoneSystemCombo = this._getTilePosition.preparedSet;

            }

        }, {

            key: '_addTile',

            value: function _addTile(options) {

                var position = this._getTilePosition[options.tile.shape](options, options.tile);

                this._addTileToContainer(options.tile, options.container, position);

            }

        }, {

            key: '_getTilesCount',

            value: function _getTilesCount(tile) {

                var count = {

                    width: this.maxSize / tile.width,

                    height: this.maxSize / tile.height

                };



                if (tile.shape === 'diamond') {

                    count.height *= 2;

                } else if (tile.shape === 'hexagon') {

                    count.width *= 0.66; // 1.75 / 0.75 * count.width;

                    count.height *= 2;

                } else if (tile.shapePreparedSet) {

                    count.width *= 1 / (1 - tile.preparedSetOffset.x / tile.width);

                    count.height *= 1 / (1 - tile.preparedSetOffset.y / tile.height);

                }



                count.width = Math.ceil(count.width + 4 - count.width % 4);

                count.height = Math.ceil(count.height + 4 - count.height % 4);



                return count;

            }

        }, {

            key: '_fillSurface',

            value: function _fillSurface(tiles$$1, drawEver) {

                // let tile = tiles[0];

                var tilesCount = this._getTilesCount(tiles$$1[0]);

                var tilesArray = [];



                for (var j = -tilesCount.height; j < tilesCount.height; j += 1) {

                    tilesArray[j + tilesCount.height] = [];

                    for (var i = -tilesCount.width; i < tilesCount.width; i += 1) {

                        var tile = this._getRandomTile(tilesArray, tiles$$1, i + tilesCount.width, j + tilesCount.height);



                        tilesArray[j + tilesCount.height][i + tilesCount.width] = tile;



                        var tileOptions = {

                            container: this.tilesContainer,

                            tile: tile,

                            xIndex: i,

                            yIndex: j

                        };



                        switch (fillTypes[this.fillTypeIndex].name) {

                            case 'Chess':

                                if (tile.shape === 'square' || tile.shape === 'rectangle') {

                                    if (Math.round((i + j) % 2) === drawEver) {

                                        this._addTile(tileOptions);

                                    } else if (Math.round(Math.abs((i + j) % 2)) === drawEver) {

                                        this._addTile(tileOptions);

                                    }

                                } else if (tile.shape === 'diamond') {

                                    if (this._isEven(j) && drawEver === 0) {

                                        this._addTile(tileOptions);

                                    } else if (this._isOdd(j) && drawEver === 1) {

                                        this._addTile(tileOptions);

                                    }

                                } else {

                                    this._addTile(tileOptions);

                                }

                                break;



                            case 'Horizontal Skew':

                                if (this._isOdd(j)) {

                                    tileOptions.skew = { x: this.skewSize };

                                }

                                this._addTile(tileOptions);

                                break;



                            case 'Vertical Skew':

                                if (this._isOdd(i)) {

                                    tileOptions.skew = { y: this.skewSize };

                                }

                                this._addTile(tileOptions);

                                break;



                            default:

                                this._addTile(tileOptions);

                        }

                    }

                }

            }

        }, {

            key: '_prepareTile',

            value: function _prepareTile(tile, image) {

                if (tile.tile3d) {

                    tile.tile3d.updateGrout(this.groutSize); // , this.groutColor

                } else {

                    tile.tile3d = new Tile3d(this.projection.maxAnisotropy);

                    tile.tile3d.make(image, tile, this.groutSize, this.groutMaterial);

                }

            }

        }, {

            key: '_drawTiles',

            value: function _drawTiles(tile, drawEver) {

                var _this11 = this;



                var tilesSet = TilesList.getRotoPrintSet(tile);

                // const images = [];

                var loadedImages = 0;



                tilesSet.forEach(function (tile) {

                    loadingAnimation.show();

                    var image = new Image();

                    image.onload = function () {

                        _this11._prepareTile(tile, image);



                        loadedImages += 1;

                        if (loadedImages >= tilesSet.length) {

                            _this11._fillSurface(tilesSet, drawEver);

                            _this11._render();

                        }

                        loadingAnimation.hide();

                    };

                    image.onerror = loadingAnimation.hide;

                    image.src = tile.file;

                    // images.push(image);

                });

            }



            /** @override */



        }, {

            key: 'setColor',

            value: function setColor() {

                var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '#ffffff';



                this.color = color;

                this._render();

            }



            /** @override */



        }, {

            key: 'setFillType',

            value: function setFillType(value) {

                this.fillTypeIndex = Number(value) || 0;

                this.draw(); // todo check

            }



            /** @override */



        }, {

            key: 'setSkewSize',

            value: function setSkewSize(value) {

                _get(TiledSurface2d.prototype.__proto__ || Object.getPrototypeOf(TiledSurface2d.prototype), 'setSkewSize', this).call(this, value);



                this.draw(); // todo check

            }



            /** @override */



        }, {

            key: 'setGroutSize',

            value: function setGroutSize(value) {

                _get(TiledSurface2d.prototype.__proto__ || Object.getPrototypeOf(TiledSurface2d.prototype), 'setGroutSize', this).call(this, value);



                this.draw(); // todo check

            }



            /** @override */



        }, {

            key: 'setGroutColor',

            value: function setGroutColor(color) {

                _get(TiledSurface2d.prototype.__proto__ || Object.getPrototypeOf(TiledSurface2d.prototype), 'setGroutColor', this).call(this, color);

                this._render();

            }

        }, {

            key: '_rotate',

            value: function _rotate(angle) {

                // angle - 0 - 360 degree

                this.rotation = Number(angle) || 0;

                var rotationInRadians = this.rotation * DEG;

                this.tilesContainer.rotation.z = rotationInRadians;

                this.freeDesignTilesContainer.rotation.z = rotationInRadians;

                this.intersectsPlane.rotation.z = rotationInRadians;

            }



            /** @override */



        }, {

            key: 'rotate',

            value: function rotate(angle) {

                this._rotate(angle);

                this._render();

            }



            // getRandomTileInSet(tileIndex) {

            //     var tilesSet = getTilesSet(tileIndex);

            //     if (tilesSet.length > 1) {

            //         return tilesSet[Math.floor(Math.random() * tilesSet.length)];

            //     }

            //     return tilesSet[0];

            // }



        }, {

            key: '_checkTilePlace',

            value: function _checkTilePlace(mesh) {

                this.projection.render();

                var intersects = this.projection.getIntersects(this.clickPoint, mesh.children);

                if (intersects.length > 0) {

                    return true;

                }

            }



            /** @override */



        }, {

            key: 'setTile',

            value: function setTile(tile) {

                _get(TiledSurface2d.prototype.__proto__ || Object.getPrototypeOf(TiledSurface2d.prototype), 'setTile', this).call(this, tile);



                this.draw();

            }



            /** @override */



        }, {

            key: 'setTile2',

            value: function setTile2(tile) {

                _get(TiledSurface2d.prototype.__proto__ || Object.getPrototypeOf(TiledSurface2d.prototype), 'setTile2', this).call(this, tile);



                this.draw();

            }

        }, {

            key: 'setFreeDesign',

            value: function setFreeDesign(value) {

                _get(TiledSurface2d.prototype.__proto__ || Object.getPrototypeOf(TiledSurface2d.prototype), 'setFreeDesign', this).call(this, value);



                if (!this.freeDesign) {

                    // tileDrawer.clearFreeDesignTiles();

                    this._render();

                }

            }

        }, {

            key: 'setFreeDesignTile',

            value: function setFreeDesignTile(tile) {

                this.freeDesignTile = tile;

            }

        }, {

            key: 'clearTile2',

            value: function clearTile2() {

                this.tile2 = undefined;

                this.tile2Index = undefined;

            }

        }, {

            key: '_freeDesignTileApproxPositions',

            value: function _freeDesignTileApproxPositions() {

                var _this12 = this;



                this._freeDesignTileApproxPosition = {

                    square: function square(point, tile) {

                        var xIndex = Math.floor(point.x / (tile.width + _this12.groutSize));

                        var yIndex = Math.floor(point.y / (tile.height + _this12.groutSize));



                        return { xIndex: xIndex, yIndex: yIndex };

                    },



                    hexagon: function hexagon(point, tile) {

                        var groutSizeX = _this12.groutSize * HEXAGON_ASPECT_RATIO;

                        var xIndex = Math.floor(point.x / (tile.width * 1.5 + groutSizeX * 2));

                        var yIndex = Math.floor(point.y / (tile.height * 0.5 + _this12.groutSize * 0.5));



                        return { xIndex: xIndex, yIndex: yIndex };

                    },



                    diamond: function diamond(point, tile) {

                        var groutSizeX = _this12.groutSize * DIAMOND_ASPECT_RATIO;

                        var xIndex = Math.floor(point.x / (tile.width + groutSizeX * 2));

                        var yIndex = Math.floor(point.y / (tile.height * 0.5 + _this12.groutSize));



                        return { xIndex: xIndex, yIndex: yIndex };

                    },



                    preparedSet: function preparedSet(point, tile) {

                        var xIndex = Math.floor(point.x / (tile.width + _this12.groutSize - tile.preparedSetOffset.x));

                        var yIndex = Math.floor(point.y / (tile.height + _this12.groutSize - tile.preparedSetOffset.y));



                        return { xIndex: xIndex, yIndex: yIndex };

                    }

                };

                this._freeDesignTileApproxPosition.rectangle = this._freeDesignTileApproxPosition.square;

                this._freeDesignTileApproxPosition.quadSet = this._freeDesignTileApproxPosition.square;



                this._freeDesignTileApproxPosition.notionHerringbon = this._freeDesignTileApproxPosition.preparedSet;

                this._freeDesignTileApproxPosition.riverstoneRohmboid = this._freeDesignTileApproxPosition.preparedSet;

                this._freeDesignTileApproxPosition.rivertsoneChevron = this._freeDesignTileApproxPosition.preparedSet;

                this._freeDesignTileApproxPosition.stoneSystemCombo = this._freeDesignTileApproxPosition.preparedSet;

            }

        }, {

            key: '_moveFreeDesignTile',

            value: function _moveFreeDesignTile(mesh, tile, cell) {

                var tilePosition = this._getTilePosition[tile.shape](cell, tile);

                mesh.position.x = tilePosition.x + tile.width / 2;

                mesh.position.y = -(tilePosition.y + tile.height / 2); // + surface.groutSize;

                mesh.rotation.y = tilePosition.rotation || 0;

            }

        }, {

            key: '_putFreeDesignTileToCell',

            value: function _putFreeDesignTileToCell(tile, point) {

                var _this13 = this;



                // , tileSize

                var neighborTileCells = [[0, 0], [-1, -1], [0, -1], [1, -1], [-1, 0], [1, 0], [-1, 1], [0, 1], [1, 1]];

                var cell = this._freeDesignTileApproxPosition[tile.shape](point, tile);

                var mesh = this._addTileToContainer(tile, this.freeDesignTilesContainer, { x: 0, y: 0 });



                neighborTileCells.some(function (neighborTileCell) {

                    _this13._moveFreeDesignTile(mesh, tile, { xIndex: cell.xIndex + neighborTileCell[0], yIndex: cell.yIndex + neighborTileCell[1] });

                    if (_this13._checkTilePlace(mesh)) {

                        mesh.freeDesignTileData = {

                            id: tile.id,

                            xIndex: cell.xIndex + neighborTileCell[0],

                            yIndex: cell.yIndex + neighborTileCell[1],

                            custom: tile.custom

                        };

                        _this13.freeDesignTiles.push(mesh.freeDesignTileData);

                        return true;

                    }

                });

            }

        }, {

            key: 'drawFreeDesignTiles',

            value: function drawFreeDesignTiles() {

                var _this14 = this;



                var loadedImages = 0;

                this.freeDesignTiles.forEach(function (freeDesignTile) {

                    var tile = TilesList.getById(freeDesignTile.id, freeDesignTile.custom);

                    if (tile) {

                        loadingAnimation.show();



                        var image = new Image();

                        image.onload = function () {

                            _this14._prepareTile(tile, image);

                            var mesh = _this14._addTileToContainer(tile, _this14.freeDesignTilesContainer, { x: 0, y: 0 });

                            _this14._moveFreeDesignTile(mesh, tile, freeDesignTile);

                            mesh.freeDesignTileData = freeDesignTile;



                            loadedImages += 1;

                            if (loadedImages >= _this14.freeDesignTiles.length) {

                                _this14._render();

                            }

                            loadingAnimation.hide();

                        };

                        image.onerror = loadingAnimation.hide;

                        image.src = tile.file;

                    }

                });

            }

        }, {

            key: '_addFreeDesignTile',

            value: function _addFreeDesignTile(intersect) {

                var _this15 = this;



                if (this.freeDesignTile) {

                    loadingAnimation.show();



                    var tile = TilesList.getRandomInSet(this.freeDesignTile);



                    var image = new Image();

                    image.onload = function () {

                        _this15._prepareTile(tile, image);



                        var x = (intersect.uv.x - 0.5) * PLANE_SIZE;

                        var y = -(intersect.uv.y - 0.5) * PLANE_SIZE;

                        _this15._putFreeDesignTileToCell(tile, { x: x, y: y });

                        _this15._render();

                        loadingAnimation.hide();

                    };

                    image.onerror = loadingAnimation.hide;

                    image.src = tile.file;

                }

            }

        }, {

            key: '_rotateTile',

            value: function _rotateTile(mesh) {

                var angle = Tile3d.Shapes[mesh.tile.shape].rotationStep;

                if (angle !== 0) {

                    mesh.rotation.y -= angle || Math.PI;

                    this._render();

                }

            }

        }, {

            key: '_removeFreeDesignTile',

            value: function _removeFreeDesignTile(tileMesh) {

                var tileIndex = this.freeDesignTiles.indexOf(tileMesh.freeDesignTileData);

                if (tileIndex !== -1) {

                    this.freeDesignTiles.splice(tileIndex, 1);

                }

                this.freeDesignTilesContainer.remove(tileMesh);

                this._render();

            }

        }, {

            key: 'freeDesignTileClick',

            value: function freeDesignTileClick(point, direction) {

                this.clickPoint = point;

                var intersects = this.projection.getIntersects(point, this.freeDesignTilesContainer.children, direction);



                if (intersects.length > 0) {

                    var rotate = document.getElementById('topPanelCheckFreeDesignRotate').checked;

                    if (rotate) {

                        this._rotateTile(intersects[0].object.parent);

                    } else {

                        this._removeFreeDesignTile(intersects[0].object.parent);

                    }

                } else {

                    intersects = this.projection.getIntersect(point, this.intersectsPlane);

                    if (intersects.length > 0) {

                        this._addFreeDesignTile(intersects[0]);

                    }

                }

            }

        }, {

            key: 'click',

            value: function click(point, direction) {

                var rotate = document.getElementById('topPanelCheckFreeDesignRotate').checked;

                if (rotate) {

                    var intersects = this.projection.getIntersects(point, this.tilesContainer.children, direction);

                    if (intersects.length > 0) {

                        this._rotateTile(intersects[0].object.parent);

                    }

                }

            }

        }, {

            key: 'draw',

            value: function draw() {

                this.removeAllTiles();



                if (this.tileIndex !== undefined) {

                    this._drawTiles(TilesList[this.tileIndex], 0);

                }

                if (this.tile2Index !== undefined) {

                    this._drawTiles(TilesList[this.tile2Index], 1);

                }

            }

        }, {

            key: 'restoreSettings',

            value: function restoreSettings(savedData) {

                this.color = savedData.color;

                this.groutSize = Number(savedData.groutSize);

                this.groutColor = savedData.groutColor;

                this.fillTypeIndex = Number(savedData.fillTypeIndex);

                this.tileIndex = TilesList.getIndexById(savedData.tileId, savedData.tileCustom);

                this.tile2Index = TilesList.getIndexById(savedData.tile2Id, savedData.tile2Custom);

                this.freeDesign = savedData.freeDesign;

                this.freeDesignTiles = savedData.freeDesignTiles;

                this.skewSize = savedData.skewSize;



                this._rotate(savedData.rotation);

                this.draw();



                if (this.freeDesign) this.drawFreeDesignTiles();

            }

        }, {

            key: '_getFreeDesignTilesData',

            value: function _getFreeDesignTilesData() {

                return this.freeDesignTilesContainer.children.map(function (tile) {

                    return {

                        id: tile.freeDesignTileData.id,

                        xIndex: tile.freeDesignTileData.xIndex,

                        yIndex: tile.freeDesignTileData.yIndex,

                        custom: tile.freeDesignTileData.custom

                    };

                });

            }

        }, {

            key: 'getSettings',

            value: function getSettings() {

                var tile = TilesList[this.tileIndex];

                var tile2 = TilesList[this.tile2Index];



                return {

                    color: this.color,

                    groutSize: this.groutSize,

                    groutColor: this.groutColor,

                    rotation: this.rotation,

                    fillTypeIndex: this.fillTypeIndex,

                    tileId: tile ? tile.id : undefined,

                    tileCustom: tile ? tile.custom : undefined,

                    tile2Id: tile2 ? tile2.id : undefined,

                    tile2Custom: tile2 ? tile2.custom : undefined,

                    skewSize: this.skewSize,

                    freeDesign: this.freeDesign,

                    freeDesignTiles: this._getFreeDesignTilesData()

                };

            }

        }, {

            key: 'drawGridHelper',

            value: function drawGridHelper(imageFile, size) {

                var _this16 = this;



                if (this._gridHelper) {

                    this.removeAllTiles();

                    this._render();

                } else {

                    this.removeAllTiles();

                    this._gridHelper = true;



                    loadingAnimation.show();

                    var image = new Image();

                    image.onload = function () {

                        var grid = new Tile3d(_this16.projection.maxAnisotropy);

                        var plane = {

                            shape: 'square',

                            width: size,

                            height: size

                        };

                        var texture = new window.THREE.Texture(image);

                        grid.makePlane(plane);

                        grid.mesh.material.map = texture;

                        texture.needsUpdate = true;

                        _this16.tilesContainer.add(grid.mesh);



                        _this16._render();

                        loadingAnimation.hide();

                    };

                    image.onerror = loadingAnimation.hide;

                    image.src = imageFile;

                }

            }

        }, {

            key: 'getFinish',

            value: function getFinish() {

                if (this.tileIndex !== undefined && TilesList[this.tileIndex]) {

                    return TilesList[this.tileIndex].finish;

                }

            }

        }]);



        return TiledSurface2d;

    }(TiledSurface);



    var room = {

        tiledSurfaces: [],

        currentTiledSurface: undefined

    };

    var engine2d = void 0;



    function updateMaps() {

        engine2d.render(room.tiledSurfaces);

    }



    function selectTile() {

        window.$('#dialogSelectTile').modal('hide');

        room.currentTiledSurface.tileIndex = this.dataset.index;

        room.currentTiledSurface.draw();

    }



    function createTile(tile, index) {

        tile.id = index;

        tile.index = index;

        tile.size = tile.width + 'x' + tile.height;

        tile.file = '/img/testTiles/tile1.jpg';

        tile.shape = 'rectangle';



        var $li = $('<li id="tile_' + index + '" data-index="' + index + '" class="top-panel-content-tiles-list-item"></li>').click(selectTile).append($('<div style="display: table-cell; text-align: center; width: 50px; line-height: 32px;"></div>').append('<img src="' + tile.file + '" style="max-width: 32px; max-height: 32px;">'), $('<div style="display: table-cell;"></div>').append('<strong>' + tile.width + 'mm x ' + tile.height + 'mm</strong>'));



        tile.li = $li[0];



        return TilesList.add(tile);

    }



    function fillTilesList$1() {

        var $ul = $('<ul ></ul>');

        var testTiles = [{ width: 100, height: 100 }, { width: 200, height: 200 }, { width: 300, height: 300 }, { width: 400, height: 400 }, { width: 600, height: 600 }, { width: 1000, height: 1000 }];



        testTiles.forEach(function (tile, index) {

            $ul.append(createTile(tile, index).li);

        });

        $('#tilesList').append($ul);

    }



    function initTiledSurface(surfaceData) {

        var tiledSurface = new TiledSurface2d(surfaceData, updateMaps);

        room.tiledSurfaces.push(tiledSurface);



        return tiledSurface;

    }



    function removeTiledSurface(surface) {

        var surfaceIndex = room.tiledSurfaces.findIndex(function (existSurfaces) {

            if (existSurfaces === surface) {

                return true;

            }

        });



        if (surfaceIndex !== -1) {

            room.tiledSurfaces.splice(surfaceIndex, 1);

        }

    }



    function reedSurfaceOptions(surfaceIndex) {

        var idPrefix = 'surfaceOptionsBlock_' + surfaceIndex;

        var data = {

            '0': surfaceIndex,

            '176': document.getElementById(idPrefix + '_type').value,

            '1': document.getElementById(idPrefix + '_positionX').value,

            '2': document.getElementById(idPrefix + '_positionY').value,

            '3': document.getElementById(idPrefix + '_positionZ').value,

            '4': document.getElementById(idPrefix + '_rotationX').value,

            '5': document.getElementById(idPrefix + '_rotationY').value,

            '6': document.getElementById(idPrefix + '_rotationZ').value,

            '7': document.getElementById(idPrefix + '_planeSize').value,

            '8': document.getElementById(idPrefix + '_planeSize').value,

            // '7': document.getElementById(idPrefix + '_planeSizeHeight').value,

            // '8': document.getElementById(idPrefix + '_planeSizeWidth').value,

            '9': document.getElementById(idPrefix + '_scaling').value,

            '10': document.getElementById(idPrefix + '_scaling').value,

            // '9': document.getElementById(idPrefix + '_scalingHeight').value,

            // '10': document.getElementById(idPrefix + '_scalingHeight').value

            'group': document.getElementById(idPrefix + '_group').value,



            'cameraFov': document.getElementById('cameraFov').value,

            'viewVerticalOffset': document.getElementById('viewVerticalOffset').value,

            'viewHorizontalOffset': document.getElementById('viewHorizontalOffset').value

        };

        var maskPathPoints = document.getElementById(idPrefix + '_maskPathPoints').children;

        var maskPathPointsData = [];



        if (maskPathPoints.length > 0) {

            Array.prototype.forEach.call(maskPathPoints, function (maskPathPoint) {

                maskPathPointsData.push([document.getElementById(idPrefix + '_maskPathPoint_' + maskPathPoint.dataset.index + '_0').value, document.getElementById(idPrefix + '_maskPathPoint_' + maskPathPoint.dataset.index + '_1').value]);

            });

        }

        data['11'] = maskPathPointsData;



        return data;

    }



    function readSurfacesOptions() {

        var datas = [],

            surfaces = document.getElementById('roomTiledSurfacesOptions').children;



        if (surfaces.length > 0) {

            Array.prototype.forEach.call(surfaces, function (surface) {

                var data = reedSurfaceOptions(surface.dataset.index);

                surface.tiledSurface.update(data);

                datas.push(data);

            });

        }

        document.getElementById('roomTiledSurfacesData').value = JSON.stringify(datas);

        return datas;

    }



    function updateRoom2d() {

        readSurfacesOptions();

        updateMaps();

    }



    function submitData() {

        readSurfacesOptions();

        document.getElementById('updateSurfacesForm').submit();

    }



    function createMaskPathPointElement(point, id, index) {

        point = point || [];

        if (Array.isArray(point)) {

            var divId = id + '_maskPathPoint_' + index,

                $div = $('<div id="' + divId + '" class="input-group" data-index="' + index + '"></div>');



            $div.append('<span class="input-group-addon">X</span>', '<input type="number" id="' + divId + '_0" value="' + (point[0] || 0) + '" class="form-control input-sm mask-path-point-x">', '<span class="input-group-addon">Y</span>', '<input type="number" id="' + divId + '_1" value="' + (point[1] || 0) + '" class="form-control input-sm mask-path-point-y">');



            $div.find(':input').on('input', function () {

                var surfaceOptions = document.getElementById(id),

                    surfacesData = reedSurfaceOptions(surfaceOptions.dataset.index);

                surfaceOptions.tiledSurface.update(surfacesData);

                updateMaps();

            });



            return $div[0];

        }

        return '';

    }



    function getIndex(parent, startIndex) {

        var lastIndex,

            index = startIndex || 0;

        if (parent.lastChild) {

            lastIndex = Number(parent.lastChild.dataset.index);

            if (!isNaN(lastIndex)) {

                index = lastIndex + 1;

            }

        }

        return index;

    }



    function getOptionsSurfaceTypes() {

        var options = '',

            types = Object.keys(room.surfaceTypes);

        types.forEach(function (type) {

            options += '<option value="' + type + '">' + room.surfaceTypes[type] + '</option>';

        });

        return options;

    }



    function addMaskPathPoints(id, point) {

        point = point || [];

        var maskPathPointsBlock = document.getElementById(id + '_maskPathPoints'),

            index = getIndex(maskPathPointsBlock),

            maskPathPoint = createMaskPathPointElement(point, id, index);

        maskPathPointsBlock.appendChild(maskPathPoint);



        return maskPathPoint;

    }



    function showMaskPathPoints(points, id) {

        points = points || [];

        var pointsElements = [];

        if (Array.isArray(points)) {

            points.forEach(function (point, index) {

                pointsElements.push(createMaskPathPointElement(point, id, index));

            });

        }

        return pointsElements;

    }



    function moveCrosshair($crosshair, point) {

        $crosshair.css({

            'left': Math.floor(room.pointsCanvas.offsetWidth / room.pointsCanvas.width * point[0]),

            'top': Math.floor(room.pointsCanvas.offsetHeight / room.pointsCanvas.height * point[1])

        });

    }



    function drawCrosshairsLine(ctx, points) {

        room.pointsCanvas.width = room.canvas.width;

        ctx.fillStyle = 'rgba(100, 100, 100, 0.4)';

        ctx.fillRect(0, 0, room.pointsCanvas.width, room.pointsCanvas.height);



        if (Array.isArray(points) && points.length > 0) {

            ctx.globalCompositeOperation = 'destination-out';

            ctx.beginPath();

            points.forEach(function (point) {

                // drawCrosshair(ctx, point[0], point[1]);

                ctx.lineTo(point[0], point[1]);

            });

            ctx.closePath();

            ctx.stroke();



            ctx.fillStyle = '#ffffff';

            ctx.fill();

            ctx.globalCompositeOperation = 'source-over';

        }

    }



    function addCrosshair(point, ctx, points, maskPathPoint) {

        var $crosshair = $('<img class="crosshair" src="/img/crosshair.png" alt="" style="position: absolute; cursor: move; margin: -16px;">');



        $crosshair.draggable({ containment: 'parent', drag: function drag() {

                point[0] = Math.floor(room.pointsCanvas.width / room.pointsCanvas.offsetWidth * ($crosshair[0].offsetLeft + 16));

                point[1] = Math.floor(room.pointsCanvas.height / room.pointsCanvas.offsetHeight * ($crosshair[0].offsetTop + 16));

                drawCrosshairsLine(ctx, points);



                var $maskPathPoint = $(maskPathPoint);

                $maskPathPoint.find('.mask-path-point-x').val(point[0]);

                $maskPathPoint.find('.mask-path-point-y').val(point[1]);

            } });



        $('#container').append($crosshair);

        moveCrosshair($crosshair, point);



        return $crosshair;

    }



    function pickMaskPathPoints(id) {

        var ctx = room.pointsCanvas.getContext('2d'),

            points = [],

            crosshairs = [];



        room.pointsCanvas.style.cursor = 'crosshair';



        room.pointsCanvas.width = room.canvas.width;

        room.pointsCanvas.height = room.canvas.height;

        ctx.fillStyle = 'rgba(100, 100, 100, 0.4)';

        ctx.fillRect(0, 0, room.pointsCanvas.width, room.pointsCanvas.height);



        document.getElementById(id + '_maskPathPoints').innerHTML = '';



        function windowResize() {

            points.forEach(function (point, index) {

                moveCrosshair(crosshairs[index], point);

            });

        }

        window.addEventListener('resize', windowResize);



        room.pointsCanvas.onclick = function (event) {

            var point = [Math.floor(this.width / this.clientWidth * event.offsetX), Math.floor(this.height / this.clientHeight * event.offsetY)],

                maskPathPoint = addMaskPathPoints(id, point);



            points.push(point);

            crosshairs.push(addCrosshair(point, ctx, points, maskPathPoint));

            drawCrosshairsLine(ctx, points);



            updateRoom2d();

        };



        room.pointsCanvas.oncontextmenu = function (event) {

            event.preventDefault();



            room.pointsCanvas.style.cursor = 'unset';

            room.pointsCanvas.width = room.canvas.width;

            $('.crosshair').remove();



            room.pointsCanvas.onclick = undefined;

            room.pointsCanvas.oncontextmenu = undefined;

            window.removeEventListener('resize', windowResize);



            updateRoom2d();

        };

    }



    function createSurfaceOptionsBlock(surface, index) {

        // const id = surface['0'],

        var position = {

            x: surface['1'],

            y: surface['2'],

            z: surface['3']

        };

        var rotation = {

            x: surface['4'],

            y: surface['5'],

            z: surface['6']

        };

        var planeSize = Math.max(surface['7'], surface['8']);

        var scaling = Math.max(surface['9'], surface['10']);

        var maskPathPoints = surface['11'];

        var type = surface['176'];



        var group = surface.group && index !== surface.group ? surface.group : index;



        var divId = 'surfaceOptionsBlock_' + index;

        var $div = $('<div id="' + divId + '" class="form-group edit-panel-group-margin" data-index="' + index + '"></div>');



        $div.append('<label for="' + divId + '_btnOptions" class="control-label"><h5>Tiled Surface ' + index + '</h5></label>', $('<div class="input-group"></div>').append($('<select id="' + divId + '_type" class="form-control input-sm control-surface-option"></select>').append(getOptionsSurfaceTypes()).val(type.trim().toLowerCase()), '<span class="input-group-addon">Group</span>', '<input type="number" min="1" id="' + divId + '_group" value="' + group + '" class="form-control input-sm control-surface-option" style="width: 50px;">', $('<span class="input-group-btn"></span>').append($('<button type="button" class="btn btn-default btn-sm" title="Show Grid"><span class="glyphicon glyphicon-th" aria-hidden="true" style="color: #fff; background: #000;"></span></button>').click(function () {

            // $div[0].tiledSurface.drawGridHelper('/img/grid10x10_1024.png', 10240);

            $div[0].tiledSurface.drawGridHelper('/img/grid20x20_2048.png', 20480);

        }), $('<button type="button" class="btn btn-default btn-sm" title="Tiles"><span class="glyphicon glyphicon-th"></span></button>').click(function () {

            room.currentTiledSurface = $div[0].tiledSurface;

            window.$('#dialogSelectTile').modal('show');

        }), '<button type="button" class="btn btn-default btn-sm" onclick="$(\'#' + divId + '_hidden\').slideToggle();" id="' + divId + '_btnOptions" title="Tiled Surface Options"><span class="glyphicon glyphicon-menu-hamburger" aria-hidden="true"></span></button>', $('<button type="button" class="btn btn-default btn-sm" title="Remove Tiled Surface"><span class="glyphicon glyphicon-trash" aria-hidden="true"></span></button>').click(function () {

            removeTiledSurface($div[0].tiledSurface);

            $div.remove();

            updateRoom2d();

        }))), $('<div id="' + divId + '_hidden" class="margin-top-small" style="display:none;"></div>').append($('<div class="input-group"></div>').append('<span class="input-group-addon">Plane Size</span>', '<input type="number" id="' + divId + '_planeSize" value="' + planeSize + '" class="form-control input-sm control-surface-option" step="100">', '<span class="input-group-addon">Scaling</span>', '<input type="number" id="' + divId + '_scaling" value="' + scaling + '" class="form-control input-sm control-surface-option" step="0.1">'), '<label class="control-label">Position</label>', $('<div class="input-group"></div>').append('<span class="input-group-addon">X</span>', '<input type="number" id="' + divId + '_positionX" value="' + position.x + '" class="form-control input-sm control-surface-option" step="0.1">', '<span class="input-group-addon">Y</span>', '<input type="number" id="' + divId + '_positionY" value="' + position.y + '" class="form-control input-sm control-surface-option" step="0.1">', '<span class="input-group-addon">Z</span>', '<input type="number" id="' + divId + '_positionZ" value="' + position.z + '" class="form-control input-sm control-surface-option" step="0.1">'

            // $('<span class="input-group-btn"></span>').append(

            //     '<button type="button" class="btn btn-default btn-sm" title="Pick center point"><span class="glyphicon glyphicon-screenshot" aria-hidden="true"></span></button>'

            // )

        ), '<label class="control-label">Rotation</label>', $('<div class="input-group"></div>').append('<span class="input-group-addon">X</span>', '<input type="number" id="' + divId + '_rotationX" value="' + rotation.x + '" class="form-control input-sm control-surface-option" step="0.1">', '<span class="input-group-addon">Y</span>', '<input type="number" id="' + divId + '_rotationY" value="' + rotation.y + '" class="form-control input-sm control-surface-option" step="0.1">', '<span class="input-group-addon">Z</span>', '<input type="number" id="' + divId + '_rotationZ" value="' + rotation.z + '" class="form-control input-sm control-surface-option" step="0.1">'), '<label class="control-label">Mask Path Points</label>', $('<div id="' + divId + '_maskPathPoints"></div>').append($(showMaskPathPoints(maskPathPoints, divId))), $('<div class="text-right"></div>').append($('<span class="btn-group btn-group-sm"></span>').append($('<button type="button" class="btn btn-default">Pick Mask Path Points (Clear Existing)</button>').click(function () {

            pickMaskPathPoints(divId);

        })))));



        document.getElementById('cameraFov').value = surface.cameraFov || 30;

        document.getElementById('viewVerticalOffset').value = surface.viewVerticalOffset || 0;

        document.getElementById('viewHorizontalOffset').value = surface.viewHorizontalOffset || 0;



        $div.find('.control-surface-option').on('input', function () {

            var surfacesData = reedSurfaceOptions(index);

            $div[0].tiledSurface.update(surfacesData);

            updateMaps();

        });



        return $div[0];

    }



    function addTiledSurface(surface, index) {

        var surfacesOptions = document.getElementById('roomTiledSurfacesOptions'),

            surfaceOptions,

            tiledSurface;



        if (index === undefined) {

            index = getIndex(surfacesOptions, 1);

        }



        surfaceOptions = createSurfaceOptionsBlock(surface, index);

        tiledSurface = initTiledSurface(surface);



        surfacesOptions.appendChild(surfaceOptions);

        tiledSurface.controls = surfaceOptions;

        surfaceOptions.tiledSurface = tiledSurface;

    }



    function fillTiledSurfacesOptions(surfaces) {

        document.getElementById('roomTiledSurfacesData').value = surfaces;



        surfaces = JSON.parse(surfaces);

        if (Array.isArray(surfaces)) {

            surfaces.forEach(function (surface, index) {

                addTiledSurface(surface, index + 1);

            });

        }

    }



    function addBlankTiledSurface() {

        var surface = {

            0: 1,

            1: 0,

            2: 0,

            3: 0,

            4: 0,

            5: 0,

            6: 0,

            7: 5000,

            8: 5000,

            9: 10,

            10: 10,

            11: [],

            12: 0,

            13: 0,

            14: 0,

            15: 0,

            177: 0,

            176: 'Wall',

            cameraFov: document.getElementById('cameraFov').value,

            viewVerticalOffset: document.getElementById('viewVerticalOffset').value,

            viewHorizontalOffset: document.getElementById('viewHorizontalOffset').value

        };

        addTiledSurface(surface);

    }



    // @jscrambler define domainLock {domains:[app001.3droomvisualizer.com, visualizer.restile.com, visualiser.sandstoneworks.com.au, simulator.stoneline.com.tr, visualizer2d.globalquartz.in, tilevisualizer.designtiles.com.au, tiledepot.3droomvisualizer.com, visualizer.metztiles.com.au, visualizer.metztiles.com.au, visualizer.alkhaleejceramics.com, 8ba86c312c.mbapp.wnpower.host, visualiser.floorsdirectltd.co.uk, tilevisualizer.kimgres.com, www.wissam.tilescarreaux.com, vis.florexceramic.in, app.niceramics.com, facciatavision.viva.co.in, visualizer.mahalaxmitiles.com, stoneline.3droomvisualizer.com, stonecash.visualizer.live, tilevisualizer.pavits.com, app.conceptvisualizer.com, facciatavision.viva.co.in, tilescarreaux.3droomvisualizer.com, tiledesigner.stile.com.pk, diy.saifurnitureindia.co.in, floorvisualizer.welspunflooring.com, simulator.machucatile.com, visualizer.topcarpetsandfloors.co.za, visualizer.ashhalan.online, visualizer.clubceramic.com, tilevisualizer.himflor.in, floorsdirect.3droomvisualizer.com, tdcc2.3dtilevisualizer.com, app.simuladorfv.com, tilevisualiser.colortile.com.au, visualizer.cletile.com, floorvisualizer.welspunflooring.com, poplar.3dtilevisualizer.com]} as dL

    // @jscrambler enable dL

    function initElements() {

        document.getElementById('btnUpdateRoom').addEventListener('click', submitData);

        document.getElementById('btnAddTiledSurface').addEventListener('click', addBlankTiledSurface);

        document.getElementById('btnUpdateSurfaces').addEventListener('click', updateRoom2d);

        document.getElementById('cameraFov').addEventListener('input', updateRoom2d);

        document.getElementById('viewVerticalOffset').addEventListener('input', updateRoom2d);

        document.getElementById('viewHorizontalOffset').addEventListener('input', updateRoom2d);



        $('#roomEditPanel').draggable({ axis: 'x', containment: 'parent' });

    }



    // @jscrambler define domainLock {domains:[app001.3droomvisualizer.com, visualizer.restile.com, visualiser.sandstoneworks.com.au, simulator.stoneline.com.tr, visualizer2d.globalquartz.in, tilevisualizer.designtiles.com.au, tiledepot.3droomvisualizer.com, visualizer.metztiles.com.au, visualizer.metztiles.com.au, visualizer.alkhaleejceramics.com, 8ba86c312c.mbapp.wnpower.host, visualiser.floorsdirectltd.co.uk, tilevisualizer.kimgres.com, www.wissam.tilescarreaux.com, vis.florexceramic.in, app.niceramics.com, facciatavision.viva.co.in, visualizer.mahalaxmitiles.com, stoneline.3droomvisualizer.com, stonecash.visualizer.live, tilevisualizer.pavits.com, app.conceptvisualizer.com, facciatavision.viva.co.in, tilescarreaux.3droomvisualizer.com, tiledesigner.stile.com.pk, diy.saifurnitureindia.co.in, floorvisualizer.welspunflooring.com, simulator.machucatile.com, visualizer.topcarpetsandfloors.co.za, visualizer.ashhalan.online, visualizer.clubceramic.com, tilevisualizer.himflor.in, floorsdirect.3droomvisualizer.com, tdcc2.3dtilevisualizer.com, app.simuladorfv.com, tilevisualiser.colortile.com.au, visualizer.cletile.com, floorvisualizer.welspunflooring.com, poplar.3dtilevisualizer.com]} as dL

    // @jscrambler enable dL

    function init() {

        room.canvas = document.getElementById('roomCanvas');

        // room.canvas.addEventListener('click', sceneMouseClick);



        engine2d = new Engine2D(room.canvas);

        engine2d.loadImages(room, RoomLoadProgress.end, RoomLoadProgress.progress);



        fillTiledSurfacesOptions(room.surfaces);

        initElements();

        fillTilesList$1();



        room.pointsCanvas = document.getElementById('pointsCanvas');

    }



    function loadRoom(id) {

        $.ajax({

            url: '/get/room2d/' + id,

            success: function success(loadedRoom) {

                Object.assign(room, loadedRoom);

                init();

            }

        });

    }



    window.addEventListener('load', function () {

        room.id = window.JsConstants.room.id;

        if (room.id) {

            loadRoom(room.id);

        }



        RoomLoadProgress.start();

    });



    // export { interiorUI };

})();