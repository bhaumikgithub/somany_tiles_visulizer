'use strict';

var topPanelTilesListUl = document.createElement('ul');
    topPanelTilesListUl.id = 'topPanelTilesListUl';

var guiObj = {
    hideTiles: { value: false },
    animate: { value: false },
    rotateWithRoom: { value: false },
    shininess: { value: 5 },
    specularPower: { value: 4 },
    specColPower: { value: 0.5 },
    enableLights: { value: [true, true, true] },
    lightOptions:[
        { distance: 30, speed: 0.01, angle: 0 },
        { distance: 30, speed: 0.01, angle: 2.1 },
        { distance: 30, speed: 0.01, angle: 4.2 },
    ],
    positions: { value: [
        new THREE.Vector3(20.0, 0.0, -20.0),
        new THREE.Vector3(20.0, 0.0, 20.0),
        new THREE.Vector3(-20.0, 0.0, 0.0),
    ] },
    save: () => {
        $.ajax({
            method: 'POST',
            url: '/userRoom/save/specular-lights',
            dataType: 'json',
            data: {
                '_token': $('meta[name=csrf-token]').attr('content'),
                'url': window.JsConstants.room.url,
                'specularLights': JSON.stringify(guiObj),
            },
            success: function success(response) {
                if (response.state === 'success') {
                    window.$('#successAlertBox').html('<strong>Success!</strong> Light options saved.').fadeIn();
                } else {
                    window.$('#dangerAlertBox').html('<strong>Error!</strong> The problem in saving room.');
                    window.$('#dangerAlertBox').fadeIn();
                }
            },
            error: function error() {
                window.$('#dangerAlertBox').html('<strong>Error!</strong> The problem in saving room.');
                window.$('#dangerAlertBox').fadeIn();
            },
        });
    }
}

var lights = {
    // positions: { value: [
    //     new THREE.Vector3(), // new THREE.Vector3(20.0, 0.0, -20.0),
    //     new THREE.Vector3(), // new THREE.Vector3(20.0, 0.0, 20.0),
    //     new THREE.Vector3(), // new THREE.Vector3(-20.0, 0.0, 0.0),
    // ] },
    angles: [0, 0, 0]
}

function initGui(guiObj) {
    if (window.location.href.match(/controls=true/)) {
        var gui = new lil.GUI();

        var hideTilesFolder = gui.addFolder('hideTiles');
        hideTilesFolder.add(guiObj.hideTiles, 'value');
        var animateFolder = gui.addFolder('animate');
        animateFolder.add(guiObj.animate, 'value');
        var rotateWithRoomFolder = gui.addFolder('rotateWithRoom');
        rotateWithRoomFolder.add(guiObj.rotateWithRoom, 'value');
        var shininessFolder = gui.addFolder('shininess');
        shininessFolder.add(guiObj.shininess, 'value', 0, 128, 0.1);
        var specularPowerFolder = gui.addFolder('specularPower');
        specularPowerFolder.add(guiObj.specularPower, 'value', 0, 10, 0.01);
        var specColPowerFolder = gui.addFolder('specColPower');
        specColPowerFolder.add(guiObj.specColPower, 'value', 0, 5, 0.01);

        for (var i = 0; i < 3; i++) {
            var lightPositionFolder = gui.addFolder('lightPosition ' + i);
            lightPositionFolder.add(guiObj.enableLights.value, i);
            lightPositionFolder.add(guiObj.positions.value[i], 'x', -100, 100, 0.1);
            lightPositionFolder.add(guiObj.positions.value[i], 'y', -100, 100, 0.1);
            lightPositionFolder.add(guiObj.positions.value[i], 'z', -100, 100, 0.1);
        }

        for (var i = 0; i < 3; i++) {
            var lightOptionFolder = gui.addFolder('lightOption ' + i);
            lightOptionFolder.add(guiObj.lightOptions[i], 'distance', 0, 100, 0.1);
            lightOptionFolder.add(guiObj.lightOptions[i], 'speed', -0.1, 0.1, 0.0001);
            lightOptionFolder.add(guiObj.lightOptions[i], 'angle', -0, 6.28, 0.01);
        }

        gui.add( guiObj, 'save' );

        gui.close();
    }
}

var _isSavedRoom = (location.href.indexOf('/room/url/') > -1);
if (_isSavedRoom) {
    document.getElementById('bottomMenuRoomSelect').style.display = 'none';
    document.getElementById('bottomMenuCapture').style.display = 'none';
}

if (window.orientation !== undefined) {
    document.getElementById('bottomMenuFullScreen').style.display = 'none';
}

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

(function () {
    'use strict';

    /**
     * 3droomvisualizer App
     *
     * by Tracing Idea
     *
     * @author ilya
     *
     * Version 2.0.1.1
     *
     * Copyright (c) 2017
     *
    **/

    var Loader = function () {
        function Loader() {
            _classCallCheck(this, Loader);

            this.data = {};

            this.dataLoaded = {
                tiles: false,
                userCustomTiles: false,
                roomCustomTiles: false,
                roomData: false
            };

            this.tilesDesigner = window.JsConstants && window.JsConstants.config && window.JsConstants.config.TilesDesigner;
        }

        _createClass(Loader, [{
            key: '_loadTiles',
            value: function _loadTiles() {
                var _this2 = this;

                $.get('/get/tiles', function (data) {
                    return _this2._onWholeDataLoaded('tiles', data);
                });
            }
        }, {
            key: '_loadUserCustomTiles',
            value: function _loadUserCustomTiles() {
                var _this3 = this;

                $.get('/customtiles', function (data) {
                    return _this3._onWholeDataLoaded('userCustomTiles', data);
                });
            }
        }, {
            key: '_loadRoomCustomTiles',
            value: function _loadRoomCustomTiles(roomTileIds) {
                var _this4 = this;

                if (roomTileIds.length > 0) {
                    $.get('/get/room-custom-tiles', { roomTileIds: roomTileIds }, function (data) {
                        return _this4._onWholeDataLoaded('roomCustomTiles', data);
                    }, 'json');
                } else {
                    this._onWholeDataLoaded('roomCustomTiles', []);
                }
            }
        }, {
            key: '_loadRoomData',
            value: function _loadRoomData(url) {
                var _this5 = this;

                $.get(url, function (data) {
                    return _this5._onWholeDataLoaded('roomData', data);
                });
            }
        }, {
            key: '_onWholeDataLoaded',
            value: function _onWholeDataLoaded(part, data) {
                this.dataLoaded[part] = true;
                this.data[part] = data;

                var customTiles = !this.tilesDesigner || this.dataLoaded.userCustomTiles && this.dataLoaded.roomCustomTiles;

                var wholeDataLoaded = this.dataLoaded.tiles && this.dataLoaded.roomData && customTiles;

                if (wholeDataLoaded && typeof this.onLoad === 'function') {
                    window._room =
                    this.onLoad(this.data);
                }
            }
        }, {
            key: '_parseRoomSettings',
            value: function _parseRoomSettings(roomData) {
                if (roomData && typeof roomData === 'string') {
                    return JSON.parse(roomData);
                }
            }
        }, {
            key: '_parseRoomCustomTiles',
            value: function _parseRoomCustomTiles() {
                var roomTileIds = [];

                var addId = function addId(id, custom) {
                    if (custom && id && roomTileIds.indexOf(id) === -1) {
                        roomTileIds.push(id);
                    }
                };

                if (this.data.roomSettings && Array.isArray(this.data.roomSettings.surfaces)) {
                    this.data.roomSettings.surfaces.forEach(function (surface) {
                        if (surface) {
                            addId(surface.tileId, surface.tileCustom);
                            addId(surface.tile2Id, surface.tile2Custom);
                            if (surface.freeDesign && Array.isArray(surface.freeDesignTiles)) {
                                surface.freeDesignTiles.forEach(function (freeDesignTile) {
                                    if (freeDesignTile) {
                                        addId(freeDesignTile.id, freeDesignTile.custom);
                                    }
                                });
                            }
                        }
                    });
                }

                return roomTileIds;
            }
        }, {
            key: '_loadData',
            value: function _loadData(roomIdUrl, roomSettingsData) {
                this._loadTiles();
                this._loadRoomData(roomIdUrl);

                this.data.roomSettings = this._parseRoomSettings(roomSettingsData);

                if (this.data.roomSettings?.specularLights) {
                    var sl = this.data.roomSettings.specularLights;
                    // if (typeof sl.hideTiles.value === 'boolean') guiObj.hideTiles.value = sl.hideTiles.value
                    if (typeof sl?.animate?.value === 'boolean') guiObj.animate.value = sl.animate.value
                    if (typeof sl?.rotateWithRoom?.value === 'boolean') guiObj.rotateWithRoom.value = sl.rotateWithRoom.value
                    if (typeof sl?.shininess?.value === 'number') guiObj.shininess.value = sl.shininess.value
                    if (typeof sl?.specularPower?.value === 'number') guiObj.specularPower.value = sl.specularPower.value
                    if (typeof sl?.specColPower?.value === 'number') guiObj.specColPower.value = sl.specColPower.value
                    if (guiObj.lightOptions && sl?.lightOptions) {
                        guiObj.lightOptions.forEach((light, i) => {
                            light.distance = sl.lightOptions[i].distance
                            light.speed = sl.lightOptions[i].speed
                            light.angle = sl.lightOptions[i].angle
                        })
                    }
                    if (guiObj.enableLights.value && sl?.enableLights?.value) guiObj.enableLights.value = sl.enableLights.value
                    if (guiObj.positions.value && sl?.positions?.value) {
                        guiObj.positions.value.forEach((position, i) => {
                            position.x = sl?.positions?.value[i].x
                            position.y = sl?.positions?.value[i].y
                            position.z = sl?.positions?.value[i].z
                        })
                    }
                }
                initGui(guiObj)

                if (this.tilesDesigner) {
                    this._loadUserCustomTiles();
                    var roomTileIds = this._parseRoomCustomTiles();
                    this._loadRoomCustomTiles(roomTileIds);
                }
            }
        }, {
            key: 'loadRoom',
            value: function loadRoom(url, onLoad) {
                var _this6 = this;

                this.onLoad = onLoad;

                this.data.id = window.JsConstants.room.id;
                this.data.url = window.JsConstants.room.url;

                if (this.data.url) {
                    $.get('/get/room/url/' + this.data.url, function (data) {
                        _this6.data.id = data.roomid;
                        _this6._loadData(url + data.roomid, data.roomsettings);
                    });
                } else if (this.data.id) {
                    this._loadData(url + this.data.id);
                }
            }
        }]);

        return Loader;
    }();

    // todo optimize

    var Locale = {
        'shapes': {
            'square': 'Square',
            'rectangle': 'Rectangle',
            'diamond': 'Diamond',
            'hexagon': 'Hexagonal'
        }
    };

    var locale = window.JsConstants && window.JsConstants.lang;
    Object.assign(Locale, locale.default); // todo fix

    function replace(text, inlineText) {
        if (typeof inlineText !== 'undefined') {
            if (text.indexOf('{s}') !== -1) {
                return text.replace('{s}', inlineText);
            }

            return text + ': ' + inlineText;
        }

        return text;
    }

    Locale.lang = function (text, inlineText) {
        if (!text) return '';

        if (locale.current) {
            var translation = locale.current[text];
            if (typeof translation === 'string') return replace(translation, inlineText);
        }

        if (locale.default) {
            var defaultText = locale.default[text];
            if (typeof defaultText === 'string') return replace(defaultText, inlineText);
        }

        return replace(text, inlineText);
    };

    var Filter = function () {
        function Filter(options, tiles, filterTilesList) {
            _classCallCheck(this, Filter);

            this.name = options.name || options.field;
            this.field = options.field;
            this.surface = options.surface;
            this._values = options.values?.split(',')?.map(value => value?.trim());

            this._tiles = tiles;
            this._filterTilesList = filterTilesList;

            this.createDomElement();
        }

        _createClass(Filter, [{
            key: 'createDomElement',
            value: function createDomElement() {
                this.domElement = document.createElement('div');
                this.domElement.className = 'filter-block';
                this.domElement.style.display = 'none';

                this._header = document.createElement('div');
                this._header.className = '-header';
                this._header.innerHTML = Locale.lang(this.name);
                this.domElement.appendChild(this._header);
            }
        }, {
            key: 'hide',
            value: function hide() {
                if (this.domElement.style.display !== 'none') {
                    this.domElement.style.display = 'none';
                }
            }
        }, {
            key: 'show',
            value: function show() {
                if (this.domElement.style.display !== '') {
                    this.domElement.style.display = '';
                }
            }
        }, {
            key: '_apply',
            value: function _apply() {
                if (typeof this._filterTilesList === 'function') this._filterTilesList();
            }
        }, {
            key: '_createSupportButton',
            value: function _createSupportButton(text) {
                var _this7 = this;

                var button = document.createElement('span');
                button.innerHTML = ' ' + Locale.lang(text) + ' ';
                button.addEventListener('click', function (event) {
                    return _this7._clickSupportButton(event);
                });

                return button;
            }
        }, {
            key: '_createSupportButtons',
            value: function _createSupportButtons() {
                var buttons = document.createElement('div');
                buttons.className = 'filter-block-support-buttons';

                return buttons;
            }
        }]);

        return Filter;
    }();

    var CheckboxFilter = function (_Filter) {
        _inherits(CheckboxFilter, _Filter);

        function CheckboxFilter(options, tiles, filterTilesList, index) {
            _classCallCheck(this, CheckboxFilter);

            var _this8 = _possibleConstructorReturn(this, (CheckboxFilter.__proto__ || Object.getPrototypeOf(CheckboxFilter)).call(this, options, tiles, filterTilesList));

            _this8._index = index;

            var values = _this8._parseValues();

            if (Array.isArray(values) && values.length > 0) {
                _this8._items = values.map(function (value) {
                    return { value: value.trim(), checked: true };
                });

                _this8.domElement.appendChild(_this8._createSupportButtons());

                _this8._items.forEach(function (item, index) {
                    return _this8._addItem(item, index);
                });
            }
            return _this8;
        }

        _createClass(CheckboxFilter, [{
            key: 'match',
            value: function match(fieldValue) {
                var _this9 = this;

                if (Array.isArray(this._items)) {
                    var result = false;
                    this._items.forEach(function (item) {
                        if (!fieldValue && item.value === 'others') {
                            if (item.checked) result = true;
                        } else if (item.value === fieldValue || _this9._subItemMatch(item.value, fieldValue)) {
                            if (item.checked) result = true;
                        }
                    });
                    return result;
                } else if (!fieldValue) {
                    return true;
                }
            }
        }, {
            key: '_compareStrings',
            value: function _compareStrings(str1, str2) {
                if (typeof str1 !== 'string' || typeof str2 !== 'string') return false;

                return str1.trim().toLowerCase() === str2.trim().toLowerCase();
            }
        }, {
            key: '_subItemMatch',
            value: function _subItemMatch(value, subValues) {
                var _this10 = this;

                if (typeof subValues !== 'string') return false;

                var subItems = subValues.split(',');
                return subItems.some(function (subItem) {
                    return _this10._compareStrings(subItem, value);
                });
            }
        }, {
            key: '_parseValues',
            value: function _parseValues() {
                var _this11 = this;

                var values = [];
                var others = void 0;

                var addValue = function addValue(text) {
                    var value = typeof text === 'string' ? text.trim().toLowerCase() : text;

                    if ((value || value === 0) && values.indexOf(value) === -1) {
                        values.push(value);
                    }
                };

                this._tiles.forEach(function (tile) {
                    var value = void 0;
                    if (tile.surface === _this11.surface) {
                        if (_this11.field === 'size') {
                            tile[_this11.field] = tile.width + 'x' + tile.height;
                        }

                        value = tile[_this11.field];
                        if (value || value === 0) {
                            var subValues = void 0;
                            if (typeof value === 'string') subValues = value.split(',');
                            if (subValues && subValues.length > 1) {
                                subValues.forEach(addValue);
                            } else {
                                addValue(value);
                            }
                        } else {
                            others = true;
                        }
                    }
                });

                values.sort();
                if (others) {
                    values.push('others');
                }

                return values;
            }
        }, {
            key: '_clickSupportButton',
            value: function _clickSupportButton(event) {
                var button = event.currentTarget;
                if (Array.isArray(this._items) && this._items.length > 0) {
                    this._items.forEach(function (item) {
                        switch (button.filterCheck) {
                            case 'None':
                                item.checked = false;
                                break;
                            case 'Invert':
                                item.checked = !item.checked;
                                break;

                            default:
                                // 'All'
                                item.checked = true;
                        }
                        item.domElement.checked = item.checked;
                    });

                    this._apply();
                }
            }
        }, {
            key: '_createSupportButton',
            value: function _createSupportButton(text) {
                var button = _get(CheckboxFilter.prototype.__proto__ || Object.getPrototypeOf(CheckboxFilter.prototype), '_createSupportButton', this).call(this, text);

                button.filterCheck = text;
                return button;
            }
        }, {
            key: '_createSupportButtons',
            value: function _createSupportButtons() {
                var buttons = _get(CheckboxFilter.prototype.__proto__ || Object.getPrototypeOf(CheckboxFilter.prototype), '_createSupportButtons', this).call(this);

                buttons.appendChild(this._createSupportButton('All'));
                buttons.appendChild(this._createSupportButton('None'));
                buttons.appendChild(this._createSupportButton('Invert'));
                return buttons;
            }
        }, {
            key: '_addItem',
            value: function _addItem(item, index) {
                var _this12 = this;

                var filterItem = document.createElement('div');
                filterItem.className = 'filter-item-checkbox';

                var checkbox = document.createElement('input');
                checkbox.id = 'checkboxFilter_' + this._index + '_' + index;
                checkbox.type = 'checkbox';
                checkbox.checked = item.checked;

                checkbox.addEventListener('change', function (event) {
                    item.checked = event.currentTarget.checked;
                    _this12._apply();
                });

                item.domElement = checkbox;
                filterItem.appendChild(checkbox);

                var label = document.createElement('label');
                label.htmlFor = checkbox.id;

                var value = item.value?.toLowerCase()
                var name = Locale.lang(value);
                if (value !== 'others') {
                    if (this.field === 'size') {
                        name += 'mm';
                    } else if (this.field !== 'finish') {
                        var valueName = this._values.find(item => item?.trim().toLowerCase() === value)
                        if (valueName) {
                            name = valueName
                        }
                    }
                }

                label.innerHTML = name
                filterItem.appendChild(label);

                this.domElement.appendChild(filterItem);
            }
        }]);

        return CheckboxFilter;
    }(Filter);

    var SliderFilter = function (_Filter2) {
        _inherits(SliderFilter, _Filter2);

        function SliderFilter(options, tiles, filterTilesList) {
            _classCallCheck(this, SliderFilter);

            var _this13 = _possibleConstructorReturn(this, (SliderFilter.__proto__ || Object.getPrototypeOf(SliderFilter)).call(this, options, tiles, filterTilesList));

            _this13._parseValues();
            if (_this13._min !== undefined && _this13._max !== undefined) {
                _this13._createSlider();
            }
            return _this13;
        }

        _createClass(SliderFilter, [{
            key: 'match',
            value: function match(fieldValue) {
                var value = this._getCorrectNumber(fieldValue);
                return this._userMin <= value && this._userMax >= value;
            }
        }, {
            key: '_parseValues',
            value: function _parseValues() {
                var _this14 = this;

                this._min = undefined;
                this._max = undefined;
                this._tiles.forEach(function (tile) {
                    if (tile.surface === _this14.surface) {
                        var value = _this14._getCorrectNumber(tile[_this14.field]);
                        if (_this14._min === undefined || _this14._min > value) _this14._min = value;
                        if (_this14._max === undefined || _this14._max < value) _this14._max = value;
                    }
                });
            }
        }, {
            key: '_createSlider',
            value: function _createSlider() {
                var _this15 = this;

                var slider = document.createElement('div');
                this._$slider = window.$(slider);

                this._userMin = this._min;
                this._userMax = this._max;

                this.domElement.appendChild(this._createSupportButtons());
                this.domElement.appendChild(slider);

                this._updateHeader(this._min, this._max);

                window.$(function () {
                    _this15._$slider.slider({
                        range: true,
                        min: _this15._min,
                        max: _this15._max,
                        step: 0.01,
                        values: [_this15._userMin, _this15._userMax],
                        slide: function slide(event, ui) {
                            return _this15._updateHeader(ui.values[0], ui.values[1]);
                        },
                        change: function change(event, ui) {
                            _this15._userMin = ui.values[0];
                            _this15._userMax = ui.values[1];

                            _this15._apply();
                        }
                    });
                });
            }
        }, {
            key: '_clickSupportButton',
            value: function _clickSupportButton() {
                this._$slider.slider('values', [this._min, this._max]);
                this._updateHeader(this._min, this._max);
            }
        }, {
            key: '_createSupportButtons',
            value: function _createSupportButtons() {
                var buttons = _get(SliderFilter.prototype.__proto__ || Object.getPrototypeOf(SliderFilter.prototype), '_createSupportButtons', this).call(this);

                buttons.appendChild(this._createSupportButton('All'));
                return buttons;
            }
        }, {
            key: '_updateHeader',
            value: function _updateHeader(min, max) {
                if (this.field === 'price') {
                    this._header.innerHTML = Locale.lang(this.field) + ': $' + min + ' - $' + max;
                } else {
                    this._header.innerHTML = Locale.lang(this.field) + ': ' + min + ' - ' + max;
                }
            }
        }, {
            key: '_getCorrectNumber',
            value: function _getCorrectNumber(value) {
                var number = Number(value);
                if (isFinite(number)) {
                    return number;
                }
                return 0;
            }
        }]);

        return SliderFilter;
    }(Filter);

    var Filters = function () {
        function Filters(tiles, room, onLoad) {
            var _this16 = this;

            _classCallCheck(this, Filters);

            this._list = [];

            this._tiles = tiles;
            this._room = room;
            this._onLoad = onLoad;

            this._loaded = false;
            this._searchWord = '';

            this._defaultFilters = [];

            if (!window.JsConstants.config.notUseDefaultProductFilters) {
                try {
                    var surfaceTypes = [...new Set(JSON.parse(room.surfaces)?.map(surface => surface.type))];

                    if (surfaceTypes?.length) {
                        if (window.JsConstants.config.productFilterSize) {
                            this._defaultFilters.push(...surfaceTypes.map(surface => ({ name: 'Size', field: 'size', surface: surface, type: 'checkbox' })));
                        }
                        if (window.JsConstants.config.productFilterFinish) {
                            this._defaultFilters.push(...surfaceTypes.map(surface => ({ name: 'Finish', field: 'finish', surface: surface, type: 'checkbox' })));
                        }
                    }
                } catch {}
            }

            this._resultCountElement = document.getElementById('topPanelSearchResult');

            window.$.ajax({
                url: '/get/filters',
                success: function success(loadedFilters) {
                    return _this16._init(loadedFilters);
                }
            });
        }

        _createClass(Filters, [{
            key: 'show',
            value: function show() {
                var _this17 = this;

                if (this._loaded && this._room.currentTiledSurface) {
                    this._list.forEach(function (filter) {
                        if (filter.surface === _this17._room.currentTiledSurface.type) {
                            filter.show();
                        } else {
                            filter.hide();
                        }
                    });

                    this._filterTilesList();
                }
            }
        }, {
            key: 'find',
            value: function find(text) {
                if (this._loaded && this._room.currentTiledSurface) {
                    this._searchWord = text ? text.toString().trim().toLowerCase() : '';

                    this._find();
                }
            }
        }, {
            key: '_find',
            value: function _find() {
                var _this18 = this;

                var foundTilesCount = 0;

                this._tiles.forEach(function (tile) {
                    if (tile.li.hidedByFilter || tile.li.rotoHidden || tile.li.dataset.hidden === 'hidden' || tile.removed) return;

                    var name = tile.name.toLowerCase();
                    if (name.indexOf(_this18._searchWord) === -1) {
                        tile.hide();
                    } else {
                        tile.show();
                        foundTilesCount += 1;
                    }
                });

                this._showFoundTilesCount(this._searchWord, foundTilesCount);

                this._tiles.showIcons();
            }
        }, {
            key: '_showFoundTilesCount',
            value: function _showFoundTilesCount(searchWord, count) {
                if (searchWord) {
                    this._resultCountElement.style.display = '';
                    if (count === 1) {
                        this._resultCountElement.innerHTML = Locale.lang('FILTER_FOUND_ONE_TILE');
                    } else if (count > 1) {
                        this._resultCountElement.innerHTML = Locale.lang('FILTER_FOUND_TILES', count);
                    } else {
                        this._resultCountElement.innerHTML = Locale.lang('FILTER_TILES_NOT_FOUND');
                    }
                } else if (count === 0) {
                    this._resultCountElement.style.display = '';
                    this._resultCountElement.innerHTML = Locale.lang('FILTER_TILES_NOT_FOUND');
                } else {
                    this._resultCountElement.style.display = 'none';
                }
            }
        }, {
            key: '_init',
            value: function _init(loadedFilters) {
                var _this19 = this;

                var topPanelFilter = document.getElementById('topPanelFilter');

                var filtersList = Array.isArray(loadedFilters) ? this._defaultFilters.concat(loadedFilters) : this._defaultFilters;

                filtersList.forEach(function (filterOptions, index) {
                    var filter = void 0;
                    switch (filterOptions.type) {
                        case 'checkbox':
                            filter = new CheckboxFilter(filterOptions, _this19._tiles, function () {
                                return _this19._filterTilesList();
                            }, index);
                            break;

                        case 'slider':
                            filter = new SliderFilter(filterOptions, _this19._tiles, function () {
                                return _this19._filterTilesList();
                            });
                            break;
                    }

                    if (filter) {
                        topPanelFilter.appendChild(filter.domElement);
                        _this19._list.push(filter);
                    }
                });

                this._loaded = true;
                this.show();
                if (typeof this._onLoad === 'function') this._onLoad();
            }
        }, {
            key: '_filterTilesList',
            value: function _filterTilesList() {
                var _this20 = this;

                this._tiles.forEach(function (tile) {
                    if (tile.li.rotoHidden || tile.li.dataset.hidden === 'hidden' || tile.removed) return;

                    var correctSurface = !tile.surface || tile.surface === _this20._room.currentTiledSurface.type;
                    var match = _this20._filterMatch(tile);
                    if (correctSurface && match || tile.custom) {
                        // todo fix tile.custom
                        tile.show();
                        if (tile.li.hidedByFilter) tile.li.hidedByFilter = false;
                    } else {
                        tile.hide();
                        if (!tile.li.hidedByFilter) tile.li.hidedByFilter = true;
                    }
                });

                this._find();
            }
        }, {
            key: '_filterMatch',
            value: function _filterMatch(tile) {
                var _this21 = this;

                return this._list.every(function (filter) {
                    if (filter.surface !== _this21._room.currentTiledSurface.type) {
                        return true;
                    }

                    return filter.match(tile[filter.field]);
                });
            }
        }]);

        return Filters;
    }();

    var API = function (window) {
        var vendor = 'TracingIdea';
        var app = 'TileVisualizer';

        if (!window[vendor]) window[vendor] = {};
        if (!window[vendor][app]) window[vendor][app] = {};

        var api = window[vendor][app];

        return {
            addMethod: function addMethod(name, method) {
                api[name] = method;
            }
        };
    }(window);

    // // import { UI } from '../InteriorUI.js';

    var tiles = [];

    var onTileClick = void 0;

    function Tile(tileData, index) {
        this.id = Number(tileData.id);
        this.index = index;
        this.custom = Boolean(tileData.custom);

        this.name = tileData.name || '';

        this.file = tileData.file || '';
        this.icon = tileData.icon || tileData.file;
        this.width = Number(tileData.width) || 400;
        this.height = Number(tileData.height) || 400;
        this.size = this.width + 'x' + this.height;
        this.shape = tileData.shape || 'square';
        this.surface = tileData.surface;
        this.grout = Number(tileData.grout) || 0;

        this.price = tileData.price;
        this.url = tileData.url;

        this.rotoPrintSetName = tileData.rotoPrintSetName || '';
        if (window.JsConstants.config.Product.rotoPrintSetAsName && this.rotoPrintSetName) {
            this.name = this.rotoPrintSetName;
        }

        this.created_at = tileData.created_at;

        this.shapePreparedSet = this.shape === 'preparedSet' || this.shape === 'notionHerringbon' || this.shape === 'riverstoneRohmboid' || this.shape === 'rivertsoneChevron' || this.shape === 'stoneSystemCombo';

        this.expProps = tileData.expProps
        this.parseExpandableProperties(tileData.expProps);

        this.finish = tileData.finish || ''; // glossy
        this.usedColors = tileData.usedColors || '';

        this.needsRotate = tileData.needsRotate;

        // this.highlighted = Boolean(this.buildersRange);

        if (tileData.li) {
            this.li = tileData.li;
        } else {
            this.createTileLi();
        }
    }
    (function () {
        this.preparedSetOffset = { x: 0, y: 0 };

        var rotoPrintSets = [];

        rotoPrintSets.add = function (setName, surface) {
            var name = setName.trim().toLowerCase();
            var itemExist = rotoPrintSets.some(function (rotoPrintSet) {
                return rotoPrintSet.name === name && rotoPrintSet.surface === surface;
            });
            if (!itemExist) {
                rotoPrintSets.push({ name: name, surface: surface });
                return true;
            }
            return false;
        };

        function selectTile(event, secondLayerTileIndex, secondLayer) {
            var tileIndex = secondLayer ? secondLayerTileIndex : this.dataset.index;

            if (typeof onTileClick === 'function') {
                onTileClick(tileIndex, secondLayer);
            }
        }

        function setSecondLayerTile(event) {
            event.stopPropagation();
            selectTile(event, this.dataset.index, true);
        }

        this.parseExpandableProperties = function (expProps) {
            if (expProps) {
                var expandableProperties = JSON.parse(expProps);
                for (var propertyName in expandableProperties) {
                    if (expandableProperties.hasOwnProperty(propertyName) && !this.hasOwnProperty(propertyName)) {
                        this[propertyName] = expandableProperties[propertyName];
                    }
                }
            }
        };

        this.getExtraOptionsText = function () {
            var _this22 = this;

            var htmlString = '';
            var options = window.JsConstants.config.tileExtraOptions;
            if (Array.isArray(options) && _this22 && _this22.expProps) {
                var expProps = JSON.parse(_this22.expProps)
                options.forEach(function (option) {
                    if (option && expProps.hasOwnProperty(option) && expProps[option]) {
                        var optionText = Locale.lang(option, expProps[option]);
                        htmlString += '<p>' + optionText + '</p>';
                    }
                });
            }
            return htmlString;
        };

        this.getPriceText = function () {
            if (window.JsConstants.config.ProductInfo.price && this.price) {
                var priceText = Locale.lang('PRICE_TEMPLATE', this.price);
                return '<p class="-price">' + priceText + '</p>';
            }
            return '';
        };

        this.getInfoText = function () {
            var config = window.JsConstants.config.ProductInfo;

            var size = config.size ? '<p>' + Locale.lang('Size') + ': ' + this.width + 'mm x ' + this.height + 'mm</p>' : '';

            var finish = config.finish && this.finish ? '<p>' + Locale.lang('Finish') + ': ' + Locale.lang(this.finish) + '</p>' : '';

            var url = config.url && this.url ? '<p><a href="' + this.url + '" target="blank">' + Locale.lang('PRODUCT_URL') + '</a></p>' : '';

            var usedColors = config.colors && this.usedColors ? '<p>' + Locale.lang('COLORS_USED') + ': ' + this.usedColors + '</p>' : '';

            var shape = config.shape ? '<p>' + Locale.lang('Shape') + ': ' + Locale.lang(this.shape) + '</p>' : '';

            var rotoPrintSet = config.rotoPrintSet && this.rotoPrintSetName ? '<p>' + Locale.lang('Roto Print Set') + ': ' + Locale.lang(this.rotoPrintSetName) + '</p>' : '';

            if (config.stile === 'Client3') {
                var urlBtn = url ? '<div class="-url"><p>Order Sample</p>' + url + '</div>' : '';
                return '<div class="tile-list-text"><p class="-caption">' + this.name + '</p><div>' + this.getExtraOptionsText() + this.getPriceText() + '</div>' + urlBtn + ' </div>';
            }

            return '<div class="tile-list-text"><p class="-caption">' + this.name + '</p>' + size + shape + finish + rotoPrintSet + this.getExtraOptionsText() + this.getPriceText() + url + usedColors + '</div>';
        };

        this.createTileLi = function () {
            this.iconImage = document.createElement('img');
            this.iconImage.class = 'tile-list-thumbnail';

            this.li = document.createElement('li');
            this.li.id = 'tile_' + this.index;
            this.li.dataset.index = this.index;

            var liClass = 'top-panel-content-tiles-list-item';
            if (this.highlighted) liClass += ' top-panel-content-tiles-list-item-highlighted';

            this.li.className = liClass;
            this.li.style.display = 'none';

            if (this.rotoPrintSetName) {
                var rotoPrintSetAdded = rotoPrintSets.add(this.rotoPrintSetName, this.surface);
                if (!rotoPrintSetAdded) {
                    this.li.rotoHidden = true;
                }
            }

            this.li.layer2btn = document.createElement('button');
            this.li.layer2btn.dataset.index = this.index;


            this.li.finalize = () => {

            var $imageHolder = $('<div class="tile-list-thumbnail-image-holder"></div>').append(this.iconImage);

            var $tileText = $(this.getInfoText());

            var $li = $(this.li).click(selectTile).append($imageHolder, $tileText);

            if (this.shape === 'square' || this.shape === 'rectangle' || this.shape === 'diamond') {
                var $btnLayer1 = $('<button type="button" class="button-tile-list-choose-tile">1</button>');

                var $btnLayer2 = $(this.li.layer2btn).addClass('button-tile-list-choose-tile').text('2').click(setSecondLayerTile);

                $li.append($('<div class="buttons-holder-tile-list-choose-tile" style="display: none;"></div>').append($btnLayer1, $btnLayer2));
            }

            this.li.finalize = () => {};
            };
        };

        this.getRotoPrintSet = function () {
            var _this23 = this;

            // return tiles.getRotoPrintSet(this);
            if (this.rotoPrintSetName && typeof this.rotoPrintSetName === 'string') {
                var rotoPrintTiles = [];
                tiles.forEach(function (tile) {
                    if (tile.rotoPrintSetName === _this23.rotoPrintSetName && tile.surface === _this23.surface) {
                        rotoPrintTiles.push(tile);
                    }
                });
                return rotoPrintTiles;
            }
            return [this];
        };

        this.getRandomInSet = function () {
            // return tiles.getRotoPrintSet(this);
            var tilesSet = this.getRotoPrintSet();
            if (tilesSet.length > 1) {
                return tilesSet[Math.floor(Math.random() * tilesSet.length)];
            }
            return this;
        };

        this.hide = function () {
            if (this.li.style.display !== 'none') this.li.style.display = 'none';
        };

        this.show = function () {
            if (this.li.style.display !== '') this.li.style.display = '';
        };

        this.remove = function () {
            this.hide();
            this.removed = true;
            // todo clear surfaces
        };
    }).call(Tile.prototype);

    tiles.getById = function (tileId, custom) {
        var foundTile = void 0;
        var id = Number(tileId);
        if (!isNaN(id)) {
            this.some(function (tile) {
                if (tile.id === id && Boolean(tile.custom) === Boolean(custom)) {
                    foundTile = tile;
                    return true;
                }
            });
        }
        return foundTile;
    };

    tiles.getIndexById = function (id, custom) {
        var tile = tiles.getById(id, custom);
        return tile && tile.index;
    };

    tiles.isExist = function (id, custom) {
        return Boolean(tiles.getById(id, custom));
    };

    tiles.add = function (tileData) {
        if (tiles.isExist(tileData.id, tileData.custom)) return;

        var tile = new Tile(tileData, tiles.length);
        tiles.push(tile);

        return tile;
    };

    tiles.remove = function (id, custom) {
        var tile = tiles.getById(id, custom);

        if (tile) tile.remove();
    };

    tiles.getRotoPrintSet = function (tile) {
        return tile && tile.getRotoPrintSet();
    };

    tiles.getRandomInSet = function (tile) {
        return tile && tile.getRandomInSet();
    };

    tiles.updateLayerButtons = function (tileIndex) {
        tiles.forEach(function (tile) {
            if (tile.li.layer2btn) {
                if (tileIndex === undefined || tiles[tileIndex].shape !== 'hexagon' && tiles[tileIndex].width === tile.width && tiles[tileIndex].height === tile.height) {
                    tile.li.layer2btn.disabled = '';
                } else {
                    tile.li.layer2btn.disabled = 'disabled';
                }
            }
        });
    };

    tiles.showHideLayerButtons = function (surface, fillTypeIndex) {
        var display = 'none';
        if (fillTypeIndex === 1) {
            display = '';
            tiles.updateLayerButtons(surface.tileIndex);
        } else {
            surface.tile2Index = undefined;
        }
        $('.buttons-holder-tile-list-choose-tile').css('display', display);
    };

    // isTilesSame
    tiles.isSame = function (item1, item2) {
        var tile1 = typeof item1 === 'number' ? tiles[item1] : (typeof item1 === 'undefined' ? 'undefined' : _typeof(item1)) === 'object' ? item1 : undefined;

        var tile2 = typeof item2 === 'number' ? tiles[item2] : (typeof item2 === 'undefined' ? 'undefined' : _typeof(item2)) === 'object' ? item2 : undefined;

        if (tile1 && tile2 && tile1.shape === tile2.shape && tile1.width === tile2.width && tile1.height === tile2.height) {
            return true;
        }
        return false;
    };

    tiles.enabledPatternButtons = function (surface) {
        var tile = {};
        if (surface.tileIndex !== undefined) {
            tile = tiles[surface.tileIndex];
        }

        switch (tile.shape) {
            case 'square':
            case 'rectangle':
                document.getElementById('topPanelSurfacePattern_1').disabled = '';
                document.getElementById('topPanelSurfacePattern_2').disabled = '';
                document.getElementById('topPanelSurfacePattern_3').disabled = '';
                break;

            case 'diamond':
                if (surface.fillTypeIndex > 1) {
                    surface.fillTypeIndex = 0;
                    tiles.showHideLayerButtons(surface, 0);
                    document.getElementById('topPanelSurfacePattern_0').checked = true;
                }
                document.getElementById('topPanelSurfacePattern_1').disabled = '';
                document.getElementById('topPanelSurfacePattern_2').disabled = 'disabled';
                document.getElementById('topPanelSurfacePattern_3').disabled = 'disabled';
                break;

            default:
                // hexagon and etc
                if (surface.fillTypeIndex > 0) {
                    surface.fillTypeIndex = 0;
                    tiles.showHideLayerButtons(surface, 0);
                    document.getElementById('topPanelSurfacePattern_0').checked = true;
                }
                document.getElementById('topPanelSurfacePattern_1').disabled = 'disabled';
                document.getElementById('topPanelSurfacePattern_2').disabled = 'disabled';
                document.getElementById('topPanelSurfacePattern_3').disabled = 'disabled';
                break;
        }

        if (tile.shapePreparedSet) {
            if (surface.rotation === 45 || surface.rotation === 135) surface.rotate(0);
            document.getElementById('topPanelSurfaceRotation_0').checked = true;
            document.getElementById('topPanelSurfaceRotation_45').disabled = 'disabled';
            document.getElementById('topPanelSurfaceRotationLabel_45').classList.add('disabled');
            document.getElementById('topPanelSurfaceRotation_135').disabled = 'disabled';
            document.getElementById('topPanelSurfaceRotationLabel_135').classList.add('disabled');
        } else {
            document.getElementById('topPanelSurfaceRotation_45').disabled = '';
            document.getElementById('topPanelSurfaceRotationLabel_45').classList.remove('disabled');
            document.getElementById('topPanelSurfaceRotation_135').disabled = '';
            document.getElementById('topPanelSurfaceRotationLabel_135').classList.remove('disabled');
        }
    };

    function showTileIcons() {
        // const indexes = tiles.map((tile, index) => index);
        var tilesListBox = document.getElementById('topPanelTilesListBox');

        var showIcons = function showIcons() {
            tiles.forEach(function (tile) {
                if (tile.iconImage && !tile.iconImage.src && tile.li.style.display !== 'none' && tile.li.offsetTop - tilesListBox.scrollTop < window.innerHeight + 1000 && tile.li.offsetTop - tilesListBox.scrollTop > -1000) {
                    tile.iconImage.src = tile.icon;
                }
            });
        };

        tilesListBox.addEventListener('scroll', showIcons);

        showIcons();

        return showIcons;
    }

    function fillTilesList(tilesData) {
        if (Array.isArray(tilesData)) {
            tilesData.forEach(function (tileData) {
                return tiles.add(tileData);
            });
        }
    }

    function fillCustomTiles(loadedTiles) {
        function parseTileName(url) {
            if (url && typeof url === 'string') {
                var fileName = url.match(/[^/]+(?=\.\w+$)/)[0].replace('_', ' ');
                return fileName.charAt(0).toUpperCase() + fileName.slice(1);
            }
            return 'Tile';
        }

        if (Array.isArray(loadedTiles)) {
            loadedTiles.forEach(function (tileData) {
                var settings = JSON.parse(tileData.settings);

                tiles.add({
                    id: tileData.id,
                    custom: true,
                    name: parseTileName(settings.baseTileUrl),
                    width: tileData.width,
                    height: tileData.height,
                    shape: tileData.shape,
                    file: tileData.file,
                    usedColors: settings.usedColorNames.join(' / '),
                    needsRotate: tileData.shape === 'hexagon'
                });
            });
        }
    }

    // @jscrambler define domainLock {domains:[app001.3droomvisualizer.com, floorsdirect.3droomvisualizer.com, tdcc2.3dtilevisualizer.com, simuladorfv.westus.cloudapp.azure.com, tilevisualiser.colortile.com.au, visualizer.cletile.com]} as dL
    // @jscrambler enable dL
    tiles.load = function (onLoad, onClick) {
        $.ajax({
            url: '/get/tiles',
            success: function success(tilesData) {
                fillTilesList(tilesData);

                tiles.showIcons = showTileIcons();

                onLoad();
                onTileClick = onClick;
            }
        });
    };

    tiles.fill = function (onClick, loadedData) {
        fillTilesList(loadedData.tiles);
        fillCustomTiles(loadedData.userCustomTiles);
        fillCustomTiles(loadedData.roomCustomTiles);
        onTileClick = onClick;

        tiles.showIcons = showTileIcons();
    };

    /**
     * Receive custom tile data and add it to Tiles list
     */
    API.addMethod('addTile', function (tileData) {
        var tile = tiles.add(tileData);
        tile.show();
        tile.iconImage.src = tile.icon;

        var list = topPanelTilesListUl;
        list.insertBefore(tile.li, list.firstChild); // todo move to UI.js
    });

    /**
     * Remove custom tile data by id
     */
    API.addMethod('removeTile', tiles.remove);

    var TilesList = tiles;

    function UI(room) {
        this.tiles = [];

        var _this = this;

        var topPanelVisible = false;

        /**
         * Show alerts for user
         *
         * @method showAlert
         * @param {string} message
         * @param {?string} type - 'warning', 'success', 'danger', 'error' or 'info'
         */
        this.showAlert = function (message, type) {
            if (message) {
                switch (type) {
                    case 'warning':
                        this.alertWarning(message);
                        break;
                    case 'success':
                        this.alertSuccess(message);
                        break;
                    case 'danger':
                        this.alertDanger(message);
                        break;
                    case 'error':
                        this.alertError(message);
                        break;

                    default:
                        this.alert(message);
                        break;
                }
            }
        };

        this.alertWarning = function (message) {
            window.$('#warningAlertBox').html('<strong>Warning!</strong> ' + message);
            window.$('#warningAlertBox').fadeIn();
        };

        this.alertSuccess = function (message) {
            window.$('#successAlertBox').html('<strong>Success!</strong> ' + message);
            window.$('#successAlertBox').fadeIn();
        };

        this.alertDanger = function (message) {
            window.$('#dangerAlertBox').html('<strong>Danger!</strong> ' + message);
            window.$('#dangerAlertBox').fadeIn();
        };

        this.alertError = function (message) {
            window.$('#dangerAlertBox').html('<strong>Error!</strong> ' + message);
            window.$('#dangerAlertBox').fadeIn();
        };

        this.alert = function (message) {
            window.$('#infoAlertBox').html('<strong>Info!</strong> ' + message);
            window.$('#infoAlertBox').fadeIn();
        };

        this.isMobileDevice = function () {
            return UI.isMobileDevice();
        };

        /**
         * Show or hide tiles panel
         *
         * @method topPanelSlide
         * @param {?boolean} show - true to show panel, false|undefined to hide it
         */
        this.topPanelSlide = function (show) {
            if (typeof show === 'boolean' && show) {
                if (!topPanelVisible) {
                    topPanelVisible = true;
                    window.$('#topPanel').animate({ 'right': 0 }, 'fast');
                    window.$('#topPanelHideIcon').removeClass('glyphicon-triangle-left').addClass('glyphicon-triangle-right');
                }
            } else if (topPanelVisible) {
                topPanelVisible = false;
                window.$('#topPanel').animate({ 'right': -400 }, 'fast');
                window.$('#topPanelHideIcon').removeClass('glyphicon-triangle-right').addClass('glyphicon-triangle-left');
            }
        };

        this.topPanelToggle = function () {
            _this.topPanelSlide(!topPanelVisible);
        };

        this.topPanelHide = function () {
            _this.topPanelSlide(false);
        };

        this.topPanelShow = function () {
            _this.topPanelSlide(true);
        };

        /**
         * Switch tiles panel
         *
         * @method switchTopPanel
         * @param {string} panel - Panel HTMLElement ID
         * @param {?string} display - CSS display value
         */
        this.switchTopPanel = function (panel) {
            var display = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

            var panelHtmlElement = document.getElementById(panel);
            if (panelHtmlElement.style.display !== display) {
                panelHtmlElement.style.display = display;

                if ((display !== 'none') && (panel === 'topPanel')) {
                    var currentUl = document.getElementById('topPanelTilesListUl');
                    if (currentUl !== topPanelTilesListUl) {
                        currentUl.parentElement.insertBefore(topPanelTilesListUl, currentUl);
                        currentUl.remove();

                        topPanelTilesListUl.querySelectorAll('li').forEach(li => li.finalize());
                    }
                }
            }

            var panels = ['topPanel', 'topPanelCeilingColor', 'productInfoPanel'];
            panels.forEach(function (otherPanel) {
                var otherPanelHtmlElement = document.getElementById(otherPanel);
                if (otherPanelHtmlElement && otherPanelHtmlElement !== panelHtmlElement) {
                    otherPanelHtmlElement.style.display = 'none';
                }
            });
        };

        /**
         * Change grout size text on grout panel
         *
         * @method changeGroutSizeText
         * @param {HTMLElementEvent} event - not used
         * @param {?number} value - Grout size value or {HTMLElement input value
         */
        this.changeGroutSizeText = function (event, value) {
            if (value === undefined) {
                value = event && event.currentTarget && event.currentTarget.value;
            }
            document.getElementById('topPanelGroutSizeText').innerHTML = value + ' mm';
        };

        this.changeGroutSize = function (value) {
            var groutSizeRange = document.getElementById('topPanelGroutSizeRange');
            if (Number(groutSizeRange.value) !== Number(value)) {
                groutSizeRange.value = value;
                this.changeGroutSizeText(undefined, value);
            }
        };

        function tilesSort(field, order) {
            // field: name, created_at, price, size;  order: 1 = asc, -1 = desc
            if (Array.isArray(_this.tiles) && _this.tiles.length) {
                var tilesListUl = topPanelTilesListUl;

                var values = _this.tiles.map(function (tile, index) {
                    var value = '';
                    if (typeof tile[field] === 'string') {
                        value = tile[field].trim().toLowerCase();
                    } else if (typeof tile[field] === 'number') {
                        value = tile[field];
                    }

                    return { value: value, index: index };
                });

                values.sort(function (a, b) {
                    if (a.value > b.value) return order;else if (a.value < b.value) return -order;
                    return 0;
                });

                values.forEach(function (value) {
                    var tile = _this.tiles[value.index];
                    if (tile.custom) {
                        tilesListUl.insertBefore(tile.li, tilesListUl.firstChild);
                    } else {
                        tilesListUl.appendChild(tile.li);
                    }
                });

                _this.tiles.showIcons();
            }
        }

        this.addTilesToList = function (sortType) {
            switch (sortType) {
                case 'z-a':
                    tilesSort('name', -1);
                    break;
                case 'newest first':
                    tilesSort('created_at', -1);
                    break;
                case 'oldest first':
                    tilesSort('created_at', 1);
                    break;

                default:
                    // 'a-z'
                    tilesSort('name', 1);
            }
        };

        this.changeTilesSort = function () {
            _this.addTilesToList(this.value);
        };

        this.hideTilesPreloader = function () {
            document.getElementById('loadTilesAnimationContainer').style.display = 'none';
        };

        function getProductInfoElement(tile) {
            var tileItem = document.createElement('div');
            tileItem.className = 'top-panel-content-tiles-list-item';
            tileItem.innerHTML = '<div class="tile-list-thumbnail-image-holder"><img src="' + tile?.file + '" class="tile-list-thumbnail"></div>' + tile?.getInfoText();
            return tileItem;
        }

        this.addProductInfo = function (room, tiles) {
            var productInfoTilesList = document.getElementById('productInfoTilesList');
            productInfoTilesList.innerHTML = ''; // '<div class="top-panel-label">Used product information</div>';
            if (room.size) {
                productInfoTilesList.innerHTML = '<div class="top-panel-label">Room size: ' + room.size.x / 1000 + 'm \xD7 ' + room.size.z / 1000 + 'm, Height: ' + room.size.y / 1000 + 'm</div>';
            }

            room.tiledSurfaces.forEach(function (tiledSurface, index) {
                var tileApplied = tiledSurface.tileIndex !== undefined || tiledSurface.tile2Index !== undefined || tiledSurface.freeDesignTiles && tiledSurface.freeDesignTiles.length > 0;

                if (tileApplied) {
                    var surfaceProductInfo = document.createElement('p');
                    var usedTileIds = [];

                    if (!tiledSurface.name) {
                        // todo move to surfaces init
                        if (room.surfaceTypes && tiledSurface.type) {
                            tiledSurface.name = room.surfaceTypes[tiledSurface.type];
                        } else if (tiledSurface.type) {
                            tiledSurface.name = tiledSurface.type;
                        } else {
                            tiledSurface.name = 'Surface ' + (1 + index);
                        }
                    }
                    surfaceProductInfo.className = 'top-panel-label';
                    surfaceProductInfo.textContent = Locale.lang(tiledSurface.name);
                    productInfoTilesList.appendChild(surfaceProductInfo);

                    if (tiledSurface.tileIndex !== undefined) {
                        productInfoTilesList.appendChild(getProductInfoElement(tiles[tiledSurface.tileIndex]));
                        usedTileIds.push({
                            id: tiles[tiledSurface.tileIndex].id,
                            custom: tiles[tiledSurface.tileIndex].custom,
                            rotoPrintSetName: tiles[tiledSurface.tileIndex].rotoPrintSetName
                        });
                    }

                    if (tiledSurface.tile2Index !== undefined && tiledSurface.tile2Index !== tiledSurface.tileIndex) {
                        productInfoTilesList.appendChild(getProductInfoElement(tiles[tiledSurface.tile2Index]));
                        usedTileIds.push({
                            id: tiles[tiledSurface.tile2Index].id,
                            custom: tiles[tiledSurface.tile2Index].custom,
                            rotoPrintSetName: tiles[tiledSurface.tile2Index].rotoPrintSetName
                        });
                    }

                    if (tiledSurface.freeDesignTiles) {
                        tiledSurface.freeDesignTiles.forEach(function (freeDesignTile) {
                            var tileUsed = usedTileIds.some(function (usedTile) {
                                return (freeDesignTile._tile.id === usedTile.id && freeDesignTile._tile.custom === usedTile.custom) || (freeDesignTile._tile.rotoPrintSetName && (freeDesignTile._tile.rotoPrintSetName === usedTile.rotoPrintSetName));
                            });
                            if (!tileUsed) {
                                var tile = tiles.getById(freeDesignTile._tile.id, freeDesignTile._tile.custom);
                                productInfoTilesList.appendChild(getProductInfoElement(tile));
                                usedTileIds.push({
                                    id: freeDesignTile._tile.id,
                                    custom: freeDesignTile._tile.custom,
                                    rotoPrintSetName: freeDesignTile._tile.rotoPrintSetName
                                });
                            }
                        });
                    }
                }
            });
        };

        this.changeFullScreenMode = function (fullScreen) {
            if (!document.fullscreenElement && !document.mozFullScreenElement && !document.webkitFullscreenElement && fullScreen !== false || fullScreen === true) {
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen();
                } else if (document.documentElement.mozRequestFullScreen) {
                    document.documentElement.mozRequestFullScreen();
                } else if (document.documentElement.webkitRequestFullscreen) {
                    document.documentElement.webkitRequestFullscreen(window.Element.ALLOW_KEYBOARD_INPUT);
                }
            } else if (document.cancelFullScreen) {
                document.cancelFullScreen();
            } else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            } else if (document.webkitCancelFullScreen) {
                document.webkitCancelFullScreen();
            }
        };

        this.showAdditionalOptions = function (event) {
            if (!room || !room.currentTiledSurface) {
                _this.showAlert('Surface not selected. To select surface click on wall or floor.', 'warning');
                return;
            }

            var show = !$(event.currentTarget).hasClass('top-panel-button-active');

            $('.top-panel-button').removeClass('top-panel-button-active');
            $('.top-panel-option-box').hide();

            if (show) {
                $(event.currentTarget).addClass('top-panel-button-active');

                switch (event.currentTarget.id) {
                    case 'btnLayout':
                        $('#topPanelLayout').show();
                        break;
                    case 'btnGrout':
                        $('#topPanelGrout').show();
                        break;
                    case 'btnRefine':
                        if (typeof _this.filtersShow === 'function') {
                            $('#topPanelFilter').show();
                            _this.filtersShow();
                        }
                        break;
                }
            }
        };

        this.updateSkewSizeButtons = function (fillTypeIndex) {
            var skewPattern = fillTypeIndex === 2 || fillTypeIndex === 3;
            $('.radio-skew-size input').attr('disabled', !skewPattern);
        };

        this.updateSkewSize = function (value) {
            $('.radio-skew-size input').each(function (i, button) {
                button.checked = button.value === String(value);
            });
        };

        this.updateValues = function (surface) {
            _this.changeGroutSize(surface.groutSize);
            document.getElementById('topPanelCheckFreeDesign').checked = surface.freeDesign;
            document.getElementById('topPanelSurfaceRotation_' + surface.rotation).checked = true;
            document.getElementById('topPanelSurfacePattern_' + surface.fillTypeIndex).checked = true;

            _this.updateSkewSize(surface.skewSize);
            _this.updateSkewSizeButtons(surface.fillTypeIndex);
        };

        function bookmarkLink() {
            var url = $('#dialogSavedRoomUrlInput').val();
            if (url) {
                if (window.sidebar && window.sidebar.addPanel) {
                    // Mozilla Firefox Bookmark
                    window.sidebar.addPanel(document.title, url, '');
                } else if (window.external && window.external.hasOwnProperty('AddFavorite')) {
                    // IE Favorite
                    window.external.AddFavorite(url, document.title); // eslint-disable-line new-cap
                } else if (window.opera && window.print) {
                    // Opera Hotlist
                    var a = document.createElement('a');
                    a.setAttribute('href', url);
                    a.setAttribute('title', document.title);
                    a.setAttribute('rel', 'sidebar');
                    a.click(); // this.title=document.title;
                } else {
                    // webkit - safari/chrome
                    var ctrlButton = navigator.userAgent.toLowerCase().indexOf('mac') === -1 ? 'CTRL' : 'Command/Cmd';
                    _this.showAlert('Press ' + ctrlButton + ' + D to bookmark this page.');
                }
            }
        }

        function share(event) {
            event.preventDefault();

            var width = 400;
            var height = 400;
            var left = Math.floor(($(window).width() - width) / 2);
            var top = Math.floor(($(window).height() - height) / 2);

            var roomUrl = window.JsConstants.room.url ? window.location.origin + '/room/url/' + window.JsConstants.room.url : window.location.href;
            var href = event.currentTarget.href || event.currentTarget.dataset.href;
            var url = href + encodeURIComponent(roomUrl);

            var popup = window.open(url, 'Social Share', 'width=' + width + ',height=' + height + ',left=' + left + ',top=' + top + ',location=0,menubar=0,toolbar=0,status=0,scrollbars=1,resizable=1');

            if (popup) popup.focus();
        }

        // this.addEventListener = function (elementId, event, func) {
        //     const element = document.getElementById(elementId);
        //     if (element) {
        //         element.addEventListener(event, func);
        //     }
        // };

        // @jscrambler define domainLock {domains:[app001.3droomvisualizer.com, floorsdirect.3droomvisualizer.com, tdcc2.3dtilevisualizer.com, simuladorfv.westus.cloudapp.azure.com, tilevisualiser.colortile.com.au, visualizer.cletile.com]} as dL
        // @jscrambler enable dL
        function init() {
            $('#topPanelHideBtn').click(_this.topPanelToggle);

            $('#topPanelGroutSizeRange').on('input', _this.changeGroutSizeText);
            $('#topPanelTilesSort').change(_this.changeTilesSort);
            $('#bottomMenuFullScreen').click(_this.changeFullScreenMode);

            $('.top-panel-button').click(_this.showAdditionalOptions);

            $('#bookmarkSavedRoomLink').click(bookmarkLink);

            if (_this.isMobileDevice()) $('.copyright').remove();

            $('.social-share > a').click(share);
            $('#bottomMenuMail').click(share);
        }

        init();
    }

    UI.roomCanvas = document.getElementById('roomCanvas'); // todo optimize

    UI.updateCanvasStyle = function (title) {
        if (title && typeof title === 'string') {
            UI.roomCanvas.title = 'Change ' + title;
            UI.roomCanvas.style.cursor = 'url("/img/icons/brush.png") 18 46, pointer';
        } else {
            UI.roomCanvas.title = '';
            UI.roomCanvas.style.cursor = 'unset';
        }
    };

    /**
     * Returns true if page opened on mobile device
     *
     * @method isMobileDevice
     * @returns {boolean}
     */
    UI.isMobileDevice = function () {
        if (navigator.userAgent.match(/Android/i) || navigator.userAgent.match(/webOS/i) || navigator.userAgent.match(/BlackBerry/i) || navigator.userAgent.match(/iPhone/i) || navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPod/i) || navigator.userAgent.match(/Opera Mini/i) || navigator.userAgent.match(/IEMobile/i) || navigator.userAgent.match(/Windows Phone/i)) {
            return true;
        }
        return false;
    };

    var LoadingAnimation = function () {
        function LoadingAnimation() {
            _classCallCheck(this, LoadingAnimation);

            this.loadingItems = 0;
            this.preLoader = false;
        }

        _createClass(LoadingAnimation, [{
            key: 'show',
            value: function show() {
                this.loadingItems += 1;
                if (!this.preLoader) {
                    this.preLoader = true;
                    document.getElementById('container').style.cursor = 'wait';
                    window.$('#loadAnimationContainer').show();
                }
            }
        }, {
            key: 'hide',
            value: function hide() {
                this.loadingItems -= 1;
                if (this.loadingItems <= 0 && this.preLoader) {
                    this.loadingItems = 0;
                    this.preLoader = false;
                    document.getElementById('container').style.cursor = 'unset';
                    window.$('#loadAnimationContainer').hide();
                }
            }
        }]);

        return LoadingAnimation;
    }();

    var loadingAnimation = new LoadingAnimation();

    var RoomLoadProgress = {
        itemsLoaded: 0,
        itemsTotal: 0,
        start: function start() {
            var progressBar = document.getElementById('sourceLoadProgressBar');
            progressBar.textContent = '10%';
            if (progressBar.classList.contains('progress-bar-striped')) {
                progressBar.style.width = '10%';
            }
            window.$('#sourceLoadProgressBarContainer').show();
        },
        progress: function progress(itemsLoaded, itemsTotal) {
            var progressBar = document.getElementById('sourceLoadProgressBar');
            var value = Math.floor(itemsLoaded / itemsTotal * 80 + 10) + '%';
            progressBar.textContent = value;
            if (progressBar.classList.contains('progress-bar-striped')) {
                progressBar.style.width = value;
            }
        },
        end: function end() {
            var progressBar = document.getElementById('sourceLoadProgressBar');
            progressBar.textContent = '90%';
            if (progressBar.classList.contains('progress-bar-striped')) {
                progressBar.style.width = '90%';
            }
            window.$('#sourceLoadProgressBarContainer').hide();
            // window.$('#sourceLoadProgressBarContainer').remove();
        }
    };

    function makeIcon(canvas, maxSize) {
        $('#dialogSaveModalBox').modal('hide');
        var width = 100;
        var height = 100;
        var ratio = 1;

        ratio = canvas.width / canvas.height;
        if (canvas.width > canvas.height) {
            width = maxSize;
            height = Math.floor(maxSize / ratio);
        } else {
            width = Math.floor(maxSize * ratio);
            height = maxSize;
        }

        var iconCanvas = document.createElement('canvas');
        iconCanvas.width = width;
        iconCanvas.height = height;

        var iconCanvasContext = iconCanvas.getContext('2d');
        iconCanvasContext.drawImage(canvas, 0, 0, width, height);

        return iconCanvas.toDataURL();
    }

    function canvasImage(canvas) {
        $('#dialogSaveModalBox').modal('hide');
        // render();

        var imageCanvas = document.createElement('canvas');
        imageCanvas.width = canvas.width;
        imageCanvas.height = canvas.height;

        var imageCanvasContext = imageCanvas.getContext('2d');
        imageCanvasContext.drawImage(canvas, 0, 0, canvas.width, canvas.height);

        var companyLogo = document.getElementById('companyLogo');
        imageCanvasContext.drawImage(companyLogo, 20, 20, companyLogo.clientWidth, companyLogo.clientHeight);

        if (imageCanvas.msToBlob) {
            // for IE
            var blob = imageCanvas.msToBlob();
            window.navigator.msSaveBlob(blob, document.title + '.png');
        } else {
            var imgDataUrl = imageCanvas.toDataURL('image/jpeg');
            var link = document.createElement('a');
            if (typeof link.download === 'string') {
                document.body.appendChild(link);
                link.href = imgDataUrl;
                link.download = document.title + '.jpg';
                link.click();
                document.body.removeChild(link);
            }
        }
    }

    function userRoom(room, roomSettings, engine, interiorUI) {
        $.ajax({
            method: 'POST',
            url: '/userRoom/save',
            dataType: 'json',
            data: {
                '_token': $('meta[name=csrf-token]').attr('content'),
                'roomId': room.id,
                'url': room.savedUrl,
                'engine': engine,
                'image': makeIcon(room.canvas, 256),
                'roomSettings': JSON.stringify(roomSettings)
            },
            success: function success(response) {
                if (response.state === 'success') {
                    $('#savedRoomGoToUrl').hide();
                    $('#savedRoomLogin').hide();

                    $('#dialogSavedRoomUrlInput').val(window.location.origin + response.fullUrl);

                    if (!response.loggedIn) {
                        $('#savedRoomLogin').show();
                    }
                    if (room.savedUrl !== response.url) {
                        room.savedUrl = response.url;
                        window.JsConstants.room.url = response.url;
                        interiorUI.showAlert('Room saved to another url.');
                        $('#savedRoomGoToUrl').attr('href', window.location.origin + response.fullUrl);
                        $('#savedRoomGoToUrl').show();
                    }
                    $('#dialogSavedRoomUrl').modal('show');
                } else {
                    interiorUI.showAlert('The problem in saving room.', 'error'); // response.state
                }
            },
            error: function error() {
                interiorUI.showAlert('The problem in saving room.', 'error');
            },
            complete: function complete() {
                RoomLoadProgress.end();
            }
        });
        RoomLoadProgress.start();
    }

    var Images = function () {
        function getWidth(image) {
            return image.naturalWidth || image.width || 0;
        }

        function getHeight(image) {
            return image.naturalHeight || image.height || 0;
        }

        function canvasToBinaryJpeg(canvas) {
            var data = canvas.toDataURL('image/jpeg').slice('data:image/jpeg;base64,'.length);
            return atob(data);
        }

        function resizeImageStep(image, width, height) {
            var canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            var ctx = canvas.getContext('2d');
            ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
            return canvas;
        }

        function steppedResize(image, width, height) {
            var naturalWidth = getWidth(image);
            var naturalHeight = getHeight(image);
            if (naturalWidth <= width * 2 || naturalHeight <= height * 2) {
                return resizeImageStep(image, width, height);
            }
            var imageSmaller = resizeImageStep(image, naturalWidth / 2, naturalHeight / 2);
            return steppedResize(imageSmaller, width, height);
        }


        function getSizeInDrawArea(originalWidth, originalHeight, maxWidth, maxHeight, align) {
            var size = {
                left: 0,
                top: 0,
                width: originalWidth,
                height: originalHeight,
            };

            if (originalWidth < maxWidth && originalHeight < maxHeight) {
                size.left = Math.floor((maxWidth - size.width) / 2);
                size.top = Math.floor((maxHeight - size.height) / 2);
            } else if (maxWidth && maxHeight) {
                var imageAspectRatio = originalWidth / originalHeight;
                if (maxWidth / maxHeight > imageAspectRatio) {
                    size.height = maxHeight;
                    size.width = maxHeight * imageAspectRatio;
                } else {
                    size.width = maxWidth;
                    size.height = maxWidth / imageAspectRatio;
                }

                if (size.width < maxWidth) size.left = Math.floor((maxWidth - size.width) / 2);
                if (size.height < maxHeight) size.top = Math.floor((maxHeight - size.height) / 2);
            }

            if (align === 'left') {
                size.left = 0;
            } else if (align === 'right') {
                size.left = maxWidth - size.width;
            }

            return size;
        }

        function resize(image, originalWidth, originalHeight, maxWidth, maxHeight, asCanvas, align) {
            var size = getSizeInDrawArea(originalWidth, originalHeight, maxWidth, maxHeight, align);

            var canvas = document.createElement('canvas');
            canvas.width = Math.floor(maxWidth);
            canvas.height = Math.floor(maxHeight);
            var ctx = canvas.getContext('2d');
            ctx.fillStyle = window.JsConstants.config.pdfBackgroundColor || 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(image, size.left, size.top, size.width, size.height);

            if (asCanvas) return canvas;
            return canvasToBinaryJpeg(canvas);
        }

        return {
            // canvasToBinaryJpeg: canvasToBinaryJpeg,
            steppedResize: steppedResize,

            /**
             * Rotates image only to 90, 180, 270 degree, default 90
             *
             * @param {HTMLImageElement|HTMLCanvasElement} image
             * @param {number} deg
             * @param {Object} options
             * @param {string} options.background Sets background color
             * @returns {HTMLCanvasElement}
             */
            rotate: function rotate(image, deg, options) {
                if (image) {
                    var canvas = document.createElement('canvas');
                    var ctx = canvas.getContext('2d');

                    var background = options && options.background;
                    var areaSize = Math.max(canvas.width, canvas.height) * 2;

                    if (background) {
                        ctx.fillStyle = options.background;
                    }

                    switch (deg) {
                        case 180:
                            canvas.width = getWidth(image);
                            canvas.height = getHeight(image);
                            if (background) ctx.fillRect(-areaSize, -areaSize, areaSize, areaSize);
                            ctx.rotate(Math.PI);
                            ctx.drawImage(image, -canvas.width, -canvas.height, canvas.width, canvas.height);
                            break;

                        case 270:
                            canvas.width = getHeight(image);
                            canvas.height = getWidth(image);
                            if (background) ctx.fillRect(-areaSize, -areaSize, areaSize, areaSize);
                            ctx.rotate(4.71238898038469); // Math.PI * 3 / 2
                            ctx.drawImage(image, -canvas.height, 0, canvas.height, canvas.width);
                            break;

                        default:
                            canvas.width = getHeight(image);
                            canvas.height = getWidth(image);
                            if (background) ctx.fillRect(-areaSize, -areaSize, areaSize, areaSize);
                            ctx.rotate(1.5707963267948966); // Math.PI / 2
                            ctx.drawImage(image, 0, -canvas.width, canvas.height, canvas.width);
                    }

                    ctx.setTransform(1, 0, 0, 1, 0, 0);

                    return canvas;
                }
            },

            adjustImage: function adjustImage(image, maxWidth, maxHeight) {
                return resize(image, getWidth(image), getHeight(image), maxWidth, maxHeight, true);
            },

            toCanvas: function toCanvas(image) {
                var canvas = document.createElement('canvas');
                canvas.width = getWidth(image);
                canvas.height = getHeight(image);
                var ctx = canvas.getContext('2d');
                ctx.fillStyle = window.JsConstants.config.pdfBackgroundColor || 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(image, 0, 0, canvas.width, canvas.height);

                return canvas;
            },

            getLogo: function (maxWidth, maxHeight, align) {
                var logo = document.getElementById('companyLogo');
                if (maxWidth || maxHeight) {
                    return resize(logo, getWidth(logo), getHeight(logo), maxWidth, maxHeight, true, align);
                }

                return this.toCanvas(logo);
            },

            toDataURL: function toDataURL(image) {
                var canvas = this.toCanvas(image);
                return canvas.toDataURL('image/png');
            },

            setBackground: function setBackground(image, htmlColor) {
                var canvas = document.createElement('canvas');
                var ctx = canvas.getContext('2d');
                canvas.width = getWidth(image);
                canvas.height = getHeight(image);

                ctx.fillStyle = htmlColor || window.JsConstants.config.pdfBackgroundColor || '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.drawImage(image, 0, 0, canvas.width, canvas.height);

                return canvas;
            },

            load: function load(url, onLoad, saveIndexes) {
                if (typeof onLoad !== 'function') return;

                if (url && typeof url === 'string') {
                    var image = new Image();
                    image.onload = function () {
                        onLoad(image);
                    };
                    image.src = url;
                } else if (Array.isArray(url) && url.length > 0) {
                    var images = [];
                    var loadingCount = 0;
                    if (saveIndexes === true) {
                        var loadedCount = 0;
                        url.forEach(function (url) {
                            var image = void 0;
                            if (url && typeof url === 'string') {
                                loadingCount += 1;
                                image = new Image();
                                image.onload = function () {
                                    loadedCount += 1;
                                    if (loadedCount === loadingCount) {
                                        onLoad(images);
                                    }
                                };
                                image.onerror = function () {
                                    loadedCount += 1;
                                    if (loadedCount === loadingCount) {
                                        onLoad(images);
                                    }
                                };
                                image.src = url;
                            }
                            images.push(image);
                        });
                    } else {
                        url.forEach(function (url) {
                            if (url && typeof url === 'string') {
                                loadingCount += 1;
                                var _image = new Image();
                                _image.onload = function () {
                                    images.push(_image);
                                    if (images.length === loadingCount) {
                                        onLoad(images);
                                    }
                                };
                                _image.src = url;
                            }
                        });
                    }
                } else {
                    onLoad();
                }
            },

            getFitSizes: function getFitSizes(image, maxWidth, maxHeight) {
                var increase = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

                var naturalWidth = getWidth(image);
                var naturalHeight = getHeight(image);
                var imageAspect = naturalWidth / naturalHeight;
                var maxAspect = maxWidth / maxHeight;

                if (!increase && naturalWidth < maxWidth && naturalHeight < maxHeight) {
                    return {
                        width: naturalWidth,
                        height: naturalHeight,
                        left: (maxWidth - naturalWidth) / 2,
                        top: (maxHeight - naturalHeight) / 2
                    };
                }

                if (imageAspect >= maxAspect) {
                    var height = naturalHeight * (maxWidth / naturalWidth);
                    return {
                        width: maxWidth,
                        height: height,
                        left: 0,
                        top: (maxHeight - height) / 2
                    };
                }

                var width = naturalWidth * (maxHeight / naturalHeight);
                return {
                    width: width,
                    height: maxHeight,
                    left: (maxWidth - width) / 2,
                    top: 0
                };
            }
        };
    }();

    var ImageDoc = function () {
        function ImageDoc() {
            var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 210;
            var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 297;
            var dpi = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 144;

            _classCallCheck(this, ImageDoc);

            this._dpi = dpi;
            this._dpmm = dpi / 25.4; // Dot per mm
            this._width = width;
            this._height = height;

            this._fontSize = 10 * 0.35 * this._dpmm;
            this._fontType = '';
            this._fontFamily = 'sans-serif';

            this.pages = [];
            this.addPage();

            this.internal = {
                getNumberOfPages: () => this.pages.length
            }
        }

        _createClass(ImageDoc, [{
            key: 'addImage',
            value: function addImage(image, type, left, top, width, height) {
                if (width && height) {
                    this._context.drawImage(image, left * this._dpmm, top * this._dpmm, width * this._dpmm, height * this._dpmm);
                } else {
                    this._context.drawImage(image, left * this._dpmm, top * this._dpmm, image.width * (this._dpi / 96), image.height * (this._dpi / 96));
                }

                return this;
            }
        }, {
            key: 'text',
            value: function text(_text, left, top) {
                var _this24 = this;

                var lines = String(_text).split('\n');
                lines.forEach(function (line, i) {
                    var lineTop = top * _this24._dpmm + _this24._fontSize * 1.16 * i;
                    _this24._context.fillText(line, left * _this24._dpmm, lineTop);
                });
                return this;
            }
        }, {
            key: 'addPage',
            value: function addPage() {
                this._page = document.createElement('canvas');
                this._page.width = this._width * this._dpmm;
                this._page.height = this._height * this._dpmm;

                this._context = this._page.getContext('2d');
                this._context.fillStyle = '#ffffff';
                this._context.fillRect(0, 0, this._page.width, this._page.height);
                this._context.fillStyle = '#000000';

                this._updateFont();

                this.pages.push(this._page);
                return this;
            }
        }, {
            key: 'line',
            value: function line(x0, y0, x1, y1) {
                this._context.beginPath();
                this._context.moveTo(x0 * this._dpmm, y0 * this._dpmm);
                this._context.lineTo(x1 * this._dpmm, y1 * this._dpmm);
                this._context.stroke();
            }
        }, {
            key: '_updateFont',
            value: function _updateFont() {
                this._context.font = this._fontType + ' ' + this._fontSize + 'px ' + this._fontFamily;
            }
        }, {
            key: 'setFont',
            value: function setFont(fontName) {
                // , fontStyle
                if (fontName && typeof fontName === 'string') {
                    this._fontFamily = fontName;
                    this._updateFont();
                }
                return this;
            }
        }, {
            key: 'setFontSize',
            value: function setFontSize(size) {
                var fontSize = Number(size);
                if (fontSize) {
                    this._fontSize = fontSize * 0.35 * this._dpmm;
                    this._updateFont();
                }
                return this;
            }
        }, {
            key: 'setPage',
            value: function setPage(pageNumber) {
                this._page = this.pages[pageNumber - 1];
                this._context = this._page.getContext('2d');
            }
        }, {
            key: 'setFontType',
            value: function setFontType() {
                var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

                type = type.toLowerCase();

                this._fontType = type.indexOf('bold') === -1 ? '' : 'bold ';

                if (type.indexOf('normal') !== -1) {
                    this._fontType += 'normal';
                } else if (type.indexOf('italic') !== -1) {
                    this._fontType += 'italic';
                } else if (type.indexOf('oblique') !== -1) {
                    this._fontType += 'oblique';
                }

                this._updateFont();
                return this;
            }
        }, {
            key: 'save',
            value: function save(fileName) {
                var totalPages = this.pages.length;
                this.pages.forEach(function (page, i) {
                    var pageNumber = totalPages > 1 ? ' (page ' + (i + 1) + ' of ' + totalPages + ')' : '';
                    var name = (fileName || document.title) + pageNumber;
                    if (page.msToBlob) {
                        // for IE
                        var blob = page.msToBlob();
                        window.navigator.msSaveBlob(blob, name + '.png');
                    } else {
                        var imgDataUrl = page.toDataURL('image/jpeg');
                        var link = document.createElement('a');
                        if (typeof link.download === 'string') {
                            document.body.appendChild(link);
                            link.href = imgDataUrl;
                            link.download = name + '.jpg';
                            link.click();
                            document.body.removeChild(link);
                        }
                    }
                });

                return this;
            }
        }]);

        return ImageDoc;
    }();

    /* global jsPDF */

    const DPI = 96; // or 3.78 dorts per mm
    var PAGE_WIDTH = 210; // A4 8.27  11.7 or 210  297 mm
    var PAGE_HEIGHT = 297; // mm
    var MARGIN_TOP = 16; // mm
    var MARGIN_BOTTOM = MARGIN_TOP;
    var MARGIN_LEFT = 14; // mm
    var MARGIN_RIGHT = MARGIN_LEFT;
    var LINE_HEIGHT = 5; // mm
    var FONT_SIZE_TEXT = 9;
    var FONT_SIZE_CAPTION = 14;

    function setBackground(doc) {
        if (window.JsConstants.config.pdfBackgroundColor) {
            var color = new THREE.Color(window.JsConstants.config.pdfBackgroundColor)
            doc.setFillColor(color.r * 255, color.g * 255, color.b * 255);
            doc.rect(0, 0, 210, 297, 'F')
        }
    }

    /**
     * Adds new page to pdf document if blockHeight not fits to page
     *
     * @param {jsPDF|ImageData} doc
     * @param {number} currentLine
     * @param {number} blockHeight
     * @returns {boolean} True if new page added
     */
    function addNewPage(doc, currentLine, blockHeight) {
        if (currentLine + blockHeight > PAGE_HEIGHT - MARGIN_BOTTOM) {
            doc.addPage();
            setBackground(doc)
            return true;
        }
        return false;
    }

    function getTileExtraOptionsText(tile) {
        var text = '';
        var options = window.JsConstants.config.tileExtraOptions;
        if (Array.isArray(options) && tile && tile.expProps) {
            var expProps = JSON.parse(tile.expProps)
            options.forEach(function (option) {
                if (option && expProps.hasOwnProperty(option) && expProps[option]) {
                    var optionText = Locale.lang(option, expProps[option]);
                    text += optionText + '\n';
                }
            });
        }
        return text;
    }

    function productInfoAssText(tile, surfaceName, surfaceIndex) {
        var config = window.JsConstants.config.ProductInfo;

        var size = config.size ? Locale.lang('Size') + ': ' + tile.width + 'mm x ' + tile.height + 'mm\n' : '';

        var finish = config.finish && tile.finish ? Locale.lang('Finish') + ': ' + Locale.lang(tile.finish) + '\n' : '';

        var price = config.price && tile.price ? Locale.lang('Price') + ': ' + tile.price + '\n' : '';

        var url = config.url && tile.url ? Locale.lang('Product page') + ': ' + tile.url + '\n' : '';

        var shape = config.shape ? Locale.lang('Shape') + ': ' + Locale.lang(tile.shape) + ' \n' : '';

        var rotoPrintSet = config.rotoPrintSet && tile.rotoPrintSetName ? Locale.lang('Roto Print Set') + ': ' + Locale.lang(tile.rotoPrintSetName) + ' \n' : '';

        var extraOptions = getTileExtraOptionsText(tile);

        var usedColors = config.colors && tile.usedColors ? Locale.COLORS_USED + ': ' + tile.usedColors + '\n' : '';
        if (usedColors.length > 55) {
            var colors = usedColors.split(' / ');
            colors[3] = '\n' + colors[3];
            usedColors = colors.join(' / ');
        }

        return {
            surfaceName: Locale.lang(surfaceName),
            surfaceIndex: surfaceIndex,
            tile: tile,
            // file: tile.file,
            // name: tile.name,
            // shape: tile.shape,
            text: size + shape + finish + price + url + extraOptions + usedColors + rotoPrintSet
        };
    }

    function addProductInfo(room, tiles) {
        var productInfoTilesList = [];

        room.tiledSurfaces.forEach(function (surface, index) {
            var tileApplied = typeof surface.tileIndex !== 'undefined' || typeof surface.tile2Index !== 'undefined' || surface.freeDesignTiles && surface.freeDesignTiles.length > 0;

            if (tileApplied) {
                var usedTileIds = [];

                if (!surface.name) {
                    if (room.surfaceTypes && surface.type) {
                        surface.name = room.surfaceTypes[surface.type];
                    } else if (surface.type) {
                        surface.name = surface.type;
                    } else {
                        surface.name = 'Surface ' + (1 + index);
                    }
                }

                if (surface.tileIndex !== undefined) {
                    productInfoTilesList.push(productInfoAssText(tiles[surface.tileIndex], surface.name, index));
                    usedTileIds.push({
                        id: tiles[surface.tileIndex].id,
                        custom: tiles[surface.tileIndex].custom
                    });
                }

                if (surface.tile2Index !== undefined && surface.tile2Index !== surface.tileIndex) {
                    productInfoTilesList.push(productInfoAssText(tiles[surface.tile2Index], surface.name, index));
                    usedTileIds.push({
                        id: tiles[surface.tile2Index].id,
                        custom: tiles[surface.tile2Index].custom
                    });
                }

                if (surface.freeDesignTiles) {
                    surface.freeDesignTiles.forEach(function (freeDesignTile) {
                        var tileUsed = usedTileIds.some(function (usedTile) {
                            return freeDesignTile._tile.id === usedTile.id && freeDesignTile._tile.custom === usedTile.custom;
                        });
                        if (!tileUsed) {
                            var tile = tiles.getById(freeDesignTile._tile.id, freeDesignTile._tile.custom);
                            productInfoTilesList.push(productInfoAssText(tile, surface.name, index));
                            usedTileIds.push({
                                id: freeDesignTile._tile.id,
                                custom: freeDesignTile._tile.custom
                            });
                        }
                    });
                }
            }
        });
        return productInfoTilesList;
    }

    function milimetersToPoints(milimeters, dpi = DPI) {
        return milimeters / 25.4 * (typeof dpi === 'undefined' ? DPI : dpi);
    }

    function addFooter(doc) {
        var numberOfPages =  doc.internal.getNumberOfPages();
        for (var i = 1; i <= numberOfPages; i++) {
            doc.setPage(i);

            doc.setFontSize(8).setFontType('normal');
            doc.text('DATE: ' + new Date().toLocaleDateString(), MARGIN_LEFT, PAGE_HEIGHT - MARGIN_BOTTOM + LINE_HEIGHT + 2);

            var disclaimer = window.JsConstants.config.pdfDisclaimer || 1
            if (disclaimer === 1) {
                doc.setFontSize(7).setFontType('normal');
                doc.text('Disclaimer: Please note the tiles are random and may not represent exactly as shown in the photo', MARGIN_LEFT, PAGE_HEIGHT - MARGIN_BOTTOM + LINE_HEIGHT * 2);
            }
            if (disclaimer === 2) {
                doc.setFontSize(6.5).setFontType('bold');
                doc.text('Note:', MARGIN_LEFT, PAGE_HEIGHT - MARGIN_BOTTOM + LINE_HEIGHT * 2);
                doc.setFontSize(6.5).setFontType('normal');
                doc.text('Tile patterns are random and may not represent exactly as shown in the photo. For illustrative purposes, only 8 digital faces have been used for each tile size.', MARGIN_LEFT + 7, PAGE_HEIGHT - MARGIN_BOTTOM + LINE_HEIGHT * 2);
            }

            doc.setFontSize(7).setFontType('normal');
            doc.text(String(i) + ' of ' + String(numberOfPages), PAGE_WIDTH - MARGIN_LEFT - 7, PAGE_HEIGHT - MARGIN_BOTTOM + LINE_HEIGHT + 2);
        }
    }

    // function addWatermark(canvas) {
    //     var logo = document.getElementById('companyLogo');
    //     if (!logo) return canvas;
    //     console.log({canvas});

    //     var width = logo.naturalWidth || logo.width;
    //     var height = logo.naturalHeight || logo.height;

    //     var widthScale = canvas.width / 3 / width;
    //     var heightScale = canvas.height / 3 / height;

    //     var scale = Math.min(widthScale, heightScale);

    //     var ctx = canvas.getContext('2d');
    //     ctx.globalAlpha = window.JsConstants.config.watermarkedAlpha || 0.15;
    //     ctx.drawImage(logo, (canvas.width - width * scale) / 2, (canvas.height - height * scale) / 2, width * scale, height * scale);

    //     return canvas;
    // }

    /**
     * Create PDF using jsPDF require jsPDF.min.js
     * Or crete Image using ImageDoc
     *
     * Page size in pixels for drawing images:
     * A4: [595.28, 841.89]
     * LETTER: [612.00, 792.00],
     *
     * @param {Object} room
     * @param {Array} tiles
     * @param {String} docType set 'image' to create ImageDoc
     * @param {Boolean} pdfAsImage set true to save ImageDoc to PDF
     */
    function saveDoc(room, tiles, docType, pdfAsImage) {
        var tilesInfo = addProductInfo(room, tiles);
        var urls = tilesInfo.map(function (tileInfo) {
            return tileInfo.tile.file;
        });

        Images.load(urls, function (tileImages) {
            $('#dialogSaveModalBox').modal('hide');

            var currentLine = MARGIN_TOP;

            var doc = docType === 'image' ? new ImageDoc(210, 297, 300) : new jsPDF(); // eslint-disable-line new-cap
            setBackground(doc)

            var headerWidth = 0;

            if (window.JsConstants.config.pdfHeaderText) {
                headerWidth = window.JsConstants.config.pdfHeaderTextWidth;

                var lines = window.JsConstants.config.pdfHeaderText.split(',');

                doc.setFontSize(FONT_SIZE_CAPTION);

                currentLine -= 3;
                lines.forEach(function (line) {
                    doc.text(line, PAGE_WIDTH - MARGIN_RIGHT - headerWidth, currentLine += LINE_HEIGHT + 2);
                });

                currentLine += LINE_HEIGHT;
            }

            var logoMaxWidth = window.JsConstants.config.pdfHeaderText
                ? PAGE_WIDTH - MARGIN_LEFT - MARGIN_RIGHT - 5 - headerWidth
                : PAGE_WIDTH - MARGIN_LEFT - MARGIN_RIGHT;
            var logoWidth = milimetersToPoints(Math.min(logoMaxWidth, window.JsConstants.config.pdfLogoMaxWidth));

            var logo = Images.getLogo(logoWidth, 96, window.JsConstants.config.pdfLogoAlign);
            doc.addImage(logo, 'JPEG', MARGIN_LEFT, MARGIN_TOP);

            if (currentLine < MARGIN_TOP + 35) {
                currentLine = MARGIN_TOP + 35;
            }

            // var logo = Images.getLogo(793, 96);
            // doc.addImage(logo, 'JPEG', 0, MARGIN_TOP);
            // currentLine += 30;

            var sizes = Images.getFitSizes(room.canvas, PAGE_WIDTH - (MARGIN_LEFT + MARGIN_RIGHT), PAGE_HEIGHT - currentLine - MARGIN_BOTTOM)
            doc.addImage(room.canvas, 'JPEG', MARGIN_LEFT + sizes.left, currentLine, sizes.width, sizes.height);
            currentLine += sizes.height + LINE_HEIGHT;

            // var ratio = room.canvas.width / room.canvas.height;
            // var imageWidth = PAGE_WIDTH - (MARGIN_LEFT + MARGIN_RIGHT);
            // var imageHeight = imageWidth / ratio;

            // var watermarkedImage = addWatermark(room.canvas, logo);
            // doc.addImage(watermarkedImage, 'JPEG', MARGIN_LEFT, currentLine, imageWidth, imageHeight);
            // doc.addImage(room.canvas, 'JPEG', MARGIN_LEFT, currentLine, imageWidth, imageHeight);
            // currentLine += imageHeight + LINE_HEIGHT;

            var lastSurfaceIndex = void 0;
            var tileImageMaxWidth = 25;
            var tileImageMaxHeight = tileImageMaxWidth;

            tilesInfo.forEach(function (tileInfo, i) {
                var newPage = addNewPage(doc, currentLine, tileImageMaxHeight + LINE_HEIGHT * 2);
                if (newPage) {
                    currentLine = MARGIN_TOP;
                }

                if (lastSurfaceIndex !== tileInfo.surfaceIndex) {
                    lastSurfaceIndex = tileInfo.surfaceIndex;
                    doc.setFontSize(FONT_SIZE_CAPTION).setFontType('normal');
                    doc.text(tileInfo.surfaceName, MARGIN_LEFT, currentLine += LINE_HEIGHT);

                    doc.line(MARGIN_LEFT, currentLine += 2, PAGE_WIDTH - MARGIN_RIGHT, currentLine); // horizontal line
                }

                var tileImage = Images.adjustImage(tileImages[i], 256, 256);
                doc.addImage(tileImage, 'JPEG', MARGIN_LEFT, currentLine += 2, tileImageMaxWidth, tileImageMaxHeight);

                doc.setFontSize(FONT_SIZE_CAPTION).setFontType('bold');
                doc.text(tileInfo.tile.name, MARGIN_LEFT + tileImageMaxHeight + 6, currentLine + LINE_HEIGHT);

                doc.setFontSize(FONT_SIZE_TEXT).setFontType('normal');
                doc.text(tileInfo.text, MARGIN_LEFT + tileImageMaxHeight + 6, currentLine + LINE_HEIGHT * 2);

                currentLine += tileImageMaxHeight + LINE_HEIGHT;
            });

            addFooter(doc)

            if (pdfAsImage) {
                var pdf = new jsPDF(); // eslint-disable-line new-cap
                doc.pages.forEach(function (page, i) {
                    if (i > 0) pdf.addPage();
                    pdf.addImage(page, 'JPEG', 0, 0, 210, 297);
                });
                pdf.save(Locale.PDF_VISUALIZER_FILE + '.pdf');
            } else {
                var fileExtension = docType === 'image' ? '' : '.pdf';
                doc.save(Locale.PDF_VISUALIZER_FILE + fileExtension);
            }
        }, true);
    }

    /**
     * Create PDF using pdfmake (http://pdfmake.org)
     * require pdfmake.min.js and vfs_fonts.js
     *
     * Page size in pixels for drawing images:
     * A4: [595.28, 841.89]
     * LETTER: [612.00, 792.00],
     *
     * @param {Object} room
     * @param {Array} tiles
     */
    function docVisualizer(room, tiles) {
        window.$('#dialogSaveModalBox').modal('hide');
        loadingAnimation.show();

        var tilesInfo = addProductInfo(room, tiles);
        var urls = tilesInfo.map(function (tileInfo) {
            return tileInfo.tile.file;
        });

        Images.load(urls, function (tileImages) {
            var doc = {
                content: [{
                    image: Images.getLogo().toDataURL('image/png'),
                    fit: [300, 72],
                    alignment: 'center'
                    // alignment: 'justify',
                }, {
                    image: room.canvas.toDataURL('image/png'),
                    fit: [512, 320],
                    alignment: 'center',
                    margin: [0, 10, 0, 10]
                }]
            };

            var point = document.createElement('canvas');
            point.width = 1;
            point.height = 1;
            var ctx = point.getContext('2d');
            ctx.fillStyle = '#888888';
            ctx.fillRect(0, 0, 1, 1);

            var lastSurfaceIndex = void 0;
            tilesInfo.forEach(function (tile, i) {
                if (lastSurfaceIndex !== tile.surfaceIndex) {
                    lastSurfaceIndex = tile.surfaceIndex;
                    doc.content.push([{
                        text: tile.surfaceName,
                        margin: [5, 5, 5, 0]
                    }, {
                        image: point.toDataURL('image/png'),
                        width: 512,
                        height: 1
                    }]);
                }

                doc.content.push({
                    columns: [{
                        width: 100,
                        image: Images.adjustImage(tileImages[i], 256, 256).toDataURL('image/png'),
                        fit: [84, 84],
                        margin: [0, 5]
                    }, [{
                        text: tile.tile.name,
                        bold: true,
                        margin: [0, 5, 0, 3]
                    }, {
                        text: tile.text,
                        fontSize: 10,
                        margin: [0, 0, 0, 5]
                    }]]
                });
            });

            window.pdfMake.createPdf(doc).download(Locale.PDF_VISUALIZER_FILE, function () {
                loadingAnimation.hide();
            });
        }, true);
    }

    function saveRoomPdf(room, tiles) {
        if (window.JsConstants.config.pdfLib === 'pdfMake') {
            docVisualizer(room, tiles); // using pdfMake lib
        } else {
            saveDoc(room, tiles); // using jsPDF lib
        }
    }

    function imageAsDoc(room, tiles) {
        saveDoc(room, tiles, 'image');
    }

    /**
     * Class for prepare and work with ColorPicker
     *
     * see
     * https://tovic.github.io/color-picker
     */

    /* global CP */

    var ColorPicker = function () {
        function ColorPicker(elementId, onUpdate) {
            var _this25 = this;

            _classCallCheck(this, ColorPicker);

            if (!elementId && typeof elementId !== 'string') return;
            if (typeof onUpdate !== 'function') return;

            this._target = document.getElementById(elementId);
            if (!this._target) return;

            this._picker = new CP(this._target);

            /**
             * default color Red
             * to set default color use data-color="#ffffff"
             * or uncomment this line
             */
            // this.set('#ffffff');

            this._picker.on('exit', function () {
                return _this25._onPickEnd(onUpdate);
            });
            this._picker.on('stop', function () {
                return _this25._onPickEnd(onUpdate);
            });

            this._picker.on('change', function (color) {
                return _this25._updateTarget(color);
            });
        }

        _createClass(ColorPicker, [{
            key: 'set',
            value: function set(color) {
                if (this._picker) {
                    this._picker.set(color);
                    this._updateTarget(color);
                }
            }
        }, {
            key: '_onPickEnd',
            value: function _onPickEnd(onUpdate) {
                var color = '#' + CP._HSV2HEX(this._picker.get());
                if (this._currentColor !== color) {
                    this._currentColor = color;
                    onUpdate(color);
                }
            }
        }, {
            key: '_updateTarget',
            value: function _updateTarget() {
                var color = '#' + CP._HSV2HEX(this._picker.get());
                this._target.setAttribute('data-color', color);
                this._target.value = color;
                this._target.style.background = color;
            }
        }]);

        return ColorPicker;
    }();

    /** @abstract */

    var Room = function () {
        // @jscrambler define domainLock {domains:[app001.3droomvisualizer.com, floorsdirect.3droomvisualizer.com, tdcc2.3dtilevisualizer.com, simuladorfv.westus.cloudapp.azure.com, tilevisualiser.colortile.com.au, visualizer.cletile.com]} as dL
        // @jscrambler enable dL

        function Room(data) {
            _classCallCheck(this, Room);

            Object.assign(this, data.roomData);
            this.savedUrl = data.url; // todo optimize

            this._ui = new UI(this);

            this._createView(data);

            // savedRoomSettings = data.roomSettings;

            // console.log(data);

            this._fillTiles(data);

            // engine2d.loadImages(this, onRoomImagesLoaded, RoomLoadProgress.progress);

            // Backlight(this.canvas, this.tiledSurfaces, engine2d);

            // initRoom();
            this._initElements();

            // this._restoreSavedRoomSettings();
        }

        /** @abstract */

        _createClass(Room, [{
            key: '_createView',
            value: function _createView() {} /** Needs override */

            /** @abstract */
        }, {
            key: '_save',
            value: function _save() {/** Needs override */}
        }, {
            key: '_isSurfaceSelected',
            value: function _isSurfaceSelected() {
                if (this.currentTiledSurface) return true;

                this._ui.showAlert('Surface not selected. To select surface click on wall or floor.', 'warning');
                return false;
            }
        }, {
            key: '_setSurfaceColor',
            value: function _setSurfaceColor(color) {
                if (!this._isSurfaceSelected()) return;

                console.warn('Surface invisible, because material option colorWrite is false!')
                this.currentTiledSurface.setColor(color);
            }
        }, {
            key: '_setGroutSize',
            value: function _setGroutSize(event) {
                if (!this._isSurfaceSelected()) return;

                var value = event && event.currentTarget && event.currentTarget.value;
                this.currentTiledSurface.setGroutSize(value);
                this._ui.changeGroutSize(this.currentTiledSurface.groutSize);
            }
        }, {
            key: '_setGroutColor',
            value: function _setGroutColor(color) {
                if (!this._isSurfaceSelected()) return;

                this.currentTiledSurface.setGroutColor(color);
            }
        }, {
            key: '_setGroutColorPredefined',
            value: function _setGroutColorPredefined(event) {
                if (!this._isSurfaceSelected()) return;

                var color = event && event.currentTarget && event.currentTarget.dataset && event.currentTarget.dataset.color;
                if (color) this.currentTiledSurface.setGroutColor(color);
                this._groutColorPicker.set(color);
            }
        }, {
            key: '_setCheckFreeDesign',
            value: function _setCheckFreeDesign(event) {
                if (!this._isSurfaceSelected()) return;

                var checked = event && event.currentTarget && event.currentTarget.checked;
                this.currentTiledSurface.setFreeDesign(checked);
            }
        }, {
            key: '_setPattern',
            value: function _setPattern(event) {
                if (!this._isSurfaceSelected()) return;

                var value = event && event.currentTarget && event.currentTarget.value;
                this.currentTiledSurface.setFillType(value);
                this._ui.updateSkewSizeButtons(this.currentTiledSurface.fillTypeIndex);
                TilesList.showHideLayerButtons(this.currentTiledSurface, this.currentTiledSurface.fillTypeIndex);
            }
        }, {
            key: '_setSkewSize',
            value: function _setSkewSize(event) {
                if (!this._isSurfaceSelected()) return;

                var value = event && event.currentTarget && event.currentTarget.value;
                this.currentTiledSurface.setSkewSize(value);
            }
        }, {
            key: '_setPatternRotation',
            value: function _setPatternRotation(event) {
                if (!this._isSurfaceSelected()) return;

                var value = event && event.currentTarget && event.currentTarget.value;
                this.currentTiledSurface.rotate(value);
            }
        }, {
            key: '_find',
            value: function _find(event) {
                var value = event && event.currentTarget && event.currentTarget.value;
                this._filters.find(value);
            }
        }, {
            key: '_showRoomInfo',
            value: function _showRoomInfo() {
                this._ui.addProductInfo(this, TilesList);
                this._ui.switchTopPanel('productInfoPanel');
            }

            /**
             * @param {number} tileIndex
             * @param {boolean} secondLayer
             */

        }, {
            key: '_onTileClick',
            value: function _onTileClick(tileIndex, secondLayer) {
                if (!this._isSurfaceSelected()) return;

                var surfaceGroup = {}
                this.currentTiledSurface.visibleMesh.parent.traverse(o => {
                    if(o.surface && o.geometry.name === this.currentTiledSurface.visibleMesh.geometry.name) {
                        surfaceGroup[o.surface.i] = o.surface;
                    }
                });

                for(var i in surfaceGroup) { // surface group loop

                var surface = surfaceGroup[i];
                var tile = TilesList[tileIndex];

                if (surface.freeDesign) {
                    surface.setFreeDesignTile(tile);
                } else if (secondLayer) {
                    surface.setTile2(tile);
                } else {
                    if (surface.tile2) {
                        if (!TilesList.isSame(tile, surface.tile2)) {
                            surface.clearTile2();
                        }
                    }

                    surface.setTile(tile);

                    TilesList.enabledPatternButtons(surface);
                    TilesList.updateLayerButtons(tileIndex);

                    this._ui.changeGroutSize(surface.groutSize);
                }

                } // end of surface group loop

                this._ui.topPanelHide();
            }
        }, {
            key: '_onSurfaceClick',
            value: function _onSurfaceClick(surface) {
                if (document.getElementById('topPanel').style.display !== 'flex') {
                    this._ui.switchTopPanel('topPanel', 'flex');
                }

                var rotate = document.getElementById('topPanelCheckFreeDesignRotate').checked;
                if (rotate && (surface.tile || surface.tile2) || surface.freeDesign && surface.freeDesignTile) {
                    this._ui.topPanelHide();
                } else {
                    this._ui.topPanelShow();
                }

                if (surface !== this.currentTiledSurface) {
                    this.currentTiledSurface = surface;

                    if (this._filters) this._filters.show();

                    TilesList.enabledPatternButtons(surface);
                    TilesList.showHideLayerButtons(surface, surface.fillTypeIndex);

                    this._ui.updateValues(surface);
                    this._groutColorPicker.set(surface.groutColor);
                    this._surfaceColorPicker.set(surface.color);
                }
            }
        }, {
            key: '_fillTiles',
            value: function _fillTiles(data) {
                var _this26 = this;

                var onClick = function onClick(tileIndex, secondLayer) {
                    return _this26._onTileClick(tileIndex, secondLayer);
                };
                TilesList.fill(onClick, data);

                this._ui.tiles = TilesList;
                var sortOrder = $('topPanelTilesSort').val();
                this._ui.addTilesToList(sortOrder);

                this._filters = new Filters(TilesList, this, this._ui.hideTilesPreloader);
                this._ui.filtersShow = function () {
                    return _this26._filters.show();
                };
            }

            // @jscrambler define domainLock {domains:[app001.3droomvisualizer.com, floorsdirect.3droomvisualizer.com, tdcc2.3dtilevisualizer.com, simuladorfv.westus.cloudapp.azure.com, tilevisualiser.colortile.com.au, visualizer.cletile.com]} as dL
            // @jscrambler enable dL

        }, {
            key: '_initElements',
            value: function _initElements() {
                var _this27 = this;

                $('#inputSearch').on('input', function (event) {
                    return _this27._find(event);
                });

                $('#topPanelGroutSizeRange').change(function (event) {
                    return _this27._setGroutSize(event);
                });

                this._groutColorPicker = new ColorPicker('grout-color-picker', function (color) {
                    return _this27._setGroutColor(color);
                });
                $('#grout-predefined-color > .-btn').click(function (event) {
                    return _this27._setGroutColorPredefined(event);
                });

                this._surfaceColorPicker = new ColorPicker('surface-color-picker', function (color) {
                    return _this27._setSurfaceColor(color);
                });

                $('#topPanelCheckFreeDesign').change(function (event) {
                    return _this27._setCheckFreeDesign(event);
                });

                $('.radio-surface-pattern > input').change(function (event) {
                    return _this27._setPattern(event);
                });
                $('.radio-skew-size input').change(function (event) {
                    return _this27._setSkewSize(event);
                });

                $('.radio-surface-rotation > input').click(function (event) {
                    return _this27._setPatternRotation(event);
                });

                $('#bottomMenuRoomInfo').click(function () {
                    return _this27._showRoomInfo();
                });

                if (window.JsConstants.config.saveImageAsDoc) {
                    $('#btnDialogSaveImage').click(function () {
                        return imageAsDoc(_this27, TilesList);
                    });
                } else {
                    $('#btnDialogSaveImage').click(function () {
                        return canvasImage(_this27.canvas);
                    });
                }
                $('#btnDialogSavePdf').click(function () {
                    return saveRoomPdf(_this27, TilesList);
                });
                $('#btnDialogSaveScene').click(function () {
                    return _this27._save();
                });
            }
        }]);

        return Room;
    }();

    /* global THREE */

    var View = function () {
        function View(containerId) {
            var _this28 = this;

            _classCallCheck(this, View);

            this._animationEnabled = false;

            this._renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            this._renderer.setPixelRatio(window.devicePixelRatio);
            this._renderer.setSize(window.innerWidth, window.innerHeight);
            this._renderer.setClearColor(0xffffff);

            var container = document.getElementById(containerId);
            container.appendChild(this._renderer.domElement);

            this.canvas = this._renderer.domElement;
            // this.canvas.addEventListener('click', sceneMouseClick);
            // this.canvas.addEventListener('touchstart', sceneMouseClick);

            this._scene = new THREE.Scene();
            this._camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);

            window.addEventListener('resize', function () {
                return _this28._onWindowResize();
            }, false);

            this._rayCaster = new THREE.Raycaster();

            // this._scene.add(createPanorama(room));
            // addTiledSurfaces();
        }

        _createClass(View, [{
            key: '_onWindowResize',
            value: function _onWindowResize() {
                this._camera.aspect = window.innerWidth / window.innerHeight;
                this._camera.updateProjectionMatrix();
                this._renderer.setSize(window.innerWidth, window.innerHeight);
                this.render();
            }
        }, {
            key: '_render',
            value: function _render() {
                // console.log('_render');
                this._renderer.render(this._scene, this._camera);
            }

            // _animate() {
            //     if (this._animationEnabled) {
            //         requestAnimationFrame(() => this._animate());
            //         this._render();
            //     }
            // }

        }, {
            key: 'render',
            value: function render() {
                if (this._animationEnabled) return;
                this._render();
                // console.log('render');
            }
        }, {
            key: 'startAnimation',
            value: function startAnimation() {
                var _this29 = this;

                this._animationEnabled = true;
                this._renderer.setAnimationLoop(function () {
                    return _this29._render();
                });
            }
        }, {
            key: 'stopAnimation',
            value: function stopAnimation() {
                this._animationEnabled = false;
                this._renderer.setAnimationLoop(null);
            }

            // _renderIfNeeds() {
            //     setInterval(() => {
            //         if (this.needsUpdate && !this._animationEnabled) {
            //             this.needsUpdate = false;
            //             this.render();
            //         }
            //     }, 1000);
            // }

            /**
             * @param {MouseEvent} mouseEvent
             * @param {Array} objects - Array of objects (default this._scene.children)
             * @param {Boolean} recursive  If true, it also checks all descendants
             * @returns {Object[]} - Intersect Objects
             */

        }, {
            key: 'getIntersects',
            value: function getIntersects(mouseEvent, objects) {
                var recursive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

                var normalizedPoint = {
                    x: mouseEvent.offsetX / this.canvas.scrollWidth * 2 - 1,
                    y: -mouseEvent.offsetY / this.canvas.scrollHeight * 2 + 1
                };

                this._rayCaster.setFromCamera(normalizedPoint, this._camera);
                return this._rayCaster.intersectObjects(objects || this._scene.children, recursive);
            }

            /**
             * Check if any object in objects array intersects with current rayCaster
             * @param {Array} objects
             * @returns {Boolean} - Intersect Objects
             */

        }, {
            key: 'isIntersect',
            value: function isIntersect(objects) {
                if (!Array.isArray(objects) || objects.length === 0) return false;

                this._render(); // todo optimize

                var intersects = this._rayCaster.intersectObjects(objects);
                return intersects.length > 0;
            }
        }]);

        return View;
    }();

    /* global THREE */

    var SIDES_POSITIONS = [{ x: 1, y: 0, z: 0, rotationZ: Math.PI }, { x: -1, y: 0, z: 0, rotationZ: Math.PI }, { x: 0, y: 1, z: 0, rotationZ: 0 }, { x: 0, y: -1, z: 0, rotationZ: 0 }, { x: 0, y: 0, z: 1, rotationZ: Math.PI }, { x: 0, y: 0, z: -1, rotationZ: Math.PI }];

    var vertexShader = '\n    varying vec2 vUv;\n    void main() {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n';

    var fragmentShader = `#include <packing>
    varying vec2 vUv;
    uniform sampler2D tImage;
    uniform sampler2D tMask;
    uniform bool useMattShadow;
    uniform sampler2D tMattShadow;
    uniform bool useGlossyShadow;
    uniform sampler2D tGlossyShadow;

    // vec4 getShadow(sampler2D shadow, vec2 vUv) {
    //     vec3 color = texture2D(shadow, vUv).rgb;

    //     float minColor = min(color.r, min(color.g, color.b));
    //     return vec4(color, 1.0) - minColor;
    // }

    // void main() {
    //     vec4 image = texture2D(tImage, vUv);
    //     gl_FragColor = image;

    //     vec3 mask = texture2D(tMask, vUv).rgb;

    //     //float a2 = texture2D(tImage, vUv + vec2(1.0/400.0, 0.0), 1.0).a;
    //     //float a3 = texture2D(tImage, vUv + vec2(0.0, 1.0/400.0), 1.0).a;
    //     //float a = (2.0 * image.a + a2 + a3) / 4.0;
    //     float a = image.a;
    //     if (a < 1.0) {
    //         vec4 s = mix(
    //             getShadow(tGlossyShadow, vUv),
    //             getShadow(tMattShadow, vUv),
    //             smoothstep(0.48, 0.52,
    //                 max( mask.r, max( mask.g, mask.b ) )
    //             )
    //         );
    //         gl_FragColor = mix(s, vec4(image.rgb / pow(a, 0.8), 1.0), a * a);
    //     }
    // }

    vec4 shadow(vec4 color) {
        float minColor = min(color.r, min(color.g, color.b));
        return vec4(color.rgb, 1.0) - minColor;
    }

    vec4 gloss(vec4 color) {
        // float l = color.r * color.g * color.b;
        float l = max(color.r, max(color.g, color.b));
        return vec4(color.rgb, pow(l, 20.0) * 0.8);
    }

    vec4 mixColors(vec4 c0, vec4 c1) {
        float alpha = (1.0 - c0.a) * c1.a + c0.a;
        vec3 color = ((1.0 - c0.a) * c1.a * c1.rgb + c0.a * c0.rgb) / alpha;

        return vec4(color, alpha);
    }

    vec4 getColor(sampler2D tShadow, vec2 vUv) {
        vec4 texture = texture2D(tShadow, vUv);
        return mixColors(gloss(texture), shadow(texture));
    }

    vec4 addImage(vec4 c0, vec4 image) {
        return mix(c0, vec4(image.rgb / pow(image.a, 0.8), 1.0), image.a * image.a);
    }

    void main() {
        vec4 image = texture2D(tImage, vUv);
        vec4 mask = texture2D(tMask, vUv);

        if (image.a == 1.0) {
            gl_FragColor = image;
            return;
        }

        vec4 color;
        if (mask.r < 0.5 && mask.g < 0.5 && mask.b < 0.5) {
            color = getColor(tGlossyShadow, vUv);
        } else {
            color = getColor(tMattShadow, vUv);
        }

        if (image.a > 0.0) {
            gl_FragColor = addImage(color, image);
        } else {
            gl_FragColor = color;
        }
    }
    `;







    /**
     * Camera for rendering cube maps
     *	- renders scene into axis-aligned cube
     *
     * @author alteredq / http://alteredqualia.com/
     * https://github.com/mrdoob/three.js/blob/r95/src/cameras/CubeCamera.js
     */

    function CubeCamera( near, far ) {

        THREE.Object3D.call( this );

        this.type = 'CubeCamera';

        var fov = 90, aspect = 1;

        var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
        cameraPX.up.set( 0, - 1, 0 );
        cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
        this.add( cameraPX );

        var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
        cameraNX.up.set( 0, - 1, 0 );
        cameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );
        this.add( cameraNX );

        var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
        cameraPY.up.set( 0, 0, 1 );
        cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
        this.add( cameraPY );

        var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
        cameraNY.up.set( 0, 0, - 1 );
        cameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );
        this.add( cameraNY );

        var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
        cameraPZ.up.set( 0, - 1, 0 );
        cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
        this.add( cameraPZ );

        var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
        cameraNZ.up.set( 0, - 1, 0 );
        cameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );
        this.add( cameraNZ );

        this.update = function () {
            if ( this.parent === null ) this.updateMatrixWorld();
        };
    }

    CubeCamera.prototype = Object.create( THREE.Object3D.prototype );
    CubeCamera.prototype.constructor = CubeCamera;





    var CubeView = function () {
        function CubeView(textures) {
            var maskResolution = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 128;

            _classCallCheck(this, CubeView);

            this.scene = new THREE.Scene();

            // this.camera = new THREE.CubeCamera(1, 1000, 1);
            // const cubeRenderTarget = new THREE.WebGLCubeRenderTarget( 128 );
            // console.log(THREE.WebGLCubeRenderTarget, {cubeRenderTarget});

            this.camera = new CubeCamera(1, 1000);
            // this.camera.layers.set(2)
            // this.scene.add( this.camera );
            // console.log('this.camera', this.camera);
            this.camera.children.forEach(function (camera) {
                return camera.layers.set(2);
            });

            this._createRenderTargets(maskResolution);
            this._createCube(textures, maskResolution);
        }

        _createClass(CubeView, [{
            key: '_createRenderTargets',
            value: function _createRenderTargets(maskResolution) {
                this._renderTargets = [];
                for (var i = 0; i < 6; i += 1) {
                    var renderTarget = new THREE.WebGLRenderTarget(maskResolution, maskResolution);
                    this._renderTargets.push(renderTarget);
                    // console.log(renderTarget);
                    // var canvas = document.createElement('canvas')
                    // var ctx = canvas.getContext('2d');
                    // ctx.drawImage(renderTarget.texture.image, 0, 0)
                    // document.body.appendChild(renderTarget.texture.image)
                }
            }
        }, {
            key: '_getMaskTextures',
            value: function _getMaskTextures() {
                var textures = [];

                if (this._renderTargets) {
                    this._renderTargets.forEach(function (renderTarget) {
                        textures.push(renderTarget.texture);
                    });
                }

                return textures;
            }
        }, {
            key: 'updateMask',
            value: function updateMask(renderer, scene) {
                var _this30 = this;

                renderer.autoClear = true;
                renderer.clear();

                this.camera.children.forEach(function (camera, i) {
                    // renderer.render(scene, camera, _this30._renderTargets[i]);
                    renderer.setRenderTarget(_this30._renderTargets[i])
                    renderer.render(scene, camera);

                    // if (i === 1) {
                    //     renderer.setRenderTarget(null)
                    //     renderer.render(scene, camera);

                    //     var tempCanvas = document.getElementById('tempCanvas')
                    //     if (!tempCanvas) {
                    //         tempCanvas = document.createElement('canvas')
                    //         tempCanvas.id = 'tempCanvas'
                    //         tempCanvas.style.position = 'absolute'
                    //         tempCanvas.style.width = '400px'
                    //         tempCanvas.style.height = '400px'
                    //         tempCanvas.style.transform = 'rotate(180deg)'
                    //         tempCanvas.width = renderer.domElement.width
                    //         tempCanvas.height = renderer.domElement.height

                    //         document.body.appendChild(tempCanvas)
                    //     }

                    //     var ctx = tempCanvas.getContext('2d')
                    //     ctx.drawImage(renderer.domElement, 0, 0, tempCanvas.width, tempCanvas.height)
                    // }
                });

                renderer.setRenderTarget(null)
            }
        }, {
            key: '_getMaterials',
            value: function _getMaterials(textures) {
                var materials = [];
                var masks = this._getMaskTextures();
                for (var i = 0; i < 6; i += 1) {
                    masks[i].flipY = false;
                    var uniforms = {
                        tMask: { value: masks[i] }
                    };

                    if (textures) {
                        if (textures.images && textures.images[i]) {
                            textures.images[i].flipY = false;
                            uniforms.tImage = { value: textures.images[i] };
                        }

                        if (textures.matt && textures.matt[i]) {
                            textures.matt[i].flipY = false;
                            uniforms.useMattShadow = { value: true };
                            uniforms.tMattShadow = { value: textures.matt[i] };
                        }
                        if (textures.glossy && textures.glossy[i]) {
                            textures.glossy[i].flipY = false;
                            uniforms.useGlossyShadow = { value: true };
                            uniforms.tGlossyShadow = { value: textures.glossy[i] };
                        }
                    }

                    materials.push(new THREE.ShaderMaterial({
                        vertexShader: vertexShader,
                        fragmentShader: fragmentShader,
                        uniforms: uniforms,
                        transparent: true,
                    }));
                }

                return materials;
            }
        }, {
            key: '_createCube',
            value: function _createCube(textures, maskResolution) {
                var _this31 = this;

                var size = 10;

                var materials = this._getMaterials(textures);

                SIDES_POSITIONS.forEach(function (sidePosition, i) {
                    var planeGeometry = new THREE.PlaneBufferGeometry(size, size);

                    // eat 1 pixel off the edges away
                    var _p = 2/maskResolution, _a=[_p, 1-_p,1-_p,1-_p ,_p,_p, 1-_p, _p];
                    planeGeometry.attributes.uv.array.set(_a);

                    var planeMesh = new THREE.Mesh(planeGeometry, materials[i]);
                    planeMesh.position.copy(sidePosition);
                    planeMesh.position.multiplyScalar(size / 2);

                    planeMesh.lookAt(_this31.scene.position);

                    planeMesh.rotation.z += sidePosition.rotationZ;

                    // remove the cracks between the planes and keep them from re-appearing
                    // planeMesh.updateMatrix();
                    // Object.freeze(planeMesh.matrix.elements = planeMesh.matrix.elements.map(Math.round));

                    _this31.scene.add(planeMesh);
                });
            }
        }]);

        return CubeView;
    }();

    function PanoramaControls(camera, domElement, render) {
        this.enabled = true;

        this.enableZoom = true;
        this.zoomSpeed = 1.0;

        this.fovMin = 1;
        this.fovMax = 176;

        var scope = this;

        var target = new window.THREE.Vector3();
        var lon = -90 + 0.5; // +0.5 To fix grout issue in mobile
        var lat = 0;
        var phi = 0;
        var theta = 0;
        var touchX = void 0;
        var touchY = void 0;
        var touchZoomDistance = void 0;

        var interacting = false;

        function update() {
            if (!scope.enabled) {
                return;
            }

            lat = Math.max(-85, Math.min(85, lat));
            phi = window.THREE.MathUtils.degToRad(90 - lat);
            theta = window.THREE.MathUtils.degToRad(lon);
            target.x = Math.sin(phi) * Math.cos(theta);
            target.y = Math.cos(phi);
            target.z = Math.sin(phi) * Math.sin(theta);
            camera.lookAt(target);
        }

        this.update = update;

        update();
        render();

        function autoRotate() {
            if(!interacting) {
                lon += 0.05;
                update();
                render();
            }
            requestAnimationFrame(autoRotate);
        }

        if (_isSavedRoom) {
            requestAnimationFrame(autoRotate);
        }

        function onMouseMove(event) {
            var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
            var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
            lon -= movementX * 0.1;
            lat += movementY * 0.1;

            update();
            render();
        }

        function onMouseUp() {
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
            interacting = false;
        }

        function onMouseWheel(event) {
            if (!scope.enabled || !scope.enableZoom) {
                return;
            }

            event.preventDefault();
            var delta = event.deltaY * scope.zoomSpeed * 0.02;
            if (delta < 0 && camera.fov > scope.fovMin || delta > 0 && camera.fov < scope.fovMax) {
                camera.fov += delta;
                // console.log(camera.fov);

                camera.updateProjectionMatrix();

                render();
            }
        }

        function onMouseDown(event) {
            if (!scope.enabled) {
                return;
            }

            event.preventDefault();
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('mouseup', onMouseUp, false);
            interacting = true;
        }

        function onTouchMove(event) {
            event.preventDefault();
            event.stopPropagation();
            var touch = event.touches[0];
            lon -= (touch.screenX - touchX) * 0.1;
            lat += (touch.screenY - touchY) * 0.1;

            if (event.touches[1] && scope.enabled && scope.enableZoom) {
                var touch2 = event.touches[1];
                var dx = touch2.screenX - touch.screenX
                var dy = touch2.screenY - touch.screenY
                var distance = Math.sqrt((dx*dx + dy*dy))
                var delta = touchZoomDistance ? (touchZoomDistance - distance) * scope.zoomSpeed * 0.2 : 0;
                if (delta < 0 && camera.fov > scope.fovMin || delta > 0 && camera.fov < scope.fovMax) {
                    camera.fov += delta;
                    camera.updateProjectionMatrix();
                }
                touchZoomDistance = distance
            }

            touchX = touch.screenX;
            touchY = touch.screenY;

            update();
            render();
        }

        function onTouchEnd() {
            document.removeEventListener('touchmove', onTouchMove);
            document.removeEventListener('touchend', onTouchEnd);
            interacting = false;
            touchZoomDistance = 0
        }

        function onTouchStart(event) {
            if (!scope.enabled) {
                return;
            }

            event.stopPropagation();
            document.addEventListener('touchmove', onTouchMove, false);
            document.addEventListener('touchend', onTouchEnd, false);

            var touch = event.touches[0];
            touchX = touch.screenX;
            touchY = touch.screenY;
            interacting = true;
        }

        domElement.addEventListener('mousedown', onMouseDown, false);
        domElement.addEventListener('wheel', onMouseWheel, false);
        domElement.addEventListener('touchstart', onTouchStart, false);
    }

    /* global THREE */

    /* global THREE */

    var SURFACE_DEFAULTS = {
        color: '#ffffff',
        groutSize: Number(window.JsConstants.config.TiledSurface.groutSize) || 0,
        groutColor: '#ffffff',
        rotation: 0,
        fillTypeIndex: 0,
        freeDesign: false,
        // tile: undefined,
        // tileIndex: undefined,
        // tile2: undefined,
        // tile2Index: undefined,
        // texture: undefined,
        textureIndex: 0,
        skewSize: Number(window.JsConstants.config.TiledSurface.skewSize) || 0.5
    };

    var TiledSurface = function () {
        function TiledSurface(surfaceData, stencilRef) {
            _classCallCheck(this, TiledSurface);

            Object.assign(this, SURFACE_DEFAULTS);

            this.type = surfaceData.type;
            this._stencilRef = stencilRef;

            // this.setGroutColor();
        }

        _createClass(TiledSurface, [{
            key: 'setColor',
            value: function setColor() {
                var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0xffffff;

                if (this.mesh.material) {
                    // this.mesh.material.color.set(color);
                    // this.color = '#' + this.mesh.material.color.getHexString();
                } else if (this.visibleMesh.material) {
                    this.visibleMesh.material.color.set(color);
                    this.color = '#' + this.visibleMesh.material.color.getHexString();
                }
            }
        }, {
            key: 'setGroutColor',
            value: function setGroutColor() {
                var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0xffffff;

                if (this.groutMaterial) {
                    this.groutMaterial.color.set(color);
                } else {
                    this.groutMaterial = new THREE.MeshBasicMaterial({
                        color: color,
                        // depthWrite: false,
                        // polygonOffset: true,
                        // polygonOffsetFactor: -1,
                        stencilWrite: true,
                        stencilRef: this._stencilRef,
                        stencilFunc: THREE.EqualStencilFunc,
                        // stencilZPass: THREE.ReplaceStencilOp,
                    });
                }
                this.groutColor = '#' + this.groutMaterial.color.getHexString();
                // this._update();
            }
        }, {
            key: '_useGrout',
            value: function _useGrout(tile) {
                if (tile && tile.grout) {
                    if (!this.groutSize && this._reservedGroutSize) {
                        this.groutSize = this._reservedGroutSize;
                    }
                } else if (this.groutSize) {
                    this._reservedGroutSize = this.groutSize;
                    this.groutSize = 0;
                }
            }
        }, {
            key: 'setGroutSize',
            value: function setGroutSize(value) {
                var groutSize = value === undefined ? SURFACE_DEFAULTS.groutSize : value;
                this.groutSize = Math.max(0, Math.min(24, groutSize)) || 0;
                // this._update();
                // this._updateMask();
            }
        }, {
            key: 'setFillType',
            value: function setFillType(value) {
                // this.clear();
                this.fillTypeIndex = Number(value) || 0;
                // const drawEver = this.fillTypeIndex === 1 ? 0 : undefined; // Chess
                // this._tiles.fill(drawEver);
                // this._updateMask();
            }
        }, {
            key: 'setSkewSize',
            value: function setSkewSize(value) {
                this.skewSize = Math.max(0.1, Math.min(0.9, Number(value) || SURFACE_DEFAULTS.skewSize));
            }
        }, {
            key: 'rotate',
            value: function rotate(angle) {
                this.rotation = Number(angle) || 0;
                // this.rotationRadians = THREE.MathUtils.degToRad(this.rotation);
                // this._update();
                // this._updateMask();
            }
        }, {
            key: 'getSettings',
            value: function getSettings() {
                return {
                    color: this.color,
                    groutSize: this.groutSize || undefined,
                    groutColor: this.groutColor,
                    rotation: this.rotation || undefined,
                    fillTypeIndex: this.fillTypeIndex || undefined,
                    tileId: this.tile ? this.tile.id : undefined,
                    tileCustom: this.tile ? this.tile.custom : undefined,
                    tile2Id: this.tile2 ? this.tile2.id : undefined,
                    tile2Custom: this.tile2 ? this.tile2.custom : undefined,
                    skewSize: this.skewSize,
                    freeDesign: this.freeDesign || undefined,
                    freeDesignTiles: this.freeDesign ? this._getFreeDesignTilesSettings() : undefined
                };
            }
        }, {
            key: 'restoreSettings',
            value: function restoreSettings(sets) {
                if ((typeof sets === 'undefined' ? 'undefined' : _typeof(sets)) === 'object') {
                    if (sets.color) this.color = sets.color;
                    if (sets.groutSize) this.groutSize = sets.groutSize;
                    if (sets.groutColor) this.setGroutColor(sets.groutColor);
                    if (sets.rotation) this.rotate(sets.rotation);
                    if (sets.fillTypeIndex) this.fillTypeIndex = sets.fillTypeIndex;
                    if (sets.skewSize) this.skewSize = sets.skewSize;

                    if (sets.tileId) {
                        var tile = TilesList.getById(sets.tileId, sets.tileCustom);
                        this.setTile(tile);
                    }
                    if (sets.tile2Id) {
                        var _tile = TilesList.getById(sets.tile2Id, sets.tile2Custom);
                        this.setTile2(_tile);
                    }

                    if (sets.freeDesign) {
                        this.freeDesign = sets.freeDesign;
                        this._restoreFreeDesignTiles(sets.freeDesignTiles);
                    }

                    // this._update();
                    // this._updateMask();
                }
            }
        }, {
            key: 'setTile',
            value: function setTile(tile) {
                this._useGrout(tile);
                if ((typeof tile === 'undefined' ? 'undefined' : _typeof(tile)) === 'object') {
                    this.tile = tile;
                    this.tileIndex = tile.index;
                } else {
                    this.tile = undefined;
                    this.tileIndex = undefined;
                }
            }

            /**
             * Set tile for second layer of chess pattern
             * @param {Object} tile
             */

        }, {
            key: 'setTile2',
            value: function setTile2(tile) {
                if ((typeof tile === 'undefined' ? 'undefined' : _typeof(tile)) === 'object') {
                    this.tile2 = tile;
                    this.tile2Index = tile.index;
                } else {
                    this.tile2 = undefined;
                    this.tile2Index = undefined;
                }
            }
        }, {
            key: 'clearTile2',
            value: function clearTile2() {
                this.tile2 = undefined;
                this.tile2Index = undefined;
            }
        }, {
            key: 'setFreeDesign',
            value: function setFreeDesign(value) {
                this.freeDesign = Boolean(value); // value === true
                // this._freeDesignTiles.clear();
                // this._updateMask();
            }
        }, {
            key: '_getFreeDesignTilesSettings',
            value: function _getFreeDesignTilesSettings() {
                return this.freeDesignTiles;
            }
        }, {
            key: '_restoreFreeDesignTiles',
            value: function _restoreFreeDesignTiles(tilesSettings) {
                this.freeDesignTiles = tilesSettings;
            }
        }]);

        return TiledSurface;
    }();

    /* global THREE */

    // White mask for glossy tiles


    var MATT_MASK_MATERIAL = new THREE.MeshBasicMaterial({
        polygonOffset: true,
        polygonOffsetFactor: -1,
        // stencilWrite: true,
        // stencilRef: this._stencilRef,
        // stencilFunc: THREE.EqualStencilFunc,
        // stencilZPass: THREE.ReplaceStencilOp,
    });

    // // Black mask for glossy tiles
    var GLOSSY_MASK_MATERIAL = new THREE.MeshBasicMaterial({ color: 0x000000,
        polygonOffset: true,
        polygonOffsetFactor: -1,
        // stencilWrite: true,
        // stencilRef: this._stencilRef,
        // stencilFunc: THREE.EqualStencilFunc,
        // stencilZPass: THREE.ReplaceStencilOp,
    });

    var PLANE_GEOMETRY = void 0;

    var TileMesh = function (_THREE$Group) {
        _inherits(TileMesh, _THREE$Group);

        function TileMesh(tile, material, position, surface, zOffset, stencilRef, freeDesign) {
            _classCallCheck(this, TileMesh);

            var _this32 = _possibleConstructorReturn(this, (TileMesh.__proto__ || Object.getPrototypeOf(TileMesh)).call(this));

            _this32._tile = tile;
            _this32._width = tile.width;
            _this32._height = tile.height;
            _this32._zOffset = zOffset;
            this._stencilRef = stencilRef

            _this32._addGrout(surface);
            _this32._createTile(material);

            if (freeDesign) {
                _this32._createMask(tile.finish);
            }

            _this32._setPositionAndRotation(position, surface.rotationRadians);

            surface.add(_this32);

            return _this32;
        }

        _createClass(TileMesh, [{
            key: '_createTile',
            value: function _createTile(material) {
                if (!material) return;

                var mesh = new THREE.Mesh(this._geometry, material);
                mesh.scale.set(this._width, this._height, 1);
                this.position.z = 1;
                this.add(mesh);
            }
        }, {
            key: '_addGrout',
            value: function _addGrout(surface) {
                if (surface.groutSize === 0) return;
                if (surface.groutColor === surface.color) return;

                var mesh = new THREE.Mesh(this._geometry, surface.groutMaterial);
                var groutSize = surface.groutSize * 2;
                mesh.scale.set(this._width + groutSize, this._height + groutSize, 1);
                this.add(mesh);
            }
        }, {
            key: '_setPositionAndRotation',
            value: function _setPositionAndRotation(position, surfaceRotation) {
                this.move(position);

                if (position.rotation) this.rotation.z = position.rotation || 0;
                if (surfaceRotation) this.rotation.z += surfaceRotation || 0;
            }
        }, {
            key: 'move',
            value: function move(position) {
                this.position.copy(position);
                this.position.z = this._zOffset;
            }
        }, {
            key: 'remove',
            value: function remove() {
                this.parent.remove(this);
            }
        }, {
            key: 'rotate',
            value: function rotate() {
                this.rotation.z += Math.PI;
                return this.rotation;
            }
        }, {
            key: '_createMask',
            value: function _createMask(finish) {
                var material = finish === 'glossy' ? GLOSSY_MASK_MATERIAL : MATT_MASK_MATERIAL;
                var mask = new THREE.Mesh(this._geometry, material);
                mask.layers.set(2);
                mask.scale.set(this._width, this._height, 1);

                this.add(mask);
            }

            // getDataToSave() {
            //     return {
            //         id: this._tile.id,
            //         xIndex: this._tile.xIndex,
            //         yIndex: this._tile.yIndex,
            //         custom: this._tile.custom,
            //     };
            // }

        }, {
            key: '_geometry',
            get: function get() {
                if (!PLANE_GEOMETRY) {
                    PLANE_GEOMETRY = new THREE.PlaneBufferGeometry(1, 1);
                }

                return PLANE_GEOMETRY;
            }
        }]);

        return TileMesh;
    }(THREE.Group);

    var SquareTileMesh = function (_TileMesh) {
        _inherits(SquareTileMesh, _TileMesh);

        function SquareTileMesh() {
            _classCallCheck(this, SquareTileMesh);

            return _possibleConstructorReturn(this, (SquareTileMesh.__proto__ || Object.getPrototypeOf(SquareTileMesh)).apply(this, arguments));
        }

        _createClass(SquareTileMesh, [{
            key: 'rotate',

            /** @override */
            value: function rotate() {
                this.rotation.z += Math.PI / 2;
                return this.rotation;
            }
        }]);

        return SquareTileMesh;
    }(TileMesh);

    var DIAMOND_GEOMETRY = void 0;

    var DiamondTileMesh = function (_TileMesh2) {
        _inherits(DiamondTileMesh, _TileMesh2);

        function DiamondTileMesh() {
            _classCallCheck(this, DiamondTileMesh);

            return _possibleConstructorReturn(this, (DiamondTileMesh.__proto__ || Object.getPrototypeOf(DiamondTileMesh)).apply(this, arguments));
        }

        _createClass(DiamondTileMesh, [{
            key: '_geometry',

            /** @override */
            get: function get() {
                if (DIAMOND_GEOMETRY) return DIAMOND_GEOMETRY;

                DIAMOND_GEOMETRY = new THREE.BufferGeometry();
                var vertices = new Float32Array([0.5, 0, 0, 0, 0.5, 0, -0.5, 0, 0, 0.5, 0, 0, -0.5, 0, 0, 0, -0.5, 0]);
                DIAMOND_GEOMETRY.setAttribute('position', new THREE.BufferAttribute(vertices, 3));

                var uvs = new Float32Array([1, 0.5, 0.5, 1, 0, 0.5, 1, 0.5, 0, 0.5, 0.5, 0]);
                DIAMOND_GEOMETRY.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));

                return DIAMOND_GEOMETRY;
            }
        }]);

        return DiamondTileMesh;
    }(TileMesh);

    var HEXAGON_GEOMETRY = void 0;
    var HEXAGON_GEOMETRY_CUSTOM_TILE = void 0;
    var HEXAGON_GEOMETRY_VERTICES = new Float32Array([0.5, 0, 0, 0.25, 0.5, 0, -0.25, 0.5, 0, 0.5, 0, 0, -0.25, 0.5, 0, -0.5, 0, 0, 0.5, 0, 0, -0.5, 0, 0, -0.25, -0.5, 0, 0.5, 0, 0, -0.25, -0.5, 0, 0.25, -0.5, 0]);

    var HexagonTileMesh = function (_TileMesh3) {
        _inherits(HexagonTileMesh, _TileMesh3);

        function HexagonTileMesh() {
            _classCallCheck(this, HexagonTileMesh);

            return _possibleConstructorReturn(this, (HexagonTileMesh.__proto__ || Object.getPrototypeOf(HexagonTileMesh)).apply(this, arguments));
        }

        _createClass(HexagonTileMesh, [{
            key: 'rotate',


            /** @override */
            value: function rotate() {
                this.rotation.z += Math.PI / 3;
                return this.rotation;
            }
        }, {
            key: '_geometry',

            /** @override */
            get: function get() {
                if (this._tile.custom) {
                    if (HEXAGON_GEOMETRY_CUSTOM_TILE) return HEXAGON_GEOMETRY_CUSTOM_TILE;

                    HEXAGON_GEOMETRY_CUSTOM_TILE = new THREE.BufferGeometry();
                    HEXAGON_GEOMETRY_CUSTOM_TILE.setAttribute('position', new THREE.BufferAttribute(HEXAGON_GEOMETRY_VERTICES, 3));

                    var uvsCustomTiles = new Float32Array([0.5, 0, 1, 0.25, 1, 0.75, 0.5, 0, 1, 0.75, 0.5, 1, 0.5, 0, 0.5, 1, 0, 0.75, 0.5, 0, 0, 0.75, 0, 0.25]);
                    HEXAGON_GEOMETRY_CUSTOM_TILE.setAttribute('uv', new THREE.BufferAttribute(uvsCustomTiles, 2));

                    return HEXAGON_GEOMETRY_CUSTOM_TILE;
                }

                if (HEXAGON_GEOMETRY) return HEXAGON_GEOMETRY;

                HEXAGON_GEOMETRY = new THREE.BufferGeometry();
                HEXAGON_GEOMETRY.setAttribute('position', new THREE.BufferAttribute(HEXAGON_GEOMETRY_VERTICES, 3));

                var uvs = new Float32Array([1, 0.5, 0.75, 1, 0.25, 1, 1, 0.5, 0.25, 1, 0, 0.5, 1, 0.5, 0, 0.5, 0.25, 0, 1, 0.5, 0.25, 0, 0.75, 0]);
                HEXAGON_GEOMETRY.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));

                return HEXAGON_GEOMETRY;
            }
        }]);

        return HexagonTileMesh;
    }(TileMesh);

    var PreparedSetTileMesh = function (_TileMesh4) {
        _inherits(PreparedSetTileMesh, _TileMesh4);

        function PreparedSetTileMesh() {
            _classCallCheck(this, PreparedSetTileMesh);

            return _possibleConstructorReturn(this, (PreparedSetTileMesh.__proto__ || Object.getPrototypeOf(PreparedSetTileMesh)).apply(this, arguments));
        }

        _createClass(PreparedSetTileMesh, [{
            key: '_createTile',

            /** @override */
            value: function _createTile(material) {
                if (!material) return;

                material.transparent = true;
                // material.depthTest = true;
                material.depthWrite = false;
                // material.alphaTest = 0.3;

                _get(PreparedSetTileMesh.prototype.__proto__ || Object.getPrototypeOf(PreparedSetTileMesh.prototype), '_createTile', this).call(this, material);
            }
        }]);

        return PreparedSetTileMesh;
    }(TileMesh);

    /* global THREE */

    var TilesGrid = function () {
        function TilesGrid(surface, tile, stencilRef, freeDesign) {
            _classCallCheck(this, TilesGrid);

            // this._STANDARD = 0;
            this._CHESS = 1;
            this._HORIZONTAL_SKEW = 2;
            this._VERTICAL_SKEW = 3;

            this._surface = surface; // todo fix. Used for groutSize and fillTypeIndex

            this._width = surface.width;
            this._height = surface.height;

            this._shape = tile.shape;
            this._tileWidth = tile.width;
            this._tileHeight = tile.height;

            this._LEFT = -(this._width - this._tileWidth) / 2;
            this._TOP = (this._height - this._tileHeight) / 2;

            this._stencilRef = stencilRef
            this._freeDesign = freeDesign
        }

        _createClass(TilesGrid, [{
            key: 'getTileMesh',
            value: function getTileMesh(tile, material, position, zOffset) {
                if (tile.shape === 'square' || tile.shape === 'rectangle' && tile.width === tile.height) {
                    return new SquareTileMesh(tile, material, position, this._surface, zOffset, this._stencilRef, this._freeDesign);
                }
                return new TileMesh(tile, material, position, this._surface, zOffset, this._stencilRef, this._freeDesign);
            }
        }, {
            key: '_isEven',
            value: function _isEven(number) {
                if (Math.round(number % 2) === 0) {
                    return true;
                }
                return false;
            }
        }, {
            key: '_isOdd',
            value: function _isOdd(number) {
                if (Math.round(Math.abs(number % 2)) === 1) {
                    return true;
                }
                return false;
            }
        }, {
            key: '_getPosition',
            value: function _getPosition(options) {
                var x = options.xIndex * this._cellWidth;
                var y = options.yIndex * this._cellHeight;

                if (options.horizontalSkew) x += this._cellWidth * this._surface.skewSize;
                if (options.verticalSkew) y += this._cellHeight * (1 - this._surface.skewSize);

                return { x: x, y: y };
            }
        }, {
            key: '_applyOffset',
            value: function _applyOffset(point) {
                point.x += this._LEFT + this._surface.groutSize;
                point.y += this._TOP - this._surface.groutSize;
                point.z = 0;
            }
        }, {
            key: '_applyRotation',
            value: function _applyRotation(position) {
                var inverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

                if (this._surface.rotation === 0) return;

                var angle = inverse ? -this._surface.rotationRadians : this._surface.rotationRadians;
                var point = new THREE.Vector2(position.x, position.y);
                point.rotateAround(this._surface.zeroPoint, angle);
                position.x = point.x;
                position.y = point.y;
            }
        }, {
            key: 'getPosition',
            value: function getPosition(options) {
                var position = this._getPosition(options);
                this._applyOffset(position);
                this._applyRotation(position);

                return position;
            }
        }, {
            key: '_getApproximateCell',
            value: function _getApproximateCell(point) {
                var xIndex = Math.floor(point.x / this._cellWidth);
                var yIndex = Math.floor(point.y / this._cellHeight);

                return { xIndex: xIndex, yIndex: yIndex };
            }
        }, {
            key: 'getApproximateCell',
            value: function getApproximateCell(point) {
                this._applyRotation(point, true);
                point.x -= this._surface.zeroPoint.x;
                point.y -= this._surface.zeroPoint.y;
                return this._getApproximateCell(point);
            }
        }, {
            key: '_checkNeighborTile',
            value: function _checkNeighborTile(tilesArray, tiles, tile, i, j) {
                if (tiles.length <= 2) return false;

                return tile === tilesArray[j][i - 1] || j > 0 && tile === tilesArray[j - 1][i];
            }
        }, {
            key: '_getRandomTile',
            value: function _getRandomTile(tilesArray, tiles, i, j) {
                if (Array.isArray(tiles) && tiles.length > 1) {
                    var tile = tiles[Math.floor(Math.random() * tiles.length)];
                    if (this._checkNeighborTile(tilesArray, tiles, tile, i, j)) {
                        return this._getRandomTile(tilesArray, tiles, i, j);
                    }
                    return tile;
                }
                return tiles[0];
            }
        }, {
            key: '_getSize',
            value: function _getSize() {
                var surfaceMaxSize = Math.max(this._width, this._height);
                var count = {
                    width: surfaceMaxSize / this._tileWidth,
                    height: surfaceMaxSize / this._tileHeight
                };

                if (typeof this._multiplySize === 'function') this._multiplySize(count);

                count.width = Math.ceil(count.width + 4 - count.width % 4);
                count.height = Math.ceil(count.height + 4 - count.height % 4);

                return count;
            }
        }, {
            key: '_drawIfChess',
            value: function _drawIfChess(i, j, drawEver) {
                return Math.abs((i + j) % 2) === drawEver;
            }
        }, {
            key: 'get',
            value: function get(tiles, drawEver) {
                var size = this._getSize();
                var tilesArray = [];
                var grid = [];

                for (var j = -size.height; j < size.height; j += 1) {
                    tilesArray[j + size.height] = [];
                    for (var i = -size.width; i < size.width; i += 1) {
                        var tile = this._getRandomTile(tilesArray, tiles, i + size.width, j + size.height);

                        tilesArray[j + size.height][i + size.width] = tile;

                        var tileOptions = {
                            // container: this._surface.tilesContainer,
                            tile: tile,
                            xIndex: i,
                            yIndex: j
                        };

                        switch (this._surface.fillTypeIndex) {
                            case this._CHESS:
                                if (this._drawIfChess(i, j, drawEver)) {
                                    grid.push(tileOptions);
                                }
                                break;

                            case this._HORIZONTAL_SKEW:
                                if (this._isOdd(j)) tileOptions.horizontalSkew = true;
                                grid.push(tileOptions);
                                break;

                            case this._VERTICAL_SKEW:
                                if (this._isOdd(i)) tileOptions.verticalSkew = true;
                                grid.push(tileOptions);
                                break;

                            default:
                                // StandardFillType
                                grid.push(tileOptions);
                        }
                    }
                }

                return grid;
            }
        }, {
            key: '_cellWidth',
            get: function get() {
                return this._tileWidth + this._surface.groutSize;
            }
        }, {
            key: '_cellHeight',
            get: function get() {
                return this._tileHeight + this._surface.groutSize;
            }
        }]);

        return TilesGrid;
    }();

    var DiamondTilesGrid = function (_TilesGrid) {
        _inherits(DiamondTilesGrid, _TilesGrid);

        function DiamondTilesGrid() {
            _classCallCheck(this, DiamondTilesGrid);

            return _possibleConstructorReturn(this, (DiamondTilesGrid.__proto__ || Object.getPrototypeOf(DiamondTilesGrid)).apply(this, arguments));
        }

        _createClass(DiamondTilesGrid, [{
            key: 'getTileMesh',
            value: function getTileMesh(tile, material, position, zOffset) {
                return new DiamondTileMesh(tile, material, position, this._surface, zOffset, this._stencilRef, this._freeDesign);
            }
        }, {
            key: '_getPosition',
            value: function _getPosition(options) {
                var x = this._isEven(options.yIndex) ? options.xIndex * this._cellWidth : (options.xIndex + 0.5) * this._cellWidth;

                var y = options.yIndex * this._cellHeight / 2;

                return { x: x, y: y };
            }
        }, {
            key: '_getApproximateCell',
            value: function _getApproximateCell(point) {
                var xIndex = Math.floor(point.x / this._cellWidth) - 1;
                var yIndex = Math.floor(point.y / (this._cellHeight / 2)) + 1;

                return { xIndex: xIndex, yIndex: yIndex };
            }
        }, {
            key: '_checkNeighborTile',
            value: function _checkNeighborTile(tilesArray, tiles, tile, i, j) {
                if (tiles.length <= 2) return false;

                if (this._isEven(j)) {
                    return j > 0 && tile === tilesArray[j - 1][i - 1] || j > 0 && tile === tilesArray[j - 1][i];
                }

                return j > 0 && tile === tilesArray[j - 1][i + 1] || j > 0 && tile === tilesArray[j - 1][i];
            }
        }, {
            key: '_multiplySize',
            value: function _multiplySize(count) {
                count.height *= 2;
            }
        }, {
            key: '_drawIfChess',
            value: function _drawIfChess(i, j, drawEver) {
                // eslint-disable-line no-unused-vars
                if (this._isEven(j)) return drawEver === 0;
                return drawEver === 1;
            }
        }, {
            key: '_cellWidth',
            get: function get() {
                var aspectRatio = 0.707 * 2;
                return this._tileWidth + this._surface.groutSize * aspectRatio;
            }
        }]);

        return DiamondTilesGrid;
    }(TilesGrid);

    var HexagonTilesGrid = function (_DiamondTilesGrid) {
        _inherits(HexagonTilesGrid, _DiamondTilesGrid);

        function HexagonTilesGrid() {
            _classCallCheck(this, HexagonTilesGrid);

            return _possibleConstructorReturn(this, (HexagonTilesGrid.__proto__ || Object.getPrototypeOf(HexagonTilesGrid)).apply(this, arguments));
        }

        _createClass(HexagonTilesGrid, [{
            key: 'getTileMesh',
            value: function getTileMesh(tile, material, position, zOffset) {
                return new HexagonTileMesh(tile, material, position, this._surface, zOffset, this._stencilRef, this._freeDesign);
            }
        }, {
            key: '_checkNeighborTile',
            value: function _checkNeighborTile(tilesArray, tiles, tile, i, j) {
                if (tiles.length <= 3) return false;

                if (this._isEven(j)) {
                    return j > 0 && tile === tilesArray[j - 1][i - 1] || j > 1 && tile === tilesArray[j - 2][i] || j > 0 && tile === tilesArray[j - 1][i];
                }

                return j > 0 && tile === tilesArray[j - 1][i + 1] || j > 0 && tile === tilesArray[j - 1][i] || j > 1 && tile === tilesArray[j - 2][i];
            }
        }, {
            key: '_multiplySize',
            value: function _multiplySize(count) {
                count.width *= 0.66; // 1.75 / 0.75 * count.width;
                count.height *= 2;
            }
        }, {
            key: '_drawIfChess',
            value: function _drawIfChess() {
                return true;
            }
        }, {
            key: '_cellWidth',
            get: function get() {
                var aspectRatio = 0.866 * 2;
                return this._tileWidth * 1.5 + this._surface.groutSize * aspectRatio;
            }
        }]);

        return HexagonTilesGrid;
    }(DiamondTilesGrid);

    var PreparedSetTilesGrid = function (_TilesGrid2) {
        _inherits(PreparedSetTilesGrid, _TilesGrid2);

        function PreparedSetTilesGrid(surface, tile, stencilRef, freeDesign) {
            _classCallCheck(this, PreparedSetTilesGrid);

            var _this39 = _possibleConstructorReturn(this, (PreparedSetTilesGrid.__proto__ || Object.getPrototypeOf(PreparedSetTilesGrid)).call(this, surface, tile, stencilRef, freeDesign));

            _this39._offsetX = tile.preparedSetOffset && tile.preparedSetOffset.x || 0;
            _this39._offsetY = tile.preparedSetOffset && tile.preparedSetOffset.y || 0;
            return _this39;
        }

        _createClass(PreparedSetTilesGrid, [{
            key: 'getTileMesh',
            value: function getTileMesh(tile, material, position, zOffset) {
                return new PreparedSetTileMesh(tile, material, position, this._surface, zOffset, this._stencilRef, this._freeDesign);
            }
        }, {
            key: '_multiplySize',
            value: function _multiplySize(count) {
                count.width *= 1 / (1 - this._offsetX / this._tileWidth);
                count.height *= 1 / (1 - this._offsetY / this._tileHeight);
            }
        }, {
            key: '_drawIfChess',
            value: function _drawIfChess() {
                return true;
            }
        }, {
            key: '_cellWidth',
            get: function get() {
                return this._tileWidth + this._surface.groutSize - this._offsetX;
            }
        }, {
            key: '_cellHeight',
            get: function get() {
                return this._tileHeight + this._surface.groutSize - this._offsetY;
            }
        }]);

        return PreparedSetTilesGrid;
    }(TilesGrid);

    var QuadSetTilesGrid = function (_TilesGrid3) {
        _inherits(QuadSetTilesGrid, _TilesGrid3);

        function QuadSetTilesGrid() {
            _classCallCheck(this, QuadSetTilesGrid);

            return _possibleConstructorReturn(this, (QuadSetTilesGrid.__proto__ || Object.getPrototypeOf(QuadSetTilesGrid)).apply(this, arguments));
        }

        _createClass(QuadSetTilesGrid, [{
            key: '_getPosition',
            value: function _getPosition(options) {
                var position = _get(QuadSetTilesGrid.prototype.__proto__ || Object.getPrototypeOf(QuadSetTilesGrid.prototype), '_getPosition', this).call(this, options);

                var oddX = this._isOdd(options.xIndex);
                var oddY = this._isOdd(options.yIndex);

                if (oddX && !oddY) position.rotation = Math.PI * 1.5;else if (!oddX && oddY) position.rotation = Math.PI / 2;else if (oddX && oddY) position.rotation = Math.PI;else position.rotation = 0;

                return position;
            }
        }, {
            key: '_drawIfChess',
            value: function _drawIfChess() {
                return true;
            }
        }]);

        return QuadSetTilesGrid;
    }(TilesGrid);

    /* global THREE */

    var TilesLayer = function () {
        function TilesLayer(surface, zOffset, stencilRef, freeDesign) {
            _classCallCheck(this, TilesLayer);

            this._surface = surface;
            this._zOffset = zOffset;
            this._stencilRef = stencilRef;
            this._freeDesign = freeDesign;

            this._tiles = [];
            this._cells = [];
            this._materials = [];
        }

        _createClass(TilesLayer, [{
            key: '_getGrid',
            value: function _getGrid() {
                var tile = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.tile;

                switch (tile.shape) {
                    case 'diamond':
                        return new DiamondTilesGrid(this._surface, tile, this._stencilRef, this._freeDesign);
                    case 'hexagon':
                        return new HexagonTilesGrid(this._surface, tile, this._stencilRef, this._freeDesign);
                    case 'preparedSet':
                    case 'notionHerringbon':
                    case 'riverstoneRohmboid':
                    case 'rivertsoneChevron':
                    case 'stoneSystemCombo':
                        return new PreparedSetTilesGrid(this._surface, tile, this._stencilRef, this._freeDesign);
                    case 'quadSet':
                        return new QuadSetTilesGrid(this._surface, tile, this._stencilRef, this._freeDesign);

                    default:
                        return new TilesGrid(this._surface, tile, this._stencilRef, this._freeDesign);
                }
            }
        }, {
            key: '_getMaterial',
            value: function _getMaterial(tile) {
                var material = void 0;
                this._materials.some(function (savedMaterial) {
                    if (savedMaterial.file === tile.file) {
                        material = savedMaterial.material;
                        return true;
                    }
                });
                if (!material) {
                    if (tile.specular) {
                        // http://www.cs.toronto.edu/~jacobson/phong-demo/
                        // https://threejs.org/docs/index.html#api/en/renderers/webgl/WebGLProgram
                        var vertexShader = /* glsl */`
                        // https://threejs.org/docs/index.html#api/en/renderers/webgl/WebGLProgram
                        // uniform mat4 modelMatrix;       // = object.matrixWorld
                        // uniform mat4 modelViewMatrix;   // = camera.matrixWorldInverse * object.matrixWorld
                        // uniform mat4 projectionMatrix;  // = camera.projectionMatrix
                        // uniform mat4 viewMatrix;        // = camera.matrixWorldInverse
                        // uniform mat3 normalMatrix;      // = inverse transpose of modelViewMatrix
                        // uniform vec3 cameraPosition;    // = camera position in world space

                        // default vertex attributes provided by BufferGeometry
                        // attribute vec3 position;
                        // attribute vec3 normal;
                        // attribute vec2 uv;

                        varying mat4 vViewMatrix;
                        varying vec2 vUv;
                        varying vec3 vVertex;
                        varying vec3 vNormal;

                        void main(){
                            vViewMatrix = viewMatrix;
                            vUv = uv;
                            vVertex = vec3(modelViewMatrix * vec4(position, 1.0));
                            vNormal = vec3(modelViewMatrix * vec4(normal, 0.0)); // vec3(normalMatrix * normal);

                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                        `;

                        var fragmentShader = /* glsl */`
                        #include <packing>

                        uniform sampler2D tDiffuse;
                        uniform sampler2D tSpecular;
                        uniform bool uHideTiles;
                        uniform bool uRotateWithRoom;
                        uniform float uShininess;
                        uniform float uSpecularPower;
                        uniform float uSpecColPower;
                        uniform vec3 uLights[3];
                        uniform bool uEnableLights[3];

                        varying mat4 vViewMatrix;
                        varying vec2 vUv;
                        varying vec3 vVertex;
                        varying vec3 vNormal;   // Surface normal

                        vec3 calcSpec(vec3 lightPosition) {
                            vec3 specCol = 1.0 - texture2D(tSpecular, vUv).rgb;     // invert colors

                            vec3 vLightPosition = lightPosition;
                            if (uRotateWithRoom) {
                                vLightPosition = vec3(vViewMatrix * vec4(lightPosition, 0.0));
                            }

                            vec3 normal = normalize(vNormal);
                            vec3 light = normalize(vLightPosition - vVertex);
                            vec3 vertex = normalize(-vVertex);                      // Vector to viewer

                            vec3 reflection = reflect(-light, normal);              // Reflected light vector
                            float specAngle = max(dot(reflection, vertex), 0.0);    // clamp(specAngle, 0.0, 1.0);
                            specAngle = pow(specAngle, uShininess);

                            return pow(specAngle, uSpecularPower) * pow(specCol, vec3(uSpecColPower));
                        }

                        void main() {
                            vec3 diffuse = texture2D(tDiffuse, vUv).rgb;
                            // vec3 specCol = 1.0 - texture2D(tSpecular, vUv).rgb;     // invert colors

                            // vec3 normal = normalize(vNormal);
                            // vec3 light = normalize(uLights[0] - vVertex);
                            // vec3 vertex = normalize(-vVertex);                      // Vector to viewer

                            // vec3 reflection = reflect(-light, normal);              // Reflected light vector
                            // float specAngle = max(dot(reflection, vertex), 0.0);    // clamp(specAngle, 0.0, 1.0);
                            // specAngle = pow(specAngle, uShininess);

                            // gl_FragColor = vec4(diffuse + pow(specAngle, uSpecularPower) * pow(specCol, vec3(uSpecColPower)), 1.0);


                            vec3 specular;
                            for(int i = 0; i < 3; i++) {
                                if (uEnableLights[i]) {
                                    specular += calcSpec(uLights[i]);
                                }
                            }
                            if (uHideTiles) {
                                gl_FragColor = vec4(specular, 1.0);
                            } else {
                                gl_FragColor = vec4(diffuse + specular, 1.0);
                            }
                        }


                        // void main() {
                        //     vec4 diffuse = texture2D(tDiffuse, vUv); // vec4(vec3(0.0), 1.0);
                        //     vec3 specCol = 1.0 - texture2D(tSpecular, vUv).rgb;     // invert colors

                        //     vec3 normal = normalize(vNormal);                       // The vertex's normal vector is being interpolated across the primitive which can make it un-normalized. So normalize the vertex's normal vector.
                        //     vec3 light = normalize(vLightPosition - vVertex);       // Calculate a vector from the fragment location to the light source
                        //     vec3 vertex = normalize(-vVertex);                      // Calculate a vector from the fragment location to the camera. The camera is at the origin, so negating the vertex location gives the vector

                        //     vec3 reflection = normalize(2.0 * dot(normal, light) * normal - light);    // Calculate the reflection vector
                        //     float specAngle = dot(reflection, vertex);              // Calculate the cosine of the angle between the reflection vector and the vector going to the camera.
                        //     specAngle = clamp(specAngle, 0.0, 1.0);
                        //     specAngle = pow(specAngle, uShininess);

                        //     vec3 specular = specCol * specAngle;                    // If this fragment gets a specular reflection, use the light's color
                        //     vec3 color = diffuse.rgb * (1.0 - specAngle);          // otherwise use the objects's color

                        //     gl_FragColor = vec4(specular + color, diffuse.a);
                        // }
                        `;

                        function getSpecularFileName(tileFile) {
                            if (!tileFile) return ''

                            const name = tileFile.split('/').pop()
                            return tileFile.replace(name, 'specular/' + name)
                        }

                        material = new THREE.ShaderMaterial({
                            vertexShader: vertexShader,
                            fragmentShader: fragmentShader,
                            uniforms: {
                                tDiffuse: { value: null },
                                tSpecular: { value: null },
                            },
                            polygonOffset: true,
                            polygonOffsetFactor: -1,
                            stencilWrite: true,
                            stencilRef: this._stencilRef,
                            stencilFunc: THREE.EqualStencilFunc,
                            // stencilZPass: THREE.ReplaceStencilOp,
                        })

                        new THREE.TextureLoader().load(tile.file, function (texture) {
                            material.uniforms.tDiffuse = { value: texture }
                            material.needsUpdate = true;
                        });

                        new THREE.TextureLoader().load(getSpecularFileName(tile.file), function (texture) {
                            material.uniforms.tSpecular = { value: texture }
                            material.uniforms.uHideTiles = guiObj.hideTiles;
                            material.uniforms.uRotateWithRoom = guiObj.rotateWithRoom;
                            material.uniforms.uShininess = guiObj.shininess;
                            material.uniforms.uSpecularPower = guiObj.specularPower;
                            material.uniforms.uSpecColPower = guiObj.specColPower;
                            material.uniforms.uLights = guiObj.positions;
                            material.uniforms.uEnableLights = guiObj.enableLights;
                            material.needsUpdate = true;
                        });
                    } else {
                        material = new THREE.MeshBasicMaterial({
                            polygonOffset: true,
                            polygonOffsetFactor: -1,
                            stencilWrite: true,
                            stencilRef: this._stencilRef,
                            stencilFunc: THREE.EqualStencilFunc,
                            // stencilZPass: THREE.ReplaceStencilOp,
                        });
                        new THREE.TextureLoader().load(tile.file, function (texture) {
                            material.map = texture;
                            material.needsUpdate = true;
                        });
                    }

                    this._materials.push({ file: tile.file, material: material });
                }
                return material;
            }
        }, {
            key: '_isTileOnSurface',
            value: function _isTileOnSurface(position) {
                if (!this._tileForm || !this._tileFormBox) {
                    var planeGeometry = new THREE.PlaneGeometry(1, 1);
                    this._tileForm = new THREE.Mesh(planeGeometry);

                    this._tileFormBox = new THREE.Box3();
                }

                this._tileForm.position.copy(position);
                this._tileForm.scale.x = this.tile.width;
                this._tileForm.scale.y = this.tile.height;
                this._tileForm.rotation.z = this._surface.rotationRadians;

                this._tileFormBox.setFromObject(this._tileForm);

                return this._surface.boundingBox.intersectsBox(this._tileFormBox);
            }
        }, {
            key: '_add',
            value: function _add(cell) {
                var position = this._grid.getPosition(cell);
                if (!this._isTileOnSurface(position)) return;

                if (cell.rotation) position.rotation = cell.rotation;
                var material = this._getMaterial(cell.tile);
                var tileMesh = this._grid.getTileMesh(cell.tile, material, position, this._zOffset);

                this._tiles.push(tileMesh);
                return tileMesh;
            }
        }, {
            key: 'set',
            value: function set(tile, drawEver) {
                this.tile = tile;
                this.tileIndex = tile.index;
                this._materials = [];
                this._grid = this._getGrid();

                this.fill(drawEver);
            }
        }, {
            key: 'removeAll',
            value: function removeAll() {
                if (this._tiles.length === 0) return;

                this._tiles.forEach(function (tile) {
                    return tile.remove();
                });
                this._tiles = [];
            }
        }, {
            key: 'clear',
            value: function clear() {
                this.tile = undefined;
                this.tileIndex = undefined;
                this._cells = [];
                this.removeAll();
            }
        }, {
            key: 'fill',
            value: function fill(drawEver) {
                if (_typeof(this.tile) !== 'object') return;

                this._cells = this._grid.get(this.tile.getRotoPrintSet(), drawEver);
                this.update();
            }
        }, {
            key: 'update',
            value: function update() {
                var _this41 = this;

                if (!Array.isArray(this._cells) || this._cells.length === 0) return;

                this.removeAll();
                this._cells.forEach(function (cell) {
                    return _this41._add(cell);
                });
            }
        }]);

        return TilesLayer;
    }();

    var NEIGHBOR_CELLS = [[-1, -1], [0, -1], [1, -1], [-1, 0], [1, 0], [-1, 1], [0, 1], [1, 1]];

    var FreeDesignTiles = function (_TilesLayer) {
        _inherits(FreeDesignTiles, _TilesLayer);

        function FreeDesignTiles() {
            _classCallCheck(this, FreeDesignTiles);

            return _possibleConstructorReturn(this, (FreeDesignTiles.__proto__ || Object.getPrototypeOf(FreeDesignTiles)).apply(this, arguments));
        }

        _createClass(FreeDesignTiles, [{
            key: 'fill',
            value: function fill() {
                /**
                 * Method override - blank func
                 */
            }
        }, {
            key: '_remove',
            value: function _remove(intersectObject) {
                var tile = intersectObject && intersectObject.parent;

                var index = this._tiles.indexOf(tile);
                if (index !== -1) {
                    tile.remove();
                    this._tiles.splice(index, 1);
                    this._cells.splice(index, 1);
                    return true;
                }
                return false;
            }
        }, {
            key: '_isTileOnSurface',
            value: function _isTileOnSurface() {
                return true;
            }
        }, {
            key: '_checkTilePlace',
            value: function _checkTilePlace(tileMesh, cell, isIntersect) {
                var _this43 = this;

                if (!tileMesh) return;

                if (isIntersect(tileMesh.children)) {
                    this._cells.push(cell);
                    return;
                }

                NEIGHBOR_CELLS.some(function (neighborCell) {
                    var nextCell = {
                        xIndex: cell.xIndex + neighborCell[0],
                        yIndex: cell.yIndex + neighborCell[1],
                        tile: cell.tile
                    };
                    var position = _this43._grid.getPosition(nextCell);
                    tileMesh.move(position);
                    tileMesh.position.z += _this43._zOffset; // todo optimize

                    if (isIntersect(tileMesh.children)) {
                        _this43._cells.push(nextCell);
                        return true;
                    }
                });
            }
        }, {
            key: '_add',
            value: function _add(cell) {
                if (!this._grid || cell.tile.shape !== this._grid._shape || cell.tile.width !== this._grid._tileWidth || cell.tile.height !== this._grid._tileHeight) {
                    this._grid = this._getGrid(cell.tile);
                }
                return _get(FreeDesignTiles.prototype.__proto__ || Object.getPrototypeOf(FreeDesignTiles.prototype), '_add', this).call(this, cell);
            }
        }, {
            key: 'click',
            value: function click(intersects, point, isIntersect) {
                var _this44 = this;

                var tileFound = intersects.some(function (intersect) {
                    return _this44._remove(intersect.object);
                });

                if (!tileFound && this.tile) {
                    var position = this._surface.mesh.worldToLocal(point);
                    var cell = this._grid.getApproximateCell(position);
                    cell.tile = this.tile.getRandomInSet();

                    var tileMesh = this._add(cell);

                    tileMesh.position.z += this._zOffset; // todo optimize

                    this._checkTilePlace(tileMesh, cell, isIntersect);
                }
            }
        }, {
            key: 'getSettings',
            value: function getSettings() {
                var _this45 = this;

                if (this._cells.length > 0) {
                    return this._cells.map(function (cell, i) {
                        var tileData = {
                            id: cell.tile.id,
                            custom: cell.tile.custom,
                            xIndex: cell.xIndex,
                            yIndex: cell.yIndex
                        };

                        var rotation = Number(_this45._tiles[i].rotation.z);
                        if (rotation) tileData.rotation = rotation;

                        return tileData;
                    });
                }
            }
        }, {
            key: 'restore',
            value: function restore(tilesData) {
                var _this46 = this;

                if (Array.isArray(tilesData) && tilesData.length > 0) {
                    tilesData.forEach(function (cell) {
                        cell.tile = TilesList.getById(cell.id, cell.custom);
                        if (_typeof(cell.tile) !== 'object') return;

                        var tileMesh = _this46._add(cell);
                        tileMesh.position.z += _this46._zOffset; // todo optimize
                        _this46._cells.push(cell);
                    });
                }
            }
        }]);

        return FreeDesignTiles;
    }(TilesLayer);

    /* global THREE */

    var PanoramaTiledSurface = function (_TiledSurface) {
        _inherits(PanoramaTiledSurface, _TiledSurface);

        function PanoramaTiledSurface(surfaceData, geometry, updateMask, stencilRef) {
            _classCallCheck(this, PanoramaTiledSurface);

            var _this47 = _possibleConstructorReturn(this, (PanoramaTiledSurface.__proto__ || Object.getPrototypeOf(PanoramaTiledSurface)).call(this, surfaceData, stencilRef));

            _this47._sizeMultiplier = 1000;

            _this47.rotationRadians = 0;
            _this47._tiles = new TilesLayer(_this47, 0.1, stencilRef);
            _this47._tiles2 = new TilesLayer(_this47, 0.1, stencilRef);
            _this47._freeDesignTiles = new FreeDesignTiles(_this47, 0.2, stencilRef, true);

            _this47._createMesh(geometry);

            _this47.setGroutColor();

            _this47._updateMaskFunc = updateMask;
            return _this47;
        }

        _createClass(PanoramaTiledSurface, [{
            key: 'add',
            value: function add(mesh) {
                this.mesh.add(mesh);
            }
            // addMask(mesh) { this._mask.add(mesh); }

        }, {
            key: '_createMesh',
            value: function _createMesh(geometry) {
                var box = new THREE.Box3();
                box.setFromPoints(geometry.vertices);

                var center = new THREE.Vector3();
                box.getCenter(center);
                box.min.sub(center);
                box.max.sub(center);
                if (box.min.y === 0) {
                    // floor plane
                    this.width = box.max.x - box.min.x;
                    this.height = box.max.z - box.min.z;
                } else if (box.min.x === 0 || box.min.z === 0) {
                    // wall plane
                    this.width = box.max.x - box.min.x || box.max.z - box.min.z;
                    this.height = box.max.y - box.min.y;
                } else {
                    // rotated wall plane
                    var point1 = new THREE.Vector3(box.max.x, 0, box.max.z);
                    var point2 = new THREE.Vector3(box.min.x, 0, box.min.z);
                    this.width = point1.distanceTo(point2);
                    this.height = box.max.y - box.min.y;
                }
                this.width *= this._sizeMultiplier;
                this.height *= this._sizeMultiplier;

                this.zeroPoint = new THREE.Vector2(-this.width / 2, this.height / 2);

                this.visibleMesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true, // to fix white area in backed panorama
                    opacity: 0, // to fix white area in backed panorama
                 }));
                this.visibleMesh.scale.multiplyScalar(10); // + 0.005
                this.visibleMesh.surface = this;

                this._invisibleMesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ color: 0xff5555,
                    colorWrite: false,
                    stencilWrite: true,
                    stencilRef: this._stencilRef,
                    stencilFunc: THREE.AlwaysStencilFunc,
                    stencilZPass: THREE.ReplaceStencilOp
                }));
                this.visibleMesh.scale.multiplyScalar(1.001); // to fix white area in backed panorama
                this._invisibleMesh.surface = this;
                this.visibleMesh.add(this._invisibleMesh)

                var surfaceGeometry = new THREE.PlaneBufferGeometry(this.width, this.height);
                var material = new THREE.PointsMaterial({ color: 0xffffff,
                    // colorWrite: false,
                    // stencilWrite: true,
                    // stencilRef: this._stencilRef,
                    // stencilFunc: THREE.AlwaysStencilFunc,
                    // stencilZPass: THREE.ReplaceStencilOp
                    // side: THREE.BackSide,
                    size: 0,
                 });
                this.mesh = new THREE.Mesh(surfaceGeometry, material);
                this._addMask();
                this._addBackLight();

                this._createBoundingBox();
                this.mesh.scale.multiplyScalar(1 / this._sizeMultiplier);
                // this.mesh.surface = this;
                this._move(center, geometry.faces[0].normal);
            }
        }, {
            key: '_addMask',
            value: function _addMask() {
                this.mask = this._invisibleMesh.clone();
                this.mask.material = MATT_MASK_MATERIAL;
                this.mask.layers.set(2);
                this.visibleMesh.add(this.mask);
            }
        }, {
            key: '_addBackLight',
            value: function _addBackLight() {
                this._backLight = this._invisibleMesh.clone();
                if (window.JsConstants.config.surfaceBacklight) {
                    const color = new THREE.Color(window.JsConstants.config.surfaceBacklightColor?.slice(0, 7) || 0x0082e8);
                    this._backLight.material = new THREE.MeshBasicMaterial({
                        color: color.getHex(),
                        transparent: true,
                        opacity: 0.3,
                        polygonOffset: true,
                        polygonOffsetFactor: -10
                    });
                }
                this._backLight.visible = false;
                this.visibleMesh.add(this._backLight);
            }
        }, {
            key: 'backLight',
            value: function backLight() {
                this._backLight.visible = true;
            }
        }, {
            key: 'hideBackLight',
            value: function hideBackLight() {
                this._backLight.visible = false;
            }
        }, {
            key: '_createBoundingBox',
            value: function _createBoundingBox() {
                this.boundingBox = new THREE.Box3();
                this.boundingBox.setFromObject(this.mesh);
                this.boundingBox.min.z = -this._sizeMultiplier * 0.02;
                this.boundingBox.max.z = this._sizeMultiplier * 0.02;
            }
        }, {
            key: '_move',
            value: function _move(center, normal) {
                this.mesh.lookAt(normal);
                this.mesh.position.copy(center);
                this.mesh.position.multiplyScalar(10);
                this.mesh.scale.multiplyScalar(10);
            }
        }, {
            key: 'setGroutColor',
            value: function setGroutColor(color) {
                _get(PanoramaTiledSurface.prototype.__proto__ || Object.getPrototypeOf(PanoramaTiledSurface.prototype), 'setGroutColor', this).call(this, color);

                this._update();
                // this._updateMask();
            }
        }, {
            key: 'setGroutSize',
            value: function setGroutSize(groutSize) {
                _get(PanoramaTiledSurface.prototype.__proto__ || Object.getPrototypeOf(PanoramaTiledSurface.prototype), 'setGroutSize', this).call(this, groutSize);

                this._update();
                this._updateMask();
            }
        }, {
            key: 'setFillType',
            value: function setFillType(value) {
                _get(PanoramaTiledSurface.prototype.__proto__ || Object.getPrototypeOf(PanoramaTiledSurface.prototype), 'setFillType', this).call(this, value);

                var drawEver = this.fillTypeIndex === 1 ? 0 : undefined; // Chess
                this._tiles.fill(drawEver);
                this._updateMask();
            }
        }, {
            key: 'setSkewSize',
            value: function setSkewSize(value) {
                _get(PanoramaTiledSurface.prototype.__proto__ || Object.getPrototypeOf(PanoramaTiledSurface.prototype), 'setSkewSize', this).call(this, value);

                this._tiles.fill();
                this._updateMask();
            }
        }, {
            key: 'rotate',
            value: function rotate(angle) {
                _get(PanoramaTiledSurface.prototype.__proto__ || Object.getPrototypeOf(PanoramaTiledSurface.prototype), 'rotate', this).call(this, angle);

                this.rotationRadians = THREE.MathUtils.degToRad(this.rotation);
                this._update();
                this._updateMask();
            }
        }, {
            key: 'setTile',
            value: function setTile(tile) {
                _get(PanoramaTiledSurface.prototype.__proto__ || Object.getPrototypeOf(PanoramaTiledSurface.prototype), 'setTile', this).call(this, tile);

                var drawEver = this.fillTypeIndex === 1 ? 0 : undefined; // Chess
                this._tiles.set(tile, drawEver);

                this.mask.material = tile.finish === 'glossy' ? GLOSSY_MASK_MATERIAL : MATT_MASK_MATERIAL;

                this._updateMask();
            }
        }, {
            key: 'setTile2',
            value: function setTile2(tile) {
                this._tiles2.set(tile, 1);
                // this._tiles2.fill(1);
                // this._updateMask();
            }
        }, {
            key: 'clearTile2',
            value: function clearTile2() {
                this._tiles2.clear();
                // this._updateMask();
            }
        }, {
            key: 'setFreeDesign',
            // todo fix private

            value: function setFreeDesign(value) {
                // this.freeDesign = Boolean(value);
                _get(PanoramaTiledSurface.prototype.__proto__ || Object.getPrototypeOf(PanoramaTiledSurface.prototype), 'setFreeDesign', this).call(this, value);

                this._freeDesignTiles.clear();
                this._updateMask();
            }
        }, {
            key: 'setFreeDesignTile',
            value: function setFreeDesignTile(tile) {
                this._freeDesignTiles.set(tile);
            }
        }, {
            key: 'rotateTile',
            value: function rotateTile(mesh) {
                var tileMesh = mesh && mesh.parent;
                if (tileMesh instanceof TileMesh) tileMesh.rotate();
            }
        }, {
            key: 'freeDesignClick',
            value: function freeDesignClick(intersects, point, isIntersect) {
                this._freeDesignTiles.click(intersects, point, isIntersect);
                this._updateMask();
            }

            /** @override */

        }, {
            key: '_getFreeDesignTilesSettings',
            value: function _getFreeDesignTilesSettings() {
                return this._freeDesignTiles.getSettings();
            }
        }, {
            key: '_restoreFreeDesignTiles',
            value: function _restoreFreeDesignTiles(tilesSettings) {
                this._freeDesignTiles.restore(tilesSettings);
                this._updateMask();
            }
        }, {
            key: 'clear',
            value: function clear() {
                this._tiles.removeAll();
                this._tiles2.clear();
                this._freeDesignTiles.clear();
                this._updateMask();
            }
        }, {
            key: '_update',
            value: function _update() {
                this._tiles.update();
                this._tiles2.update();
                this._freeDesignTiles.update();
                this._updateMask();
            }
        }, {
            key: '_updateMask',
            value: function _updateMask() {
                if (typeof this._updateMaskFunc === 'function') {
                    this._updateMaskFunc();
                }
            }
        }, {
            key: 'tile',
            get: function get() {
                return this._tiles.tile;
            },
            set: function set(paramNotUsed) {
                this._tiles.clear();
            }
        }, {
            key: 'tileIndex',
            get: function get() {
                return this._tiles.tileIndex;
            },
            set: function set(paramNotUsed) {
                this._tiles.clear();
            }
        }, {
            key: 'tile2',
            get: function get() {
                return this._tiles2.tile;
            },
            set: function set(paramNotUsed) {
                this._tiles2.clear();
            }
        }, {
            key: 'tile2Index',
            get: function get() {
                return this._tiles2.tileIndex;
            },
            set: function set(paramNotUsed) {
                this._tiles2.clear();
            }
        }, {
            key: 'freeDesignTile',
            get: function get() {
                return this._freeDesignTiles.tile;
            }
        }, {
            key: 'freeDesignTiles',
            get: function get() {
                return this._freeDesignTiles._tiles;
            }
        }]);

        return PanoramaTiledSurface;
    }(TiledSurface);

    /* global THREE */

    var PanoramaView = function (_View) {
        _inherits(PanoramaView, _View);

        function PanoramaView(containerId, roomData, roomSettings) {
            _classCallCheck(this, PanoramaView);

            var _this48 = _possibleConstructorReturn(this, (PanoramaView.__proto__ || Object.getPrototypeOf(PanoramaView)).call(this, containerId));

            _this48._roomData = roomData;
            _this48.surfaces = [];

            if ((typeof roomData === 'undefined' ? 'undefined' : _typeof(roomData)) === 'object') {
                _this48._createCubeView(roomData, function () {
                    var surfacesSettings = roomSettings && roomSettings.surfaces;
                    _this48._loadSurfaces(roomData.surfaces, surfacesSettings);
                });

                if (_isSavedRoom) {
                    _this48.canvas.addEventListener('click', function () {
                        _room._ui.switchTopPanel('productInfoPanel', 'none');
                    });
                } else {

                _this48.canvas.addEventListener('click', function (event) {
                    return _this48._onClick(event);
                });
                _this48.canvas.addEventListener('mousedown', function (event) {
                    return _this48._onMouseDown(event);
                });
                _this48.canvas.addEventListener('mousemove', function (event) {
                    return _this48._onMouseMove(event);
                });
                _this48.canvas.addEventListener('mouseout', function () {
                    return _this48._clearBackLight();
                });

                var btnDialogSaveSceneAsPanorama = document.getElementById('btnDialogSaveSceneAsPanorama');
                btnDialogSaveSceneAsPanorama.addEventListener('click', function (event) {
                    return _this48._saveSceneAsPanorama(event);
                });

                }
            }

            _this48._controls = new PanoramaControls(_this48._camera, _this48.canvas, function () {
                return _this48.render();
            });
            _this48._controls.fovMin = 30;
            _this48._controls.fovMax = 120;
            // this._controls.enableZoom = false;

            // this._vr = new VRMode(this._renderer, this._scene, this._controls);

            _this48.startAnimation();
            return _this48;
        }

        _createClass(PanoramaView, [{
            key: '_render',
            value: function _render() {
                // console.log('_render');

                // this._cubeView.updateMask(this._renderer, this._scene);

                // this._camera.layers.set(2);

                if (!this._cubeView) return;


                if (guiObj.positions && guiObj.positions.value && guiObj?.lightOptions) {
                    guiObj.positions.value.forEach((position, i) => {
                        if (guiObj.animate.value === true) {
                            const light = guiObj.lightOptions[i]
                            if (guiObj.animate && guiObj.animate.value) {
                                lights.angles[i] = lights.angles[i] > 2*Math.PI ? 0 : lights.angles[i] + light.speed
                            }
                            position.x = Math.sin(lights.angles[i] + light.angle) * light.distance
                            position.z = Math.cos(lights.angles[i] + light.angle) * light.distance
                        }
                    })
                }


                this._renderer.autoClear = true;
                this._renderer.render(this._scene, this._camera);
                this._renderer.autoClear = false;
                this._renderer.render(this._cubeView.scene, this._camera);
            }
        }, {
            key: '_updateMask',
            value: function _updateMask() {
                // console.log('_updateMask');
                this._cubeView.updateMask(this._renderer, this._scene);

                this.render();
            }
        }, {
            key: '_getTexturesFromAtlasFile',
            value: function _getTexturesFromAtlasFile(url, onLoad) {
                var _this49 = this;

                var tilesNum = 6;

                if (!url && typeof url !== 'string') return;

                var textures = [];
                for (var i = 0; i < tilesNum; i += 1) {
                    textures[i] = new THREE.Texture();
                }
                textures.forEach(function (texture, i) {
                    var canvas = document.createElement('canvas');
                    canvas.width = 128;
                    canvas.height = 128;
                    var context = canvas.getContext('2d');
                    context.rect(0, 0, 128, 128);
                    context.fillStyle = 'white';
                    context.fill()
                    texture.image = canvas;
                    texture.needsUpdate = true;
                });

                RoomLoadProgress.itemsTotal++
                var image = new Image();
                image.onload = function () {
                    var size = image.height;
                    if (onLoad) onLoad(size)

                    textures.forEach(function (texture, i) {
                        var canvas = document.createElement('canvas');
                        canvas.width = size;
                        canvas.height = size;
                        var context = canvas.getContext('2d');
                        context.drawImage(image, size * i, 0, size, size, 0, 0, size, size);
                        texture.image = canvas;
                        texture.needsUpdate = true;
                    });
                    _this49.render();

                    RoomLoadProgress.itemsLoaded++
                    RoomLoadProgress.progress(RoomLoadProgress.itemsLoaded, RoomLoadProgress.itemsTotal);
                    if (RoomLoadProgress.itemsLoaded === RoomLoadProgress.itemsTotal) {
                        RoomLoadProgress.end();
                    }
                };
                image.src = url;

                return textures;
            }
        }, {
            key: '_createCubeView',
            value: function _createCubeView(textureUrls, onCreated) {
                var _this = this;

                var textures

                function onTextureLoad (size) {
                    _this._cubeView = new CubeView(textures, size);
                    onCreated();
                    _this._scene.add(_this._cubeView.camera);
                    _this.render();
                }

                textures = {
                    images: this._getTexturesFromAtlasFile(textureUrls.image, onTextureLoad),
                    matt: this._getTexturesFromAtlasFile(textureUrls.shadow_matt),
                    glossy: this._getTexturesFromAtlasFile(textureUrls.shadow)
                };
                // this._cubeView = new CubeView(textures, 1024, this._scene);
                // this._scene.add(this._cubeView.camera);
                // this.render();
            }
        }, {
            key: '_loadSurface',
            value: function _loadSurface(surfaceData, surfaceSettings, i, stencilRef, scale) {
                var _this50 = this;

                new THREE.FileLoader().load(surfaceData.json, function (text) {
                    var json = {};
                    if (text.charAt(0) === '{') {
                        json = JSON.parse(text);
                    } else {
                        json = eval('(function(){var sam;' + text + ';return sam})()');
                    }





/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * https://github.com/mrdoob/three.js/blob/398c4f39ebdb8b23eefd4a7a5ec49ec0c96c7462/examples/jsm/loaders/deprecated/LegacyJSONLoader.js#L87
 */
    const {
        Color,
        Face3,
        Geometry,
        Math: _Math,
        Vector2,
        Vector3,
    } = THREE;

            function parseModel( json, geometry ) {

                function isBitSet( value, position ) {

                    return value & ( 1 << position );

                }

                var i, j, fi,

                    offset, zLength,

                    colorIndex, normalIndex, uvIndex, materialIndex,

                    type,
                    isQuad,
                    hasMaterial,
                    hasFaceVertexUv,
                    hasFaceNormal, hasFaceVertexNormal,
                    hasFaceColor, hasFaceVertexColor,

                    vertex, face, faceA, faceB, hex, normal,

                    uvLayer, uv, u, v,

                    faces = json.faces,
                    vertices = json.vertices,
                    normals = json.normals,
                    colors = json.colors,

                    scale = json.scale,

                    nUvLayers = 0;


                if ( json.uvs !== undefined ) {

                    // disregard empty arrays

                    for ( i = 0; i < json.uvs.length; i ++ ) {

                        if ( json.uvs[ i ].length ) nUvLayers ++;

                    }

                    for ( i = 0; i < nUvLayers; i ++ ) {

                        geometry.faceVertexUvs[ i ] = [];

                    }

                }

                offset = 0;
                zLength = vertices.length;

                while ( offset < zLength ) {

                    vertex = new Vector3();

                    vertex.x = vertices[ offset ++ ] * scale;
                    vertex.y = vertices[ offset ++ ] * scale;
                    vertex.z = vertices[ offset ++ ] * scale;

                    geometry.vertices.push( vertex );

                }

                offset = 0;
                zLength = faces.length;

                while ( offset < zLength ) {

                    type = faces[ offset ++ ];

                    isQuad = isBitSet( type, 0 );
                    hasMaterial = isBitSet( type, 1 );
                    hasFaceVertexUv = isBitSet( type, 3 );
                    hasFaceNormal = isBitSet( type, 4 );
                    hasFaceVertexNormal = isBitSet( type, 5 );
                    hasFaceColor = isBitSet( type, 6 );
                    hasFaceVertexColor = isBitSet( type, 7 );

                    // console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

                    if ( isQuad ) {

                        faceA = new Face3();
                        faceA.a = faces[ offset ];
                        faceA.b = faces[ offset + 1 ];
                        faceA.c = faces[ offset + 3 ];

                        faceB = new Face3();
                        faceB.a = faces[ offset + 1 ];
                        faceB.b = faces[ offset + 2 ];
                        faceB.c = faces[ offset + 3 ];

                        offset += 4;

                        if ( hasMaterial ) {

                            materialIndex = faces[ offset ++ ];
                            faceA.materialIndex = materialIndex;
                            faceB.materialIndex = materialIndex;

                        }

                        // to get face <=> uv index correspondence

                        fi = geometry.faces.length;

                        if ( hasFaceVertexUv ) {

                            for ( i = 0; i < nUvLayers; i ++ ) {

                                uvLayer = json.uvs[ i ];

                                geometry.faceVertexUvs[ i ][ fi ] = [];
                                geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

                                for ( j = 0; j < 4; j ++ ) {

                                    uvIndex = faces[ offset ++ ];

                                    u = uvLayer[ uvIndex * 2 ];
                                    v = uvLayer[ uvIndex * 2 + 1 ];

                                    uv = new Vector2( u, v );

                                    if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
                                    if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

                                }

                            }

                        }

                        if ( hasFaceNormal ) {

                            normalIndex = faces[ offset ++ ] * 3;

                            faceA.normal.set(
                                normals[ normalIndex ++ ],
                                normals[ normalIndex ++ ],
                                normals[ normalIndex ]
                            );

                            faceB.normal.copy( faceA.normal );

                        }

                        if ( hasFaceVertexNormal ) {

                            for ( i = 0; i < 4; i ++ ) {

                                normalIndex = faces[ offset ++ ] * 3;

                                normal = new Vector3(
                                    normals[ normalIndex ++ ],
                                    normals[ normalIndex ++ ],
                                    normals[ normalIndex ]
                                );


                                if ( i !== 2 ) faceA.vertexNormals.push( normal );
                                if ( i !== 0 ) faceB.vertexNormals.push( normal );

                            }

                        }


                        if ( hasFaceColor ) {

                            colorIndex = faces[ offset ++ ];
                            hex = colors[ colorIndex ];

                            faceA.color.setHex( hex );
                            faceB.color.setHex( hex );

                        }


                        if ( hasFaceVertexColor ) {

                            for ( i = 0; i < 4; i ++ ) {

                                colorIndex = faces[ offset ++ ];
                                hex = colors[ colorIndex ];

                                if ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );
                                if ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );

                            }

                        }

                        geometry.faces.push( faceA );
                        geometry.faces.push( faceB );

                    } else {

                        face = new Face3();
                        face.a = faces[ offset ++ ];
                        face.b = faces[ offset ++ ];
                        face.c = faces[ offset ++ ];

                        if ( hasMaterial ) {

                            materialIndex = faces[ offset ++ ];
                            face.materialIndex = materialIndex;

                        }

                        // to get face <=> uv index correspondence

                        fi = geometry.faces.length;

                        if ( hasFaceVertexUv ) {

                            for ( i = 0; i < nUvLayers; i ++ ) {

                                uvLayer = json.uvs[ i ];

                                geometry.faceVertexUvs[ i ][ fi ] = [];

                                for ( j = 0; j < 3; j ++ ) {

                                    uvIndex = faces[ offset ++ ];

                                    u = uvLayer[ uvIndex * 2 ];
                                    v = uvLayer[ uvIndex * 2 + 1 ];

                                    uv = new Vector2( u, v );

                                    geometry.faceVertexUvs[ i ][ fi ].push( uv );

                                }

                            }

                        }

                        if ( hasFaceNormal ) {

                            normalIndex = faces[ offset ++ ] * 3;

                            face.normal.set(
                                normals[ normalIndex ++ ],
                                normals[ normalIndex ++ ],
                                normals[ normalIndex ]
                            );

                        }

                        if ( hasFaceVertexNormal ) {

                            for ( i = 0; i < 3; i ++ ) {

                                normalIndex = faces[ offset ++ ] * 3;

                                normal = new Vector3(
                                    normals[ normalIndex ++ ],
                                    normals[ normalIndex ++ ],
                                    normals[ normalIndex ]
                                );

                                face.vertexNormals.push( normal );

                            }

                        }


                        if ( hasFaceColor ) {

                            colorIndex = faces[ offset ++ ];
                            face.color.setHex( colors[ colorIndex ] );

                        }


                        if ( hasFaceVertexColor ) {

                            for ( i = 0; i < 3; i ++ ) {

                                colorIndex = faces[ offset ++ ];
                                face.vertexColors.push( new Color( colors[ colorIndex ] ) );

                            }

                        }

                        geometry.faces.push( face );

                    }

                }

            }

            function parse( json ) {

                if ( json.data !== undefined ) {

                    // Geometry 4.0 spec
                    json = json.data;

                }

                if ( json.scale !== undefined ) {

                    json.scale = 1.0 / json.scale;

                } else {

                    json.scale = 1.0;

                }

                var geometry = new Geometry();

                parseModel( json, geometry );

                geometry.name = json.name;

                geometry.computeFaceNormals();
                geometry.computeBoundingSphere();

                return { geometry: geometry };

            };





                    // var geometry = new THREE.LegacyJSONLoader().parse(json).geometry;
                    var geometry = parse(json).geometry;
                    if (scale) geometry.scale(scale, scale, scale)

                    var surface = new PanoramaTiledSurface(surfaceData, geometry, function () {
                        return _this50._updateMask();
                    }, stencilRef);
                    surface.i = i;
                    _this50._scene.add(surface.mesh);
                    if (surface.visibleMesh) _this50._scene.add(surface.visibleMesh);
                    surface.restoreSettings(surfaceSettings);
                    // this.surfaces.push(surface);
                    _this50.surfaces[i] = surface;
                });
            }
        }, {
            key: '_loadSurfaces',
            value: function _loadSurfaces(surfacesData, surfacesSettings) {
                var _this51 = this;

                if (surfacesData && typeof surfacesData === 'string') {
                    var surfaces = JSON.parse(surfacesData);
                    if (Array.isArray(surfaces)) {
                        var scale = surfaces.find(surface => surface.scale)?.scale
                        surfaces.forEach(function (surface, i) {
                            var settings = Array.isArray(surfacesSettings) ? surfacesSettings[i] : undefined;
                            _this51._loadSurface(surface, settings, i, i+1, scale);
                        });
                        this._updateMask();
                    }
                }
            }
        }, {
            key: '_onMouseDown',
            value: function _onMouseDown(event) {
                this._MouseDownOffsetX = event.offsetX;
                this._MouseDownOffsetY = event.offsetY;
            }
        }, {
            key: '_onClick',
            value: function _onClick(event) {
                var _this52 = this;

                if (this._MouseDownOffsetX !== event.offsetX && this._MouseDownOffsetY !== event.offsetY) return;

                var intersects = this.getIntersects(event);

                intersects.some(function (intersect) {
                    if (intersect.object.surface instanceof PanoramaTiledSurface) {
                        _this52._surface = intersect.object.surface;
                        _this52._surface.hideBackLight();

                        var rotate = document.getElementById('topPanelCheckFreeDesignRotate').checked;

                        if (_this52._surface.freeDesign) {
                            var tileIntersects = _this52.getIntersects(event, _this52._surface.freeDesignTiles, true);
                            if (rotate && tileIntersects.length > 0) {
                                _this52._surface.rotateTile(tileIntersects[0].object);
                            } else {
                                _this52._surface.freeDesignClick(tileIntersects, intersect.point, function (objects) {
                                    return _this52.isIntersect(objects);
                                });
                            }

                            _this52.render();
                        } else if (rotate) {
                            var _tileIntersects = _this52.getIntersects(event, _this52._surface.mesh.children, true);
                            if (_tileIntersects.length > 0) {
                                _this52._surface.rotateTile(_tileIntersects[0].object);

                                _this52.render();
                            }
                        }

                        if (typeof _this52.onSurfaceClick === 'function') {
                            _this52.onSurfaceClick(_this52._surface);
                        }
                        return true;
                    }
                });
            }
        }, {
            key: '_onMouseMove',
            value: function _onMouseMove(event) {
                var _this53 = this;

                var intersects = this.getIntersects(event);
                var mouseOverSurface = intersects.some(function (intersect) {
                    if (intersect.object.surface instanceof PanoramaTiledSurface) {
                        if (_this53._backLightedSurface !== intersect.object.surface) {
                            _this53._clearBackLight();
                            _this53._backLightedSurface = intersect.object.surface;
                            _this53._backLightedSurface.backLight();
                        }
                        return true;
                    }
                });
                if (!mouseOverSurface) this._clearBackLight();
            }
        }, {
            key: '_clearBackLight',
            value: function _clearBackLight() {
                if (this._backLightedSurface) {
                    this._backLightedSurface.hideBackLight();
                    this._backLightedSurface = undefined;
                }
            }
        }, {
            key: 'getRoomSettings',
            value: function getRoomSettings() {
                return {
                    // ceilingColor: room.ceilingColor,
                    surfaces: this.surfaces.map(function (surface) {
                        return surface.getSettings();
                    })
                };
            }

            // vrMode() {
            //     this._vr.enable();
            // }

            // vrModeDisable() {
            //     this._vr.disable();
            // }

        }, {
            key: '_saveSceneAsPanorama',
            value: function _saveSceneAsPanorama(even) {
                var saveImage = (x, y, z) => {
                    this._camera.lookAt(x, y, z);
                    this._render();

                    var imageCanvas = document.createElement('canvas');
                    imageCanvas.width = this.canvas.width;
                    imageCanvas.height = this.canvas.height;

                    var imageCanvasContext = imageCanvas.getContext('2d');
                    imageCanvasContext.drawImage(this.canvas, 0, 0, this.canvas.width, this.canvas.height);

                    return imageCanvas.toDataURL('image/jpeg');
                }

                this.stopAnimation();

                var rotation = this._camera.rotation.clone();

                this._camera.aspect = 1;
                this._camera.fov = 90;
                this._camera.updateProjectionMatrix();

                this._renderer.setSize(2048, 2048);


                $('#dialogSaveModalBox').modal('hide');

                var sides = [
                    saveImage(0, 0, -1),
                    saveImage(1, 0, 0),
                    saveImage(0, 0, 1),
                    saveImage(-1, 0, 0),
                    saveImage(0, 1, 0),
                    saveImage(0, -1, 0),
                ];

                this._camera.rotation.copy(rotation);

                this._camera.aspect = window.innerWidth / window.innerHeight;
                this._camera.fov = 75;
                this._camera.updateProjectionMatrix();

                this._renderer.setSize(window.innerWidth, window.innerHeight);

                this._render();
                this.startAnimation();

                var roomSettings = this.getRoomSettings()
                var products = [...new Set(roomSettings?.surfaces?.map(surface => [surface.tileId, surface.tile2Id, ...(surface.freeDesignTiles?.map(tile => tile.id) || [])].filter(item => item)).flat())]

                $.ajax({
                    method: 'POST',
                    url: '/userRoom/save',
                    dataType: 'json',
                    data: {
                        '_token': $('meta[name=csrf-token]').attr('content'),
                        'roomId': this._roomData.id,
                        'url': this._roomData.savedUrl,
                        'engine': 'panorama',
                        'image': makeIcon(this._renderer.domElement, 256),
                        'roomSettings': JSON.stringify({ products: products }),
                        'note': 'backed',
                        'sides': sides,
                    },
                    success: function success(response) {
                        if (response.state === 'success') {
                            $('#savedRoomLogin').hide();

                            $('#dialogSavedRoomUrlInput').val(window.location.origin + response.fullUrl);

                            if (!response.loggedIn) {
                                $('#savedRoomLogin').show();
                            }

                            $('#savedRoomGoToUrl').attr('href', window.location.origin + response.fullUrl);
                            $('#savedRoomGoToUrl').attr('target', '_blank');
                            $('#savedRoomGoToUrl').show();

                            $('#dialogSavedRoomUrl').modal('show');
                        } else {
                            window.$('#dangerAlertBox').html('<strong>Error!</strong> The problem in saving room.');
                            window.$('#dangerAlertBox').fadeIn();
                        }
                    },
                    error: function error() {
                        window.$('#dangerAlertBox').html('<strong>Error!</strong> The problem in saving room.');
                        window.$('#dangerAlertBox').fadeIn();
                    },
                    complete: function complete() {
                        RoomLoadProgress.end();
                    }
                });
                RoomLoadProgress.start();
            }
        }]);

        return PanoramaView;
    }(View);

    var PanoramaRoom = function (_Room) {
        _inherits(PanoramaRoom, _Room);

        function PanoramaRoom(data) {
            _classCallCheck(this, PanoramaRoom);

            // todo fix
            var _this54 = _possibleConstructorReturn(this, (PanoramaRoom.__proto__ || Object.getPrototypeOf(PanoramaRoom)).call(this, data));

            // RoomLoadProgress.end();
            return _this54;
        }

        /** @override */


        _createClass(PanoramaRoom, [{
            key: '_createView',
            value: function _createView(data) {
                var _this55 = this;

                this._view = new PanoramaView('container', data.roomData, data.roomSettings);
                this._view.onSurfaceClick = function (surface) {
                    return _this55._onSurfaceClick(surface);
                };

                this.tiledSurfaces = this._view.surfaces;

                this.canvas = this._view.canvas;
            }

            /** @override */

        }, {
            key: '_save',
            value: function _save() {
                var settings = this._view.getRoomSettings();
                userRoom(this, settings, 'panorama', this._ui);
            }
        }]);

        return PanoramaRoom;
    }(Room);

    window.addEventListener('load', function () {
        new Loader().loadRoom('/get/panorama/', function (data) {
            return new PanoramaRoom(data);
        });
    });
})();
