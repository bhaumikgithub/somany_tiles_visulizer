"use strict";

var ws = new WebSocket("wss://37.27.48.177:8061");

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LegacyJSONLoader = (function () {
  function LegacyJSONLoader(manager) {
    if (typeof manager === "boolean") {
      console.warn(
        "THREE.JSONLoader: showStatus parameter has been removed from constructor."
      );
      manager = undefined;
    }

    THREE.Loader.call(this, manager);

    this.withCredentials = false;
  }

  LegacyJSONLoader.prototype = Object.assign(
    Object.create(THREE.Loader.prototype),
    {
      constructor: LegacyJSONLoader,

      load: function (url, onLoad, onProgress, onError) {
        var scope = this;

        var path =
          this.path === "" ? THREE.LoaderUtils.extractUrlBase(url) : this.path;

        var loader = new THREE.FileLoader(this.manager);
        loader.setPath(this.path);
        loader.setWithCredentials(this.withCredentials);
        loader.load(
          url,
          function (text) {
            var json = JSON.parse(text);
            var metadata = json.metadata;

            if (metadata !== undefined) {
              var type = metadata.type;

              if (type !== undefined) {
                if (type.toLowerCase() === "object") {
                  console.error(
                    "THREE.JSONLoader: " +
                      url +
                      " should be loaded with THREE.ObjectLoader instead."
                  );
                  return;
                }
              }
            }

            var object = scope.parse(json, path);
            onLoad(object.geometry, object.materials);
          },
          onProgress,
          onError
        );
      },

      parse: (function () {
        var _BlendingMode = {
          NoBlending: THREE.NoBlending,
          NormalBlending: THREE.NormalBlending,
          AdditiveBlending: THREE.AdditiveBlending,
          SubtractiveBlending: THREE.SubtractiveBlending,
          MultiplyBlending: THREE.MultiplyBlending,
          CustomBlending: THREE.CustomBlending,
        };

        var _color = new THREE.Color();
        var _textureLoader = new THREE.TextureLoader();
        var _materialLoader = new THREE.MaterialLoader();

        function initMaterials(materials, texturePath, crossOrigin, manager) {
          var array = [];

          for (var i = 0; i < materials.length; ++i) {
            array[i] = createMaterial(
              materials[i],
              texturePath,
              crossOrigin,
              manager
            );
          }

          return array;
        }

        function createMaterial(m, texturePath, crossOrigin, manager) {
          // convert from old material format
          // console.log("material:", m);
          var textures = {};

          //

          var json = {
            uuid: THREE.Math.generateUUID(),
            type: "MeshLambertMaterial",
          };

          for (var name in m) {
            var value = m[name];

            switch (name) {
              case "DbgColor":
              case "DbgIndex":
              case "opticalDensity":
              case "illumination":
                break;
              case "DbgName":
                json.name = value;
                break;
              case "blending":
                json.blending = _BlendingMode[value];
                break;
              case "colorAmbient":
              case "mapAmbient":
                console.warn(
                  "THREE.LegacyJSONLoader.createMaterial:",
                  name,
                  "is no longer supported."
                );
                break;
              case "colorDiffuse":
                json.color = _color.fromArray(value).getHex();
                break;
              case "colorSpecular":
                json.specular = _color.fromArray(value).getHex();
                break;
              case "colorEmissive":
                json.emissive = _color.fromArray(value).getHex();
                break;
              case "specularCoef":
                json.shininess = value;
                break;
              case "shading":
                if (value.toLowerCase() === "basic")
                  json.type = "MeshBasicMaterial";
                if (value.toLowerCase() === "phong")
                  json.type = "MeshPhongMaterial";
                if (value.toLowerCase() === "standard")
                  json.type = "MeshStandardMaterial";
                break;
              case "mapDiffuse":
                json.map = loadTexture(
                  value,
                  m.mapDiffuseRepeat,
                  m.mapDiffuseOffset,
                  m.mapDiffuseWrap,
                  m.mapDiffuseAnisotropy,
                  textures,
                  texturePath,
                  crossOrigin,
                  manager
                );
                break;
              case "mapDiffuseRepeat":
              case "mapDiffuseOffset":
              case "mapDiffuseWrap":
              case "mapDiffuseAnisotropy":
                break;
              case "mapEmissive":
                json.emissiveMap = loadTexture(
                  value,
                  m.mapEmissiveRepeat,
                  m.mapEmissiveOffset,
                  m.mapEmissiveWrap,
                  m.mapEmissiveAnisotropy,
                  textures,
                  texturePath,
                  crossOrigin,
                  manager
                );
                break;
              case "mapEmissiveRepeat":
              case "mapEmissiveOffset":
              case "mapEmissiveWrap":
              case "mapEmissiveAnisotropy":
                break;
              case "mapLight":
                json.lightMap = loadTexture(
                  value,
                  m.mapLightRepeat,
                  m.mapLightOffset,
                  m.mapLightWrap,
                  m.mapLightAnisotropy,
                  textures,
                  texturePath,
                  crossOrigin,
                  manager
                );
                break;
              case "mapLightRepeat":
              case "mapLightOffset":
              case "mapLightWrap":
              case "mapLightAnisotropy":
                break;
              case "mapAO":
                json.aoMap = loadTexture(
                  value,
                  m.mapAORepeat,
                  m.mapAOOffset,
                  m.mapAOWrap,
                  m.mapAOAnisotropy,
                  textures,
                  texturePath,
                  crossOrigin,
                  manager
                );
                break;
              case "mapAORepeat":
              case "mapAOOffset":
              case "mapAOWrap":
              case "mapAOAnisotropy":
                break;
              case "mapBump":
                json.bumpMap = loadTexture(
                  value,
                  m.mapBumpRepeat,
                  m.mapBumpOffset,
                  m.mapBumpWrap,
                  m.mapBumpAnisotropy,
                  textures,
                  texturePath,
                  crossOrigin,
                  manager
                );
                break;
              case "mapBumpScale":
                json.bumpScale = value;
                break;
              case "mapBumpRepeat":
              case "mapBumpOffset":
              case "mapBumpWrap":
              case "mapBumpAnisotropy":
                break;
              case "mapNormal":
                json.normalMap = loadTexture(
                  value,
                  m.mapNormalRepeat,
                  m.mapNormalOffset,
                  m.mapNormalWrap,
                  m.mapNormalAnisotropy,
                  textures,
                  texturePath,
                  crossOrigin,
                  manager
                );
                break;
              case "mapNormalFactor":
                json.normalScale = value;
                break;
              case "mapNormalRepeat":
              case "mapNormalOffset":
              case "mapNormalWrap":
              case "mapNormalAnisotropy":
                break;
              case "mapSpecular":
                json.specularMap = loadTexture(
                  value,
                  m.mapSpecularRepeat,
                  m.mapSpecularOffset,
                  m.mapSpecularWrap,
                  m.mapSpecularAnisotropy,
                  textures,
                  texturePath,
                  crossOrigin,
                  manager
                );
                break;
              case "mapSpecularRepeat":
              case "mapSpecularOffset":
              case "mapSpecularWrap":
              case "mapSpecularAnisotropy":
                break;
              case "mapMetalness":
                json.metalnessMap = loadTexture(
                  value,
                  m.mapMetalnessRepeat,
                  m.mapMetalnessOffset,
                  m.mapMetalnessWrap,
                  m.mapMetalnessAnisotropy,
                  textures,
                  texturePath,
                  crossOrigin,
                  manager
                );
                break;
              case "mapMetalnessRepeat":
              case "mapMetalnessOffset":
              case "mapMetalnessWrap":
              case "mapMetalnessAnisotropy":
                break;
              case "mapRoughness":
                json.roughnessMap = loadTexture(
                  value,
                  m.mapRoughnessRepeat,
                  m.mapRoughnessOffset,
                  m.mapRoughnessWrap,
                  m.mapRoughnessAnisotropy,
                  textures,
                  texturePath,
                  crossOrigin,
                  manager
                );
                break;
              case "mapRoughnessRepeat":
              case "mapRoughnessOffset":
              case "mapRoughnessWrap":
              case "mapRoughnessAnisotropy":
                break;
              case "mapAlpha":
                json.alphaMap = loadTexture(
                  value,
                  m.mapAlphaRepeat,
                  m.mapAlphaOffset,
                  m.mapAlphaWrap,
                  m.mapAlphaAnisotropy,
                  textures,
                  texturePath,
                  crossOrigin,
                  manager
                );
                break;
              case "mapAlphaRepeat":
              case "mapAlphaOffset":
              case "mapAlphaWrap":
              case "mapAlphaAnisotropy":
                break;
              case "flipSided":
                json.side = THREE.BackSide;
                break;
              case "doubleSided":
                json.side = THREE.DoubleSide;
                break;
              case "transparency":
                console.warn(
                  "THREE.LegacyJSONLoader.createMaterial: transparency has been renamed to opacity"
                );
                json.opacity = value;
                break;
              case "depthTest":
              case "depthWrite":
              case "colorWrite":
              case "opacity":
              case "reflectivity":
              case "transparent":
              case "visible":
              case "wireframe":
                json[name] = value;
                break;
              case "vertexColors":
                if (value === true) json.vertexColors = THREE.VertexColors;
                if (value === "face") json.vertexColors = THREE.FaceColors;
                break;
              default:
                console.error(
                  "THREE.LegacyJSONLoader.createMaterial: Unsupported",
                  name,
                  value
                );
                break;
            }
          }

          if (json.type === "MeshBasicMaterial") delete json.emissive;
          if (json.type !== "MeshPhongMaterial") delete json.specular;

          if (json.opacity < 1) json.transparent = true;

          _materialLoader.setTextures(textures);

          return _materialLoader.parse(json);
        }

        function loadTexture(
          path,
          repeat,
          offset,
          wrap,
          anisotropy,
          textures,
          texturePath,
          crossOrigin,
          manager
        ) {
          var fullPath = texturePath + path;
          var loader = manager.getHandler(fullPath);

          var texture;

          if (loader !== null) {
            texture = loader.load(fullPath);
          } else {
            _textureLoader.setCrossOrigin(crossOrigin);
            texture = _textureLoader.load(fullPath);
          }

          if (repeat !== undefined) {
            texture.repeat.fromArray(repeat);

            if (repeat[0] !== 1) texture.wrapS = THREE.RepeatWrapping;
            if (repeat[1] !== 1) texture.wrapT = THREE.RepeatWrapping;
          }

          if (offset !== undefined) {
            texture.offset.fromArray(offset);
          }

          if (wrap !== undefined) {
            if (wrap[0] === "repeat") texture.wrapS = THREE.RepeatWrapping;
            if (wrap[0] === "mirror")
              texture.wrapS = THREE.MirroredRepeatWrapping;

            if (wrap[1] === "repeat") texture.wrapT = THREE.RepeatWrapping;
            if (wrap[1] === "mirror")
              texture.wrapT = THREE.MirroredRepeatWrapping;
          }

          if (anisotropy !== undefined) {
            texture.anisotropy = anisotropy;
          }

          var uuid = THREE.Math.generateUUID();

          textures[uuid] = texture;

          return uuid;
        }

        function parseModel(json, geometry) {
          function isBitSet(value, position) {
            return value & (1 << position);
          }

          var i,
            j,
            fi,
            offset,
            zLength,
            colorIndex,
            normalIndex,
            uvIndex,
            materialIndex,
            type,
            isQuad,
            hasMaterial,
            hasFaceVertexUv,
            hasFaceNormal,
            hasFaceVertexNormal,
            hasFaceColor,
            hasFaceVertexColor,
            vertex,
            face,
            faceA,
            faceB,
            hex,
            normal,
            uvLayer,
            uv,
            u,
            v,
            faces = json.faces,
            vertices = json.vertices,
            normals = json.normals,
            colors = json.colors,
            scale = json.scale,
            nUvLayers = 0;

          if (json.uvs !== undefined) {
            // disregard empty arrays

            for (i = 0; i < json.uvs.length; i++) {
              if (json.uvs[i].length) nUvLayers++;
            }

            for (i = 0; i < nUvLayers; i++) {
              geometry.faceVertexUvs[i] = [];
            }
          }

          offset = 0;
          zLength = vertices.length;

          while (offset < zLength) {
            vertex = new THREE.Vector3();

            vertex.x = vertices[offset++] * scale;
            vertex.y = vertices[offset++] * scale;
            vertex.z = vertices[offset++] * scale;

            geometry.vertices.push(vertex);
          }

          offset = 0;
          zLength = faces.length;

          while (offset < zLength) {
            type = faces[offset++];

            isQuad = isBitSet(type, 0);
            hasMaterial = isBitSet(type, 1);
            hasFaceVertexUv = isBitSet(type, 3);
            hasFaceNormal = isBitSet(type, 4);
            hasFaceVertexNormal = isBitSet(type, 5);
            hasFaceColor = isBitSet(type, 6);
            hasFaceVertexColor = isBitSet(type, 7);

            if (isQuad) {
              faceA = new THREE.Face3();
              faceA.a = faces[offset];
              faceA.b = faces[offset + 1];
              faceA.c = faces[offset + 3];

              faceB = new THREE.Face3();
              faceB.a = faces[offset + 1];
              faceB.b = faces[offset + 2];
              faceB.c = faces[offset + 3];

              offset += 4;

              if (hasMaterial) {
                materialIndex = faces[offset++];
                faceA.materialIndex = materialIndex;
                faceB.materialIndex = materialIndex;
              }

              // to get face <=> uv index correspondence

              fi = geometry.faces.length;

              if (hasFaceVertexUv) {
                for (i = 0; i < nUvLayers; i++) {
                  uvLayer = json.uvs[i];

                  geometry.faceVertexUvs[i][fi] = [];
                  geometry.faceVertexUvs[i][fi + 1] = [];

                  for (j = 0; j < 4; j++) {
                    uvIndex = faces[offset++];

                    u = uvLayer[uvIndex * 2];
                    v = uvLayer[uvIndex * 2 + 1];

                    uv = new THREE.Vector2(u, v);

                    if (j !== 2) geometry.faceVertexUvs[i][fi].push(uv);
                    if (j !== 0) geometry.faceVertexUvs[i][fi + 1].push(uv);
                  }
                }
              }

              if (hasFaceNormal) {
                normalIndex = faces[offset++] * 3;

                faceA.normal.set(
                  normals[normalIndex++],
                  normals[normalIndex++],
                  normals[normalIndex]
                );

                faceB.normal.copy(faceA.normal);
              }

              if (hasFaceVertexNormal) {
                for (i = 0; i < 4; i++) {
                  normalIndex = faces[offset++] * 3;

                  normal = new THREE.Vector3(
                    normals[normalIndex++],
                    normals[normalIndex++],
                    normals[normalIndex]
                  );

                  if (i !== 2) faceA.vertexNormals.push(normal);
                  if (i !== 0) faceB.vertexNormals.push(normal);
                }
              }

              if (hasFaceColor) {
                colorIndex = faces[offset++];
                hex = colors[colorIndex];

                faceA.color.setHex(hex);
                faceB.color.setHex(hex);
              }

              if (hasFaceVertexColor) {
                for (i = 0; i < 4; i++) {
                  colorIndex = faces[offset++];
                  hex = colors[colorIndex];

                  if (i !== 2) faceA.vertexColors.push(new THREE.Color(hex));
                  if (i !== 0) faceB.vertexColors.push(new THREE.Color(hex));
                }
              }

              geometry.faces.push(faceA);
              geometry.faces.push(faceB);
            } else {
              face = new THREE.Face3();
              face.a = faces[offset++];
              face.b = faces[offset++];
              face.c = faces[offset++];

              if (hasMaterial) {
                materialIndex = faces[offset++];
                face.materialIndex = materialIndex;
              }

              // to get face <=> uv index correspondence

              fi = geometry.faces.length;

              if (hasFaceVertexUv) {
                for (i = 0; i < nUvLayers; i++) {
                  uvLayer = json.uvs[i];

                  geometry.faceVertexUvs[i][fi] = [];

                  for (j = 0; j < 3; j++) {
                    uvIndex = faces[offset++];

                    u = uvLayer[uvIndex * 2];
                    v = uvLayer[uvIndex * 2 + 1];

                    uv = new THREE.Vector2(u, v);

                    geometry.faceVertexUvs[i][fi].push(uv);
                  }
                }
              }

              if (hasFaceNormal) {
                normalIndex = faces[offset++] * 3;

                face.normal.set(
                  normals[normalIndex++],
                  normals[normalIndex++],
                  normals[normalIndex]
                );
              }

              if (hasFaceVertexNormal) {
                for (i = 0; i < 3; i++) {
                  normalIndex = faces[offset++] * 3;

                  normal = new THREE.Vector3(
                    normals[normalIndex++],
                    normals[normalIndex++],
                    normals[normalIndex]
                  );

                  face.vertexNormals.push(normal);
                }
              }

              if (hasFaceColor) {
                colorIndex = faces[offset++];
                face.color.setHex(colors[colorIndex]);
              }

              if (hasFaceVertexColor) {
                for (i = 0; i < 3; i++) {
                  colorIndex = faces[offset++];
                  face.vertexColors.push(new THREE.Color(colors[colorIndex]));
                }
              }

              geometry.faces.push(face);
            }
          }
        }

        function parseSkin(json, geometry) {
          var influencesPerVertex =
            json.influencesPerVertex !== undefined
              ? json.influencesPerVertex
              : 2;

          if (json.skinWeights) {
            for (
              var i = 0, l = json.skinWeights.length;
              i < l;
              i += influencesPerVertex
            ) {
              var x = json.skinWeights[i];
              var y = influencesPerVertex > 1 ? json.skinWeights[i + 1] : 0;
              var z = influencesPerVertex > 2 ? json.skinWeights[i + 2] : 0;
              var w = influencesPerVertex > 3 ? json.skinWeights[i + 3] : 0;

              geometry.skinWeights.push(new THREE.Vector4(x, y, z, w));
            }
          }

          if (json.skinIndices) {
            for (
              var i = 0, l = json.skinIndices.length;
              i < l;
              i += influencesPerVertex
            ) {
              var a = json.skinIndices[i];
              var b = influencesPerVertex > 1 ? json.skinIndices[i + 1] : 0;
              var c = influencesPerVertex > 2 ? json.skinIndices[i + 2] : 0;
              var d = influencesPerVertex > 3 ? json.skinIndices[i + 3] : 0;

              geometry.skinIndices.push(new THREE.Vector4(a, b, c, d));
            }
          }

          geometry.bones = json.bones;

          if (
            geometry.bones &&
            geometry.bones.length > 0 &&
            (geometry.skinWeights.length !== geometry.skinIndices.length ||
              geometry.skinIndices.length !== geometry.vertices.length)
          ) {
            console.warn(
              "When skinning, number of vertices (" +
                geometry.vertices.length +
                "), skinIndices (" +
                geometry.skinIndices.length +
                "), and skinWeights (" +
                geometry.skinWeights.length +
                ") should match."
            );
          }
        }

        function parseMorphing(json, geometry) {
          var scale = json.scale;

          if (json.morphTargets !== undefined) {
            for (var i = 0, l = json.morphTargets.length; i < l; i++) {
              geometry.morphTargets[i] = {};
              geometry.morphTargets[i].name = json.morphTargets[i].name;
              geometry.morphTargets[i].vertices = [];

              var dstVertices = geometry.morphTargets[i].vertices;
              var srcVertices = json.morphTargets[i].vertices;

              for (var v = 0, vl = srcVertices.length; v < vl; v += 3) {
                var vertex = new THREE.Vector3();
                vertex.x = srcVertices[v] * scale;
                vertex.y = srcVertices[v + 1] * scale;
                vertex.z = srcVertices[v + 2] * scale;

                dstVertices.push(vertex);
              }
            }
          }

          if (json.morphColors !== undefined && json.morphColors.length > 0) {
            console.warn(
              'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.'
            );

            var faces = geometry.faces;
            var morphColors = json.morphColors[0].colors;

            for (var i = 0, l = faces.length; i < l; i++) {
              faces[i].color.fromArray(morphColors, i * 3);
            }
          }
        }

        function parseAnimations(json, geometry) {
          var outputAnimations = [];

          // parse old style Bone/Hierarchy animations
          var animations = [];

          if (json.animation !== undefined) {
            animations.push(json.animation);
          }

          if (json.animations !== undefined) {
            if (json.animations.length) {
              animations = animations.concat(json.animations);
            } else {
              animations.push(json.animations);
            }
          }

          for (var i = 0; i < animations.length; i++) {
            var clip = THREE.AnimationClip.parseAnimation(
              animations[i],
              geometry.bones
            );
            if (clip) outputAnimations.push(clip);
          }

          // parse implicit morph animations
          if (geometry.morphTargets) {
            // TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
            var morphAnimationClips =
              THREE.AnimationClip.CreateClipsFromMorphTargetSequences(
                geometry.morphTargets,
                10
              );
            outputAnimations = outputAnimations.concat(morphAnimationClips);
          }

          if (outputAnimations.length > 0)
            geometry.animations = outputAnimations;
        }

        return function parse(json, path) {
          if (json.data !== undefined) {
            // Geometry 4.0 spec
            json = json.data;
          }

          if (json.scale !== undefined) {
            json.scale = 1.0 / json.scale;
          } else {
            json.scale = 1.0;
          }

          var geometry = new THREE.Geometry();

          parseModel(json, geometry);
          parseSkin(json, geometry);
          parseMorphing(json, geometry);
          parseAnimations(json, geometry);

          geometry.computeFaceNormals();
          geometry.computeBoundingSphere();

          if (json.materials === undefined || json.materials.length === 0) {
            return { geometry: geometry };
          } else {
            var materials = initMaterials(
              json.materials,
              this.resourcePath || path,
              this.crossOrigin,
              this.manager
            );

            return { geometry: geometry, materials: materials };
          }
        };
      })(),
    }
  );

  return LegacyJSONLoader;
})();

var _typeof =
  typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
    ? function (obj) {
        return typeof obj;
      }
    : function (obj) {
        return obj &&
          typeof Symbol === "function" &&
          obj.constructor === Symbol &&
          obj !== Symbol.prototype
          ? "symbol"
          : typeof obj;
      };

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);
  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);
    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return getter.call(receiver);
  }
};

var _createClass = (function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
})();

function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  } else {
    return Array.from(arr);
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  }
  return call && (typeof call === "object" || typeof call === "function")
    ? call
    : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError(
      "Super expression must either be null or a function, not " +
        typeof superClass
    );
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true,
    },
  });
  if (superClass)
    Object.setPrototypeOf
      ? Object.setPrototypeOf(subClass, superClass)
      : (subClass.__proto__ = superClass);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

(function () {
  "use strict";

  /**

	 * DressingRoom App

	 *

	 * by Tracing Idea

	 *

	 * @author ilya

	 *

	 * Version 2.0.1.1

	 *

	 * Copyright (c) 2017

	 *

	 **/

  // todo optimize

  var Locale = {
    shapes: {
      square: "Square",

      rectangle: "Rectangle",

      diamond: "Diamond",

      hexagon: "Hexagonal",
    },
  };

  var locale = (window.JsConstants && window.JsConstants.lang) || {};

  Object.assign(Locale, locale.default); // todo fix

  function replace(text, inlineText) {
    if (typeof inlineText !== "undefined") {
      if (text.indexOf("{s}") !== -1) {
        return text.replace("{s}", inlineText);
      }

      return text + ": " + inlineText;
    }

    return text;
  }

  Locale.lang = function (text, inlineText) {
    if (!text) return "";

    if (locale.current) {
      var translation = locale.current[text];

      if (typeof translation === "string")
        return replace(translation, inlineText);
    }

    if (locale.default) {
      var defaultText = locale.default[text];

      if (typeof defaultText === "string")
        return replace(defaultText, inlineText);
    }

    return replace(text, inlineText);
  };

  function UI(room) {
    this.tiles = [];

    var _this = this;

    var topPanelVisible = false;

    /**

		 * Show alerts for user

		 *

		 * @method showAlert

		 * @param {string} message

		 * @param {?string} type - 'warning', 'success', 'danger', 'error' or 'info'

		 */

    this.showAlert = function (message, type) {
      if (message) {
        switch (type) {
          case "warning":
            this.alertWarning(message);

            break;

          case "success":
            this.alertSuccess(message);

            break;

          case "danger":
            this.alertDanger(message);

            break;

          case "error":
            this.alertError(message);

            break;

          default:
            this.alert(message);

            break;
        }
      }
    };

    this.alertWarning = function (message) {
      window.$("#warningAlertBox").html("<strong>Warning!</strong> " + message);

      window.$("#warningAlertBox").fadeIn();
    };

    this.alertSuccess = function (message) {
      window.$("#successAlertBox").html("<strong>Success!</strong> " + message);

      window.$("#successAlertBox").fadeIn();
    };

    this.alertDanger = function (message) {
      window.$("#dangerAlertBox").html("<strong>Danger!</strong> " + message);

      window.$("#dangerAlertBox").fadeIn();
    };

    this.alertError = function (message) {
      window.$("#dangerAlertBox").html("<strong>Error!</strong> " + message);

      window.$("#dangerAlertBox").fadeIn();
    };

    this.alert = function (message) {
      window.$("#infoAlertBox").html("<strong>Info!</strong> " + message);

      window.$("#infoAlertBox").fadeIn();
    };

    this.isMobileDevice = function () {
      return UI.isMobileDevice();
    };

    /**

		 * Show or hide tiles panel

		 *

		 * @method topPanelSlide

		 * @param {?boolean} show - true to show panel, false|undefined to hide it

		 */

    this.topPanelSlide = function (show) {
      if (show === true) {
        if (!topPanelVisible) {
          topPanelVisible = true;

          window.$("#topPanel").animate({ right: 0 }, "fast");

          window
            .$("#topPanelHideIcon")
            .removeClass("glyphicon-menu-left")
            .addClass("glyphicon-menu-right");
        }
      } else if (topPanelVisible) {
        topPanelVisible = false;

        var width = window.$("#topPanel").width();

        $("#topPanel").animate({ right: -width - 10 }, "fast");

        window
          .$("#topPanelHideIcon")
          .removeClass("glyphicon-menu-right")
          .addClass("glyphicon-menu-left");
      }
    };

    this.topPanelToggle = function () {
      _this.topPanelSlide(!topPanelVisible);
    };

    this.topPanelHide = function () {
      _this.topPanelSlide(false);
    };

    this.topPanelShow = function () {
      _this.topPanelSlide(true);
    };

    /**

		 * Switch tiles panel

		 *

		 * @method switchTopPanel

		 * @param {string} panel - Panel HTMLElement ID

		 * @param {?string} display - CSS display value

		 */

    this.switchTopPanel = function (panel) {
      var display =
        arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

      var panelHtmlElement = document.getElementById(panel);

      if (panelHtmlElement.style.display !== display) {
        panelHtmlElement.style.display = display;
      }

      var panels = ["topPanel", "topPanelCeilingColor", "productInfoPanel"];

      panels.forEach(function (otherPanel) {
        var otherPanelHtmlElement = document.getElementById(otherPanel);

        if (
          otherPanelHtmlElement &&
          otherPanelHtmlElement !== panelHtmlElement
        ) {
          otherPanelHtmlElement.style.display = "none";
        }
      });
    };

    /**

		 * Change grout size text on grout panel

		 *

		 * @method changeGroutSizeText

		 * @param {HTMLElementEvent} event - not used

		 * @param {?number} value - Grout size value or {HTMLElement input value

		 */

    this.changeGroutSizeText = function (event, value) {
      if (value === undefined) {
        value = event && event.currentTarget && event.currentTarget.value;
      }

      document.getElementById("topPanelGroutSizeText").innerHTML =
        value + " mm";
    };

    /**

		 * Hide productInfoPanel for iorena layout

		 */

    this.hideProductInfoPanel = function () {
      if (window.JsConstants.config.layout === "iorena.") {
        var productInfoButton = document.getElementById("bottomMenuRoomInfo");

        var productInfoPanel = document.getElementById("productInfoPanel");

        if (
          productInfoButton &&
          productInfoPanel &&
          productInfoPanel.classList.contains("show")
        ) {
          productInfoButton.click();
        }
      }
    };

    this.changeGroutSize = function (value) {
      var groutSizeRange = document.getElementById("topPanelGroutSizeRange");

      if (Number(groutSizeRange.value) !== Number(value)) {
        groutSizeRange.value = value;

        this.changeGroutSizeText(undefined, value);
      }
    };

    function tilesSort(field, order) {
      // field: name, created_at, price, size;  order: 1 = asc, -1 = desc

      if (Array.isArray(_this.tiles) && _this.tiles.length) {
        var tilesListUl = document.getElementById("topPanelTilesListUl");

        var values = _this.tiles.map(function (tile, index) {
          var value = "";

          if (typeof tile[field] === "string") {
            value = tile[field].trim().toLowerCase();
          } else if (typeof tile[field] === "number") {
            value = tile[field];
          }

          return { value: value, index: index };
        });

        values.sort(function (a, b) {
          if (a.value > b.value) return order;
          else if (a.value < b.value) return -order;

          return 0;
        });

        values.forEach(function (value) {
          var tile = _this.tiles[value.index];

          if (tile.custom) {
            tilesListUl.insertBefore(tile.li, tilesListUl.firstChild);
          } else {
            tilesListUl.appendChild(tile.li);
          }
        });

        _this.tiles.showIcons();
      }
    }

    this.addTilesToList = function (sortType) {
      switch (sortType) {
        case "z-a":
          tilesSort("name", -1);

          break;

        case "newest first":
          tilesSort("created_at", -1);

          break;

        case "oldest first":
          tilesSort("created_at", 1);

          break;

        default:
          // 'a-z'

          tilesSort("name", 1);
      }
    };

    this.changeTilesSort = function () {
      _this.addTilesToList(this.value);
    };

    this.hideTilesPreloader = function () {
      document.getElementById("loadTilesAnimationContainer").style.display =
        "none";
    };

    function getSurfaceGroups(surfaces) {
      var groupIds = [];

      var surfaceGroups = [];

      surfaces.forEach(function (surface) {
        if (!surface.group || groupIds.indexOf(surface.group) === -1) {
          groupIds.push(surface.group);

          surfaceGroups.push(surface);
        }
      });

      return surfaceGroups;
    }

    function getProductInfoElement(tile) {
      var tileItem = document.createElement("div");

      tileItem.className = "top-panel-content-tiles-list-item";

      tileItem.innerHTML =
        '<div class="tile-list-thumbnail-image-holder">\n                <img src="' +
        tile.file +
        '" class="tile-list-thumbnail">\n            </div>\n            ' +
        tile.getInfoText();

      return tileItem;
    }

    this.addProductInfo = function (room, tiles) {
      var productInfoTilesList = document.getElementById(
        "productInfoTilesList"
      );

      productInfoTilesList.innerHTML = ""; // '<div class="top-panel-label">Used product information</div>';

      if (room.size) {
        productInfoTilesList.innerHTML =
          '<div class="top-panel-label">Room size: ' +
          room.size.x / 1000 +
          "m \xD7 " +
          room.size.z / 1000 +
          "m, Height: " +
          room.size.y / 1000 +
          "m</div>";
      }

      var surfaceGroups = getSurfaceGroups(room.tiledSurfaces);

      surfaceGroups.forEach(function (tiledSurface, index) {
        var tileApplied =
          tiledSurface.tileIndex !== undefined ||
          tiledSurface.tile2Index !== undefined ||
          (tiledSurface.freeDesignTiles &&
            tiledSurface.freeDesignTiles.length > 0);

        if (tileApplied) {
          var surfaceProductInfo = document.createElement("p");

          var usedTileIds = [];

          if (!tiledSurface.name) {
            // todo move to surfaces init

            if (room.surfaceTypes && tiledSurface.type) {
              tiledSurface.name = room.surfaceTypes[tiledSurface.type];
            } else if (tiledSurface.type) {
              tiledSurface.name = tiledSurface.type;
            } else {
              tiledSurface.name = "Surface " + (1 + index);
            }
          }

          surfaceProductInfo.className = "top-panel-label";

          surfaceProductInfo.textContent = Locale.lang(tiledSurface.name);

          productInfoTilesList.appendChild(surfaceProductInfo);

          if (tiledSurface.tileIndex !== undefined) {
            productInfoTilesList.appendChild(
              getProductInfoElement(tiles[tiledSurface.tileIndex])
            );

            usedTileIds.push({
              id: tiles[tiledSurface.tileIndex].id,

              custom: tiles[tiledSurface.tileIndex].custom,
            });
          }

          if (
            tiledSurface.tile2Index !== undefined &&
            tiledSurface.tile2Index !== tiledSurface.tileIndex
          ) {
            productInfoTilesList.appendChild(
              getProductInfoElement(tiles[tiledSurface.tile2Index])
            );

            usedTileIds.push({
              id: tiles[tiledSurface.tile2Index].id,

              custom: tiles[tiledSurface.tile2Index].custom,
            });
          }

          if (tiledSurface.freeDesignTiles) {
            tiledSurface.freeDesignTiles.forEach(function (freeDesignTile) {
              var tileUsed = usedTileIds.some(function (usedTile) {
                return (
                  freeDesignTile.id === usedTile.id &&
                  freeDesignTile.custom === usedTile.custom
                );
              });

              if (!tileUsed) {
                var tile = tiles.getById(
                  freeDesignTile.id,
                  freeDesignTile.custom
                );

                productInfoTilesList.appendChild(getProductInfoElement(tile));

                usedTileIds.push({
                  id: freeDesignTile.id,

                  custom: freeDesignTile.custom,
                });
              }
            });
          }
        }
      });
    };

    this.changeFullScreenMode = function (fullScreen) {
      if (
        (!document.fullscreenElement &&
          !document.mozFullScreenElement &&
          !document.webkitFullscreenElement &&
          fullScreen !== false) ||
        fullScreen === true
      ) {
        if (document.documentElement.requestFullscreen) {
          document.documentElement.requestFullscreen();
        } else if (document.documentElement.mozRequestFullScreen) {
          document.documentElement.mozRequestFullScreen();
        } else if (document.documentElement.webkitRequestFullscreen) {
          document.documentElement.webkitRequestFullscreen(
            window.Element.ALLOW_KEYBOARD_INPUT
          );
        }
      } else if (document.cancelFullScreen) {
        document.cancelFullScreen();
      } else if (document.mozCancelFullScreen) {
        document.mozCancelFullScreen();
      } else if (document.webkitCancelFullScreen) {
        document.webkitCancelFullScreen();
      }
    };

    this.showAdditionalOptions = function (event) {
      if (!room || !room.currentTiledSurface) {
        _this.showAlert(
          "Surface not selected. To select surface click on wall or floor.",
          "warning"
        );

        return;
      }

      var show = !$(event.currentTarget).hasClass("top-panel-button-active");

      console.log("show = " + show);

      if (event.currentTarget.id == "searchIconToggle") {
        setPanelToggleStatus('.serach-pad-set','#searchIconToggle');

      } else if (event.currentTarget.id == "sliderIconToggle") {
        var nowVisible = !setPanelToggleStatus('.filterContentPanel','#sliderIconToggle');
        if(nowVisible==true){
            if (typeof _this.filtersShow === 'function') {

                $('.filterContentPanel').show();

                _this.filtersShow();
                customFilterManagement();
                $(event.currentTarget).addClass('top-panel-button-active');
            }
        }

    } else {
		$('.top-panel-button').removeClass('top-panel-button-active');

		$('.top-panel-option-box').hide();

		$('#topPanelTilesListUl').show();

		showAllFilters(false);
		console.log("IF show = " + show);
		if (show) {
			$(event.currentTarget).addClass('top-panel-button-active');
				switch (event.currentTarget.id) {

          
          case 'btnProduct':
            $('.partOfProductTabContent-wrap').show();
            $('.radio-surface-rotation-wrap').show();

          break;

					case 'btnLayout':

						$('#topPanelLayout').show();
						$('#topPanelTilesListUl').hide();
            $('.partOfProductTabContent-wrap').hide();
            $('.radio-surface-rotation-wrap').hide();
						break;

					case 'btnGrout':
						//setPanelClicker({"area":"tiles","subsection":"grout"});
						$('#topPanelGrout').show();
						$('#topPanelTilesListUl').hide();
            $('.partOfProductTabContent-wrap').hide();
            $('.radio-surface-rotation-wrap').hide();
						break;

					case 'btnRefine':
						//setPanelClicker({"area":"tiles","subsection":"grout"});

						if (typeof _this.filtersShow === 'function') {
							$('.filterContentPanel').show();

							_this.filtersShow();
							customFilterManagement();
							$(event.currentTarget).addClass('top-panel-button-active');
						}

						break;



				}

			}
		}
    };

    this.updateSkewSizeButtons = function (fillTypeIndex) {
      var skewPattern = fillTypeIndex === 2 || fillTypeIndex === 3;

      $(".radio-skew-size input").attr("disabled", !skewPattern);
    };

    this.updateSkewSize = function (value) {
      $(".radio-skew-size input").each(function (i, button) {
        button.checked = button.value === String(value);
      });
    };

    this.updateValues = function (surface) {
      _this.changeGroutSize(surface.groutSize);

      document.getElementById("topPanelCheckFreeDesign").checked =
        surface.freeDesign;

      document.getElementById(
        "topPanelSurfaceRotation_" + surface.rotation
      ).checked = true;

      document.getElementById(
        "topPanelSurfacePattern_" + surface.fillTypeIndex
      ).checked = true;

      _this.updateSkewSize(surface.skewSize);

      _this.updateSkewSizeButtons(surface.fillTypeIndex);
    };

    function bookmarkLink() {
      var url = $("#dialogSavedRoomUrlInput").val();

      if (url) {
        if (window.sidebar && window.sidebar.addPanel) {
          // Mozilla Firefox Bookmark

          window.sidebar.addPanel(document.title, url, "");
        } else if (
          window.external &&
          window.external.hasOwnProperty("AddFavorite")
        ) {
          // IE Favorite

          window.external.AddFavorite(url, document.title); // eslint-disable-line new-cap
        } else if (window.opera && window.print) {
          // Opera Hotlist

          var a = document.createElement("a");

          a.setAttribute("href", url);

          a.setAttribute("title", document.title);

          a.setAttribute("rel", "sidebar");

          a.click(); // this.title=document.title;
        } else {
          // webkit - safari/chrome

          var ctrlButton =
            navigator.userAgent.toLowerCase().indexOf("mac") === -1
              ? "CTRL"
              : "Command/Cmd";

          _this.showAlert(
            "Press " + ctrlButton + " + D to bookmark this page."
          );
        }
      }
    }

    this.share = function (event) {
      event.preventDefault();

      var width = 400;

      var height = 400;

      var left = Math.floor(($(window).width() - width) / 2);

      var top = Math.floor(($(window).height() - height) / 2);

      var roomUrl = window.location.href;

      if (window.JsConstants.room.url) {
        // roomUrl =
        //   window.location.origin + "/room/url/" + window.JsConstants.room.url;

        roomUrl = window.location.origin + '/storage/savedrooms/' + window.JsConstants.room.url + '.png';

        if (window.JsConstants.config.urlFilters) {
          var currentUrl = new URL(window.location.href);

          var _url = new URL(roomUrl);

          _url.searchParams.set(
            "filters",
            currentUrl.searchParams.get("filters")
          );

          roomUrl = _url.href;
        }
      }

      var href = event.currentTarget.href || event.currentTarget.dataset.href;

      var url = href + encodeURIComponent(roomUrl);

      var windowFeatures =
        "width=" +
        width +
        ",height=" +
        height +
        ",left=" +
        left +
        ",top=" +
        top +
        ",location=0,menubar=0,toolbar=0,status=0,scrollbars=1,resizable=1";

      var popup = window.open(url, "Social Share", windowFeatures);

      if (popup) popup.focus();
    };

    // this.addEventListener = function (elementId, event, func) {

    //     const element = document.getElementById(elementId);

    //     if (element) {

    //         element.addEventListener(event, func);

    //     }

    // };

    // @jscrambler define domainLock {domains:[app001.3droomvisualizer.com, sean.3dtilevisualizer.com, tilevisualizer.pavits.com, vis.florexceramic.in, visualizer.restile.com, visualizer.mahalaxmitiles.com, visualiser.sandstoneworks.com.au, visualiser.tiledepot.co.nz, simulator.stoneline.com.tr, visualizer2d.globalquartz.in, diy.saifurnitureindia.co.in, tilevisualizer.designtiles.com.au, tiledesigner.stile.com.pk, showroom.gulveogfliser.dk, tiledepot.3droomvisualizer.com, visualizer.metztiles.com.au, visualizer.metztiles.com.au, visualizer.alkhaleejceramics.com, floorsdirect.3droomvisualizer.com, tdcc2.3dtilevisualizer.com, simuladorfv.westus.cloudapp.azure.com, tilevisualiser.colortile.com.au, visualizer.cletile.com, floorvisualizer.welspunflooring.com, poplar.3dtilevisualizer.com, visualizer.topcarpetsandfloors.co.za, colorizer.prattandlarson.com]} as dL

    // @jscrambler enable dL

    function init() {
      $("#topPanelHideBtn").off("click");

      $("#topPanelCloseBtn").off("click");

      $("#topPanelGroutSizeRange").off("input");

      $("#topPanelTilesSort").off("change");

      $("#bottomMenuFullScreen").off("click");

      $(".top-panel-button").off("click");

      $("#bookmarkSavedRoomLink").off("click");

      $("#topPanelHideBtn").click(_this.topPanelToggle);

      $("#topPanelCloseBtn").click(_this.topPanelToggle);

      $("#topPanelGroutSizeRange").on("input", _this.changeGroutSizeText);

      $("#topPanelTilesSort").change(_this.changeTilesSort);

      $("#bottomMenuFullScreen").click(_this.changeFullScreenMode);

      $(".top-panel-button").click(_this.showAdditionalOptions);

      $("#bookmarkSavedRoomLink").click(bookmarkLink);

      if (_this.isMobileDevice()) $(".copyright").remove();
    }

    init();
  }

  UI.roomCanvas = document.getElementById("roomCanvas"); // todo optimize

  UI.updateCanvasStyle = function (title) {
    if (title && typeof title === "string") {
      UI.roomCanvas.title = "Change " + title;

      UI.roomCanvas.style.cursor = 'url("/img/icons/brush.png") 18 46, pointer';
    } else {
      UI.roomCanvas.title = "";

      UI.roomCanvas.style.cursor = "unset";
    }
  };

  /**

	 * Returns true if page opened on mobile device

	 *

	 * @method isMobileDevice

	 * @returns {boolean}

	 */

  UI.isMobileDevice = function () {
    if (
      navigator.userAgent.match(/Android/i) ||
      navigator.userAgent.match(/webOS/i) ||
      navigator.userAgent.match(/BlackBerry/i) ||
      navigator.userAgent.match(/iPhone/i) ||
      navigator.userAgent.match(/iPad/i) ||
      navigator.userAgent.match(/iPod/i) ||
      navigator.userAgent.match(/Opera Mini/i) ||
      navigator.userAgent.match(/IEMobile/i) ||
      navigator.userAgent.match(/Windows Phone/i)
    ) {
      return true;
    }

    return false;
  };

  var LoadingAnimation = (function () {
    function LoadingAnimation() {
      _classCallCheck(this, LoadingAnimation);

      this.loadingItems = 0;

      this.preLoader = false;
    }

    _createClass(LoadingAnimation, [
      {
        key: "show",

        value: function show() {
          this.loadingItems += 1;

          if (!this.preLoader) {
            this.preLoader = true;

            document.getElementById("container").style.cursor = "wait";

            window.$("#loadAnimationContainer").show();
          }
        },
      },
      {
        key: "hide",

        value: function hide() {
          this.loadingItems -= 1;

          if (this.loadingItems <= 0 && this.preLoader) {
            this.loadingItems = 0;

            this.preLoader = false;

            document.getElementById("container").style.cursor = "unset";

            window.$("#loadAnimationContainer").hide();
          }
        },
      },
    ]);

    return LoadingAnimation;
  })();

  var loadingAnimation = new LoadingAnimation();

  var RoomLoadProgress = {
    start: function start() {
      window.$("#sourceLoadProgressBarContainer").show();
      window.$("#roomLoaderBackground").hide();

      var progressBar = document.getElementById("sourceLoadProgressBar");

      if (!progressBar) return;

      progressBar.textContent = "10%";

      if (progressBar.classList.contains("progress-bar-striped")) {
        progressBar.style.width = "10%";
      }
    },

    progress: function progress(itemsLoaded, itemsTotal) {
      var progressBar = document.getElementById("sourceLoadProgressBar");

      if (!progressBar) return;

      var value = Math.floor((itemsLoaded / itemsTotal) * 80 + 10) + "%";

      progressBar.textContent = value;

      if (progressBar.classList.contains("progress-bar-striped")) {
        progressBar.style.width = value;
      }
    },

    end: function end() {
      window.$("#sourceLoadProgressBarContainer").hide();

      // window.$('#sourceLoadProgressBarContainer').remove();

      var progressBar = document.getElementById("sourceLoadProgressBar");

      if (!progressBar) return;

      progressBar.textContent = "90%";

      if (progressBar.classList.contains("progress-bar-striped")) {
        progressBar.style.width = "90%";
      }

      // allLoadCompleted();
    },

    setBackground: function setBackground(image, smallImage) {
      // TODO move to PHP

      var roomLoaderBackground = document.getElementById(
        "roomLoaderBackground"
      );

      if (smallImage) {
        var img = new Image();

        img.src = smallImage;

        roomLoaderBackground.appendChild(img);
      }

      if (image) {
        var _img = new Image();

        _img.src = image;

        roomLoaderBackground.appendChild(_img);
      }
    },
  };

  var Loader = (function () {
    function Loader() {
      _classCallCheck(this, Loader);

      this.data = {};

      this.dataLoaded = {
        tiles: false,

        userCustomTiles: false,

        roomCustomTiles: false,

        roomData: false,
      };

      this.tilesDesigner =
        window.JsConstants &&
        window.JsConstants.config &&
        window.JsConstants.config.TilesDesigner;
    }

    _createClass(Loader, [
      {
        key: "_loadTiles",

        value: function _loadTiles() {
            var _this2 = this;

            // Extract URL parts
            var urlParts = window.location.pathname.split('/').filter(Boolean); // Remove empty parts

            // Extract room type (first segment) and room ID (last segment)
            var roomType = urlParts[0]; // Gets "room2d" or "panorama"

            // Validate room ID (ensure it's a number)
            if (    roomType !== undefined) {
                $.ajax({
                    url: '/get/tiles',
                    type: 'GET',
                    data: {
                        room_type: roomType
                    },
                    success: function (data) {
                        _this2._onWholeDataLoaded('tiles', data);
                    },
                    error: function (xhr, status, error) {
                        console.error("AJAX Request Failed:", error);
                    }
                });
            } else {
                console.error("Invalid Room ID:", roomId);
            }
        },
      },
      {
        key: "_loadUserCustomTiles",

        value: function _loadUserCustomTiles() {
          var _this3 = this;

          $.get("/customtiles", function (data) {
            return _this3._onWholeDataLoaded("userCustomTiles", data);
          });
        },
      },
      {
        key: "_loadRoomCustomTiles",

        value: function _loadRoomCustomTiles(roomTileIds) {
          var _this4 = this;

          if (roomTileIds.length > 0) {
            $.get(
              "/get/room-custom-tiles",
              { roomTileIds: roomTileIds },
              function (data) {
                return _this4._onWholeDataLoaded("roomCustomTiles", data);
              },
              "json"
            );
          } else {
            this._onWholeDataLoaded("roomCustomTiles", []);
          }
        },
      },
      {
        key: "_loadRoomData",

        value: function _loadRoomData(url) {
          var _this5 = this;

          $.get(url, function (data) {
            if (data) {
              RoomLoadProgress.setBackground(
                data.shadow || data.shadow_matt || data.image,
                data.icon
              );
            }

            _this5._onWholeDataLoaded("roomData", data);
          });
        },
      },
      {
        key: "_onWholeDataLoaded",

        value: function _onWholeDataLoaded(part, data) {
          this.dataLoaded[part] = true;

          this.data[part] = data;

          var customTiles =
            !this.tilesDesigner ||
            (this.dataLoaded.userCustomTiles &&
              this.dataLoaded.roomCustomTiles);

          var wholeDataLoaded =
            this.dataLoaded.tiles && this.dataLoaded.roomData && customTiles;

          if (wholeDataLoaded && typeof this.onLoad === "function") {
            this.onLoad(this.data);
          }
        },
      },
      {
        key: "_parseRoomSettings",

        value: function _parseRoomSettings(roomData) {
          if (roomData && typeof roomData === "string") {
            return JSON.parse(roomData);
          }
        },
      },
      {
        key: "_parseRoomCustomTiles",

        value: function _parseRoomCustomTiles() {
          var roomTileIds = [];

          var addId = function addId(id, custom) {
            if (custom && id && roomTileIds.indexOf(id) === -1) {
              roomTileIds.push(id);
            }
          };

          if (
            this.data.roomSettings &&
            Array.isArray(this.data.roomSettings.surfaces)
          ) {
            this.data.roomSettings.surfaces.forEach(function (surface) {
              if (surface) {
                addId(surface.tileId, surface.tileCustom);

                addId(surface.tile2Id, surface.tile2Custom);

                if (
                  surface.freeDesign &&
                  Array.isArray(surface.freeDesignTiles)
                ) {
                  surface.freeDesignTiles.forEach(function (freeDesignTile) {
                    if (freeDesignTile) {
                      addId(freeDesignTile.id, freeDesignTile.custom);
                    }
                  });
                }
              }
            });
          }

          return roomTileIds;
        },
      },
      {
        key: "_loadData",

        value: function _loadData(roomIdUrl, roomSettingsData) {
          this._loadTiles();

          this._loadRoomData(roomIdUrl);

          this.data.roomSettings = this._parseRoomSettings(roomSettingsData);

          if (this.tilesDesigner) {
            this._loadUserCustomTiles();

            var roomTileIds = this._parseRoomCustomTiles();

            this._loadRoomCustomTiles(roomTileIds);
          }
        },
      },
      {
        key: "loadRoom",

        value: function loadRoom(url, onLoad) {
          var _this6 = this;

          this.onLoad = onLoad;

          this.data.id = window.JsConstants.room.id;

          this.data.url = window.JsConstants.room.url;

          if (this.data.url) {
            $.get("/get/room/url/" + this.data.url, function (data) {
              _this6.data.id = data.roomid;

              _this6._loadData(url + data.roomid, data.roomsettings);
            });
          } else if (this.data.id) {
            this._loadData(url + this.data.id);
          }
        },
      },
    ]);

    return Loader;
  })();

  var TAB_ALL_ID = 0;

  var PRODUCT_CATEGORY = 1;

  var Category = function Category(categoryData) {
    _classCallCheck(this, Category);

    // Object.assign(this, categoryData);

    // this.data = { ...Category._defaultCategory, ...categoryData };

    this.type = PRODUCT_CATEGORY;

    this.enabled =
      typeof categoryData.enabled === "undefined"
        ? true
        : Boolean(categoryData.enabled);

    this.id = Number(categoryData.id) || TAB_ALL_ID;

    this.name = String(categoryData.name);

    this.note = String(categoryData.note);

    this.parentId = Number(categoryData.parent_id) || undefined;

    this.title = String(categoryData.title);

    this.surface = String(categoryData.surface);
  };

  var CheckBoxCategory = (function (_Category) {
    _inherits(CheckBoxCategory, _Category);

    function CheckBoxCategory(categoryData, container) {
      _classCallCheck(this, CheckBoxCategory);

      var _this7 = _possibleConstructorReturn(
        this,
        (
          CheckBoxCategory.__proto__ || Object.getPrototypeOf(CheckBoxCategory)
        ).call(this, categoryData)
      );

      _this7.checked = true;

      _this7._createDomElement(container);

      return _this7;
    }

    _createClass(CheckBoxCategory, [
      {
        key: "show",

        value: function show() {
          this._filterItem.style.display = "";
        },
      },
      {
        key: "hide",

        value: function hide() {
          this._filterItem.style.display = "none";
        },
      },
      {
        key: "addChangeEventListener",

        value: function addChangeEventListener(filterCallback) {
          var _this8 = this;

          this.domElement.addEventListener("change", function (event) {
            _this8.checked = event.currentTarget.checked;

            filterCallback();
          });
        },
      },
      {
        key: "_createDomElement",

        value: function _createDomElement(container) {
          // if (item.value.toLowerCase() === 'others' && JsConstants.config.tilesFiltersHideOthers) {

          //     return;

          // }

          this.domElement = document.createElement("input");

          this.domElement.id = "checkBoxCategory_" + this.id;

          this.domElement.type = "checkbox";

          this.domElement.checked = this.checked;

          var label = document.createElement("label");

          label.htmlFor = this.domElement.id;

          label.innerHTML = this.name;

          this._filterItem = document.createElement("div");

          this._filterItem.className = "filter-item-checkbox";

          this._filterItem.appendChild(this.domElement);

          this._filterItem.appendChild(label);

          container.appendChild(this._filterItem);

          this.hide();
        },
      },
    ]);

    return CheckBoxCategory;
  })(Category);

  var ProductCategory = (function (_Category2) {
    _inherits(ProductCategory, _Category2);

    function ProductCategory(categoryData) {
      _classCallCheck(this, ProductCategory);

      var _this9 = _possibleConstructorReturn(
        this,
        (
          ProductCategory.__proto__ || Object.getPrototypeOf(ProductCategory)
        ).call(this, categoryData)
      );

      _this9.children = [];

      _this9._createDomElement();

      return _this9;
    }

    _createClass(ProductCategory, [
      {
        key: "activate",

        value: function activate() {
          this.aDomElement.classList.add("-active");

          this.children.forEach(function (child) {
            child.show();
          });
        },
      },
      {
        key: "deactivate",

        value: function deactivate() {
          this.aDomElement.classList.remove("-active");

          this.children.forEach(function (child) {
            child.hide();
          });
        },
      },
      {
        key: "show",

        value: function show() {
          this.domElement.style.display = "";
        },
      },
      {
        key: "hide",

        value: function hide() {
          if (this.id === TAB_ALL_ID) {
            return;
          }

          this.domElement.style.display = "none";
        },
      },
      {
        key: "_createDomElement",

        value: function _createDomElement() {
          this.aDomElement = document.createElement("a");

          this.aDomElement.className = "nav-link top-panel-label";

          this.aDomElement.innerText = this.name;

          this.domElement = document.createElement("li");

          this.domElement.className = "nav-item";

          this.domElement.appendChild(this.aDomElement);
        },
      },
    ]);

    return ProductCategory;
  })(Category);

  var ProductCategories = (function () {
    function ProductCategories(filterCallback) {
      var _this10 = this;

      _classCallCheck(this, ProductCategories);

      this._activeTabIds = [0]; // All

      this._domElement = $(".top-panel .nav")[0];

      this._tabs = [];

      this._checkBoxes = [];

      this._checkBoxesDomElement = $(".top-panel .nav")[0];

      this._filterCallback = filterCallback;

      this._createCheckBoxesContainer();

      this._tabAll = this._addTabAll();

      var categoriesData = JsConstants.room.productCategories;

      if (Array.isArray(categoriesData)) {
        categoriesData
          .filter(function (categoryData) {
            return !Boolean(categoryData.parent_id);
          })
          .forEach(function (categoryData) {
            _this10._addTab(categoryData);
          });

        categoriesData
          .filter(function (categoryData) {
            return Boolean(categoryData.parent_id);
          })
          .forEach(function (categoryData) {
            _this10._addCheckBox(categoryData);
          });
      }

      this._tabAll.activate();
    }

    _createClass(ProductCategories, [
      {
        key: "show",

        value: function show(surfaceType) {
          this._tabs.forEach(function (tab) {
            if (tab.surface === surfaceType) {
              tab.show();
            } else {
              tab.hide();
            }
          });

          if (this._activeTab !== this._tabAll) {
            if (this._activeTab) {
              this._activeTab.deactivate();
            }

            this._activeTab = this._tabAll;

            this._activeTab.activate();
          }

          this._activeTabIds = [this._activeTab.id];
        },
      },
      {
        key: "match",

        value: function match(tile, surface) {
          var _this11 = this;

          if (surface && surface.freeDesign) {
            var currentTile = surface.tile || surface.freeDesignTile;

            if (currentTile) {
              if (
                Array.isArray(currentTile.categories) &&
                currentTile.categories.length !== 0
              ) {
                return (
                  currentTile.categories[0] ===
                  (tile.categories && tile.categories[0])
                );
              }
            }
          }

          if (this._activeTabIds.indexOf(0) !== -1) {
            return true;
          }

          if (!Array.isArray(tile.categories) || tile.categories.length === 0) {
            return false;
          }

          return tile.categories.some(function (category) {
            return _this11._activeTabIds.indexOf(category) !== -1;
          });
        },
      },
      {
        key: "_addTab",

        value: function _addTab(categoryData) {
          var tab = new ProductCategory(categoryData);

          this._addItem(tab);
        },
      },
      {
        key: "_addCheckBox",

        value: function _addCheckBox(categoryData) {
          var _this12 = this;

          var checkBox = new CheckBoxCategory(
            categoryData,
            this._checkBoxesDomElement
          );

          checkBox.parent = this._getParent(checkBox);

          checkBox.addChangeEventListener(function () {
            _this12._filter();
          });

          this._checkBoxes.push(checkBox);
        },
      },
      {
        key: "_getParent",

        value: function _getParent(checkBox) {
          var parent = this._tabs.find(function (tab) {
            return tab.id === checkBox.parentId;
          });

          if (parent) {
            parent.children.push(checkBox);
          }

          return parent;
        },
      },
      {
        key: "_addTabAll",

        value: function _addTabAll() {
          var tab = new ProductCategory({
            id: TAB_ALL_ID,

            name: "ALL",

            title: "ALL Product Categories",
          });

          this._addItem(tab);

          return tab;
        },
      },
      {
        key: "_addItem",

        value: function _addItem(tab) {
          var _this13 = this;

          tab.aDomElement.addEventListener("click", function () {
            _this13._tabClick(tab);
          });

          if (tab === this._tabAll) {
            this._domElement.prepend(tab.domElement);
          } else {
            this._domElement.appendChild(tab.domElement);
          }

          this._tabs.push(tab);
        },
      },
      {
        key: "_filter",

        value: function _filter() {
          if (typeof this._filterCallback === "function") {
            if (this._activeTab === this._tabAll) {
              this._activeTabIds = [this._activeTab.id];
            } else {
              var activeCheckBoxes = this._activeTab.children
                .filter(function (checkBox) {
                  return checkBox.checked;
                })
                .map(function (checkBox) {
                  return checkBox.id;
                });

              this._activeTabIds = [this._activeTab.id].concat(
                _toConsumableArray(activeCheckBoxes)
              );
            }

            this._filterCallback();
          }
        },
      },
      {
        key: "_tabClick",

        value: function _tabClick(clickedTab) {
          if (clickedTab === this._activeTab) {
            return;
          }

          this._activeTab = clickedTab;

          this._tabs.forEach(function (tab) {
            if (tab === clickedTab) {
              clickedTab.activate();
            } else {
              tab.deactivate();
            }
          });

          this._filter();
        },
      },
      {
        key: "_createCheckBoxesContainer",

        value: function _createCheckBoxesContainer() {
          this._checkBoxesDomElement = document.createElement("div");

          this._checkBoxesDomElement.className = "filter-block";

          // this._checkBoxesDomElement.style.display = 'none';

          var topPanelFilter = document.getElementById("topPanelFilter");

          topPanelFilter.appendChild(this._checkBoxesDomElement);
        },
      },
    ]);

    return ProductCategories;
  })();

  var SurfaceType;

  (function (SurfaceType) {
    SurfaceType["Wall"] = "wall";

    SurfaceType["Furniture"] = "furniture";

    SurfaceType["Counter"] = "counter";

    SurfaceType["Floor"] = "floor";
  })(SurfaceType || (SurfaceType = {}));

  /* tslint:disable member-ordering */

  var FilterType;

  (function (FilterType) {
    FilterType["Checkbox"] = "checkbox";

    FilterType["Slider"] = "slider";

    FilterType["Accordion"] = "accordion";
  })(FilterType || (FilterType = {}));

  var Filter = (function () {
    function Filter(options, tiles, filterTilesList) {
      _classCallCheck(this, Filter);

      this.name = options.name || options.field;

      this.field = options.field;

      this.surface = options.surface;

      this._tiles = tiles;

      this._filterTilesList = filterTilesList;

      this.createDomElement();
    }

    _createClass(Filter, [
      {
        key: "createDomElement",

        value: function createDomElement() {

          this.domElement = document.createElement('div');

          this.domElement.className = 'filter-block';

          this.domElement.style.display = 'none';

          // Create the header container
          this._headerBox = document.createElement('div');
          this._headerBox.className = '-header-box';

          // Use flexbox to arrange headers horizontally
          this._headerBox.style.display = 'flex';
          this._headerBox.style.flexWrap = 'wrap';  // Optional: Wrap to next line if too wide
          this._headerBox.style.gap = '10px';  // Optional: Add space between headers
          this.domElement.appendChild(this._headerBox);

          // Create the header for the filter
          this._header = document.createElement('div');
          this._header.className = '-header';
          this._header.addEventListener('click', this.toggleTab.bind(this)); // Event listener to toggle header and body

          this._headerBox.appendChild(this._header);

          var tempName = String(this.surface + '_' + Locale.lang(this.name)).toLowerCase();

          // Title of the filter
          this._title = document.createElement('div');
          this._title.className = '-header-title';
          this._title.id =  '-headerId_' + tempName;
          this._title.innerHTML = Locale.lang(this.name);
          this._header.appendChild(this._title);


          // Create the body for the filter options
          this._body = document.createElement('div');
          this._body.className = '-body';
          this._body.id = '-body_' + tempName;
          this.domElement.appendChild(this._body);
          this._body.style.display = 'none'; // Initially hidden
        },
      }, {
        key: 'toggleTab',
        value: function toggleTab() {
            // Get all headers and bodies in the filter block
            var allHeaders = document.querySelectorAll('#topPanelFilter .-header');
            var allBodies = document.querySelectorAll('#topPanelFilter .-body');

            // If the body of the clicked header is already visible, hide it
            if (this._body.style.display === 'flex') {
                this._body.style.display = 'none'; // Hide the body
                this._header.classList.remove('active'); // Remove active class from the header
                return; // Exit the function
            }

            // Hide all bodies and remove the active class from all headers
            allBodies.forEach(function(body) {
                body.style.display = 'none';
            });
            allHeaders.forEach(function(header) {
                header.classList.remove('active');
            });

            // Show the body of the clicked header and add the active class to the header
            this._body.style.display = 'flex'; // Show the body
            this._body.style.flexWrap = 'wrap'; // Optional: Allow wrapping if items exceed width
            this._body.style.gap = '10px'; // Optional: Add space between items
            this._header.classList.add('active'); // Add active class to the clicked header
        }
      },
      {
        key: "hide",

        value: function hide() {
          if (this.domElement.style.display !== "none") {
            this.domElement.style.display = "none";
          }
        },
      },
      {
        key: "show",

        value: function show() {
          if (this.domElement.style.display !== "") {
            this.domElement.style.display = "";
          }
        },

        /** @abstract */
      },
      {
        key: "_clickSupportButton",

        value: function _clickSupportButton(event) {},
      },
      {
        key: "_add",

        value: function _add(filterItem) {
          this._body.appendChild(filterItem);
        },
      },
      {
        key: "_apply",

        value: function _apply() {
          if (typeof this._filterTilesList === "function") {
            this._filterTilesList();
          }
        },
      },
      {
        key: "_createSupportButton",

        value: function _createSupportButton(text) {
          var _this14 = this;

          var button = document.createElement("span");

          button.innerHTML = " " + Locale.lang(text) + " ";

          button.addEventListener("click", function (event) {
            return _this14._clickSupportButton(event);
          });

          return button;
        },
      },
      {
        key: "_createSupportButtons",

        value: function _createSupportButtons() {
          var buttons = document.createElement("div");

          buttons.className = "filter-block-support-buttons";

          this._header.appendChild(buttons);

          return buttons;
        },
      },
    ]);

    return Filter;
  })();

  var CheckboxFilter = (function (_Filter) {
    _inherits(CheckboxFilter, _Filter);

    function CheckboxFilter(options, tiles, filterTilesList, index) {
      _classCallCheck(this, CheckboxFilter);

      var _this15 = _possibleConstructorReturn(
        this,
        (
          CheckboxFilter.__proto__ || Object.getPrototypeOf(CheckboxFilter)
        ).call(this, options, tiles, filterTilesList)
      );

      _this15._index = index;

      _this15._items = _this15._parseValues();

      if (Array.isArray(_this15._items) && _this15._items.length > 0) {
        _this15._createSupportButtons();

        _this15._items.forEach(function (item, i) {
          return _this15._addItem(item, i);
        });
      }

      return _this15;
    }

    /** @override */

    _createClass(CheckboxFilter, [
      {
        key: "match",

        value: function match(fieldValue) {
          var _this16 = this;

          if (Array.isArray(this._items)) {
            return this._items.some(function (item) {
              if (!fieldValue && item.value === "others") {
                return item.checked;
              }

              if (
                item.value === fieldValue ||
                _this16._subItemMatch(item.value, fieldValue)
              ) {
                return item.checked;
              }
            });
          }

          return !fieldValue;
        },
      },
      {
        key: "getValues",

        value: function getValues() {
          if (
            !this._items.some(function (item) {
              return !item.checked;
            })
          ) {
            return;
          }

          var values = this._items
            .filter(function (item) {
              return item.checked;
            })
            .map(function (item) {
              return item.value;
            });

          return {
            field: this.field,

            surface: this.surface,

            values: values,
          };
        },
      },
      {
        key: "setValues",

        value: function setValues(values) {
          if (!Array.isArray(values)) {
            return;
          }

          this._items.forEach(function (item) {
            item.checked = values.indexOf(item.value) !== -1;

            if (item.domElement) {
              item.domElement.checked = item.checked;
            }
          });
        },
      },
      {
        key: "_compareStrings",

        value: function _compareStrings(str1, str2) {
          if (typeof str1 !== "string" || typeof str2 !== "string") {
            return false;
          }

          return str1.trim().toLowerCase() === str2.trim().toLowerCase();
        },
      },
      {
        key: "_subItemMatch",

        value: function _subItemMatch(value, subValues) {
          var _this17 = this;

          if (typeof subValues !== "string") {
            return false;
          }

          var subItems = subValues.split(",");

          return subItems.some(function (subItem) {
            return _this17._compareStrings(subItem, value);
          });
        },
      },
      {
        key: "_parseValues",

        value: function _parseValues() {
          var _this18 = this;

          var items = [];

          var others = void 0;

          var addValue = function addValue(text) {
            var item =
              typeof text === "string"
                ? _this18._getCheckboxFilterItem(
                    text.trim(),
                    text.trim().toLowerCase()
                  )
                : _this18._getCheckboxFilterItem(String(text), text);

            if (
              (item.value || Number(item.value) === 0) &&
              !items.some(function (i) {
                return i.value === item.value;
              })
            ) {
              items.push(item);
            }
          };

          this._tiles.forEach(function (tile) {
            var value = void 0;

            if (tile.surface === _this18.surface) {
              if (_this18.field === "size") {
                tile[_this18.field] = tile.width + "x" + tile.height;
              }

              value = tile[_this18.field];

              if (value || Number(value) === 0) {
                var subValues = void 0;

                if (typeof value === "string") {
                  subValues = value.split(",");
                }

                if (subValues && subValues.length > 1) {
                  subValues.forEach(addValue);
                } else {
                  addValue(value);
                }
              } else {
                others = true;
              }
            }
          });

          items.sort(function (a, b) {
            return a.value >= b.value ? 1 : -1;
          });

          if (others) {
            items.push(this._getCheckboxFilterItem("Others", "others"));
          }

          return items;
        },
      },
      {
        key: "_getCheckboxFilterItem",

        value: function _getCheckboxFilterItem(name, value) {
          return {
            checked: false,
            domElement: undefined,
            name: name,
            value: value,
          };
        },
      },
      {
        key: "_clickSupportButton",

        value: function _clickSupportButton(event) {
          var button = event.currentTarget;

          if (Array.isArray(this._items) && this._items.length > 0) {
            this._items.forEach(function (item) {
              switch (button.filterCheck) {
                case "None":
                  item.checked = false;

                  break;

                case "Invert":
                  item.checked = !item.checked;

                  break;

                default:
                  // 'All'

                  item.checked = true;
              }

              item.domElement.checked = item.checked;
            });

            this._apply();
          }
        },
      },
      {
        key: "_createSupportButton",

        value: function _createSupportButton(text) {
          var button = _get(
            CheckboxFilter.prototype.__proto__ ||
              Object.getPrototypeOf(CheckboxFilter.prototype),
            "_createSupportButton",
            this
          ).call(this, text);

          button.filterCheck = text;

          return button;
        },
      },
      {
        key: "_createSupportButtons",

        value: function _createSupportButtons() {
          var buttons = _get(
            CheckboxFilter.prototype.__proto__ ||
              Object.getPrototypeOf(CheckboxFilter.prototype),
            "_createSupportButtons",
            this
          ).call(this);

          buttons.appendChild(this._createSupportButton("All"));

          buttons.appendChild(this._createSupportButton("None"));

          buttons.appendChild(this._createSupportButton("Invert"));

          return buttons;
        },
      },
      {
        key: "_addItem",

        value: function _addItem(item, index) {
			var _this19 = this;

			if (item.value !== null && item.value !== undefined) {
				if (item.value.toLowerCase() === 'others' && JsConstants.config.tilesFiltersHideOthers) {

					return;

				}
			}

			var filterItem = document.createElement("div");

			filterItem.className = "filter-item-checkbox";

			var checkbox = document.createElement("input");

			checkbox.id = "checkboxFilter_" + this._index + "_" + index;

			checkbox.type = "checkbox";

		  	//CODE BY TPS
			//TO ADD DEFAULT BLANK
			checkbox.className = 'checkboxClass';
			// checkbox.className+= prefixCheckboxClassName;
			//END

          checkbox.checked = item.checked;

          checkbox.addEventListener("change", function (event) {
            item.checked = event.currentTarget.checked;

            _this19._apply();
          });

          item.domElement = checkbox;
          
          filterItem.appendChild(checkbox);

          var label = document.createElement("label");

          label.htmlFor = checkbox.id;

          label.innerHTML = Locale.lang(item.name);

          if (this.field === "size" && item.value.toLowerCase() !== "others") {
            label.innerHTML += "mm";
          }

          filterItem.appendChild(label);

          this._add(filterItem);
        },
      },
    ]);

    return CheckboxFilter;
  })(Filter);

  /* tslint:disable member-ordering */

  var SHOW_ALL_UNFILTERED_PRODUCT = JsConstants.config.showAllUnfilteredProduct;

  var AccordionFilter = (function (_CheckboxFilter) {
    _inherits(AccordionFilter, _CheckboxFilter);

    function AccordionFilter(
      options,
      tiles,
      filterTilesList,
      index,
      updateAllAccordionFilters
    ) {
      _classCallCheck(this, AccordionFilter);

      var _this20 = _possibleConstructorReturn(
        this,
        (
          AccordionFilter.__proto__ || Object.getPrototypeOf(AccordionFilter)
        ).call(this, options, tiles, filterTilesList, index)
      );

      _this20.type = FilterType.Accordion;

      _this20._updateAllAccordionFilters = updateAllAccordionFilters;

      return _this20;
    }

    /** @override */

    _createClass(AccordionFilter, [
      {
        key: "createDomElement",

        value: function createDomElement() {
          var _this21 = this;

          this.domElement =
            document.getElementsByClassName("accordion-body")[0];

          this._accordionHeader =
            document.getElementsByClassName("accordion-header")[0];

          this._header = document.createElement("h3");

          this._header.innerText = Locale.lang(this.name);

          this._header.style.display = "none";

          this._header.addEventListener("click", function () {
            _this21._updateAllAccordionFilters(false);

            _this21._updateHeader2();

            _this21.updateChecked(true);

            _this21._apply();
          });

          this.domElement.appendChild(this._header);

          this._body = document.createElement("div");

          this._body.style.display = "none";

          this.domElement.appendChild(this._body);
        },
      },
      {
        key: "hide",

        value: function hide() {
          if (this._header.style.display !== "none") {
            // this._accordionHeader.innerText = 'Select...'; // TODO add removeEventListener

            this._header.style.display = "none";

            this._body.style.display = "none";
          }
        },
      },
      {
        key: "show",

        value: function show() {
          if (this._header.style.display !== "") {
            this._header.style.display = "";
          }
        },
      },
      {
        key: "updateChecked",

        value: function updateChecked(value) {
          this._items.forEach(function (item) {
            if (value && item.value === "others") {
              return;
            }

            item.checked = value;
          });
        },
      },
      {
        key: "updateChecked2",

        value: function updateChecked2(value) {
          this._items.forEach(function (item) {
            item.checked = value;
          });
        },
      },
      {
        key: "_createSupportButtons",

        value: function _createSupportButtons() {
          return undefined;
        },
      },
      {
        key: "_addItem",

        value: function _addItem(item) {
          var _this22 = this;

          if (
            item.value.toLowerCase() === "others" &&
            JsConstants.config.tilesFiltersHideOthers
          ) {
            return;
          }

          var filterItem = document.createElement("div");

          filterItem.className = "product-name";

          filterItem.innerHTML = Locale.lang(item.name);

          filterItem.addEventListener("click", function () {
            _this22._updateAllAccordionFilters(false);

            _this22._updateHeader(item.name);

            item.checked = true;

            _this22._apply();

            $(".filter-accordion").accordion("option", "active", false);
          });

          if (this.field === "size" && item.value.toLowerCase() !== "others") {
            filterItem.innerHTML += "mm";
          }

          this._add(filterItem);
        },

        /** @override */
      },
      {
        key: "_getCheckboxFilterItem",

        value: function _getCheckboxFilterItem(name, value) {
          return {
            checked: SHOW_ALL_UNFILTERED_PRODUCT,
            domElement: undefined,
            name: name,
            value: value,
          };
        },
      },
      {
        key: "_updateHeader",

        value: function _updateHeader(name) {
          var _this23 = this;

          this._updateHeader2();

          var span = this._addLabel(name, "-selected");

          var removeBtn = this._addLabel("×", "-remove");

          var click = function click() {
            _this23._accordionHeader.removeChild(span);

            _this23._accordionHeader.removeChild(removeBtn);

            _this23.updateChecked(true);

            _this23._apply();

            removeBtn.removeEventListener("click", click);
          };

          removeBtn.addEventListener("click", click);
        },
      },
      {
        key: "_updateHeader2",

        value: function _updateHeader2() {
          var _this24 = this;

          this._accordionHeader.innerText = ""; // TODO add removeEventListener

          this._addLabel(this.name, "-selected");

          var removeBtn = this._addLabel("×", "-remove");

          var click = function click() {
            _this24._updateAllAccordionFilters(SHOW_ALL_UNFILTERED_PRODUCT);

            _this24._accordionHeader.innerText = "Select...";

            _this24._apply();

            removeBtn.removeEventListener("click", click);
          };

          removeBtn.addEventListener("click", click);
        },
      },
      {
        key: "_addLabel",

        value: function _addLabel(text, className) {
          var span = document.createElement("span");

          span.className = className;

          span.innerText = text;

          this._accordionHeader.appendChild(span);

          return span;
        },
      },
    ]);

    return AccordionFilter;
  })(CheckboxFilter);

  /* tslint:disable member-ordering object-literal-sort-keys */

  var SliderFilter = (function (_Filter2) {
    _inherits(SliderFilter, _Filter2);

    function SliderFilter(options, tiles, filterTilesList) {
      _classCallCheck(this, SliderFilter);

      var _this25 = _possibleConstructorReturn(
        this,
        (SliderFilter.__proto__ || Object.getPrototypeOf(SliderFilter)).call(
          this,
          options,
          tiles,
          filterTilesList
        )
      );

      _this25._parseValues();

      if (_this25._min !== undefined && _this25._max !== undefined) {
        _this25._createSlider();
      }

      return _this25;
    }

    /** @override */

    _createClass(SliderFilter, [
      {
        key: "match",

        value: function match(fieldValue) {
          var value = this._getCorrectNumber(fieldValue);

          return this._userMin <= value && this._userMax >= value;
        },
      },
      {
        key: "getValues",

        value: function getValues() {
          /* TODO */ return undefined;
        }, // TODO todo
      },
      {
        key: "setValues",

        value: function setValues(values) {}, // TODO todo
      },
      {
        key: "_parseValues",

        value: function _parseValues() {
          var _this26 = this;

          this._min = undefined;

          this._max = undefined;

          this._tiles.forEach(function (tile) {
            if (tile.surface === _this26.surface) {
              var value = _this26._getCorrectNumber(tile[_this26.field]);

              if (_this26._min === undefined || _this26._min > value) {
                _this26._min = value;
              }

              if (_this26._max === undefined || _this26._max < value) {
                _this26._max = value;
              }
            }
          });
        },
      },
      {
        key: "_createSlider",

        value: function _createSlider() {
          var _this27 = this;

          var slider = document.createElement("div");

          this._$slider = $(slider);

          this._userMin = this._min;

          this._userMax = this._max;

          this._createSupportButtons();

          this._add(slider);

          this._updateHeader(this._min, this._max);

          $(function () {
            _this27._$slider.slider({
              range: true,

              min: _this27._min,

              max: _this27._max,

              step: 0.01,

              values: [_this27._userMin, _this27._userMax],

              slide: function slide(event, ui) {
                return _this27._updateHeader(ui.values[0], ui.values[1]);
              },

              change: function change(event, ui) {
                _this27._userMin = ui.values[0];

                _this27._userMax = ui.values[1];

                _this27._apply();
              },
            });
          });
        },
      },
      {
        key: "_clickSupportButton",

        value: function _clickSupportButton() {
          this._$slider.slider("values", [this._min, this._max]);

          this._updateHeader(this._min, this._max);
        },
      },
      {
        key: "_createSupportButtons",

        value: function _createSupportButtons() {
          var buttons = _get(
            SliderFilter.prototype.__proto__ ||
              Object.getPrototypeOf(SliderFilter.prototype),
            "_createSupportButtons",
            this
          ).call(this);

          buttons.appendChild(this._createSupportButton("All"));

          return buttons;
        },
      },
      {
        key: "_updateHeader",

        value: function _updateHeader(min, max) {
          this._title.innerHTML =
            this.field === "price"
              ? Locale.lang(this.field) + ": $" + min + " - $" + max
              : Locale.lang(this.field) + ": " + min + " - " + max;
        },
      },
      {
        key: "_getCorrectNumber",

        value: function _getCorrectNumber(value) {
          var num = Number(value);

          if (isFinite(num)) {
            return num;
          }

          return 0;
        },
      },
    ]);

    return SliderFilter;
  })(Filter);

  var Filters = (function () {
    function Filters(tiles, room, onLoad) {
      var _this28 = this;

      _classCallCheck(this, Filters);

      this._loaded = false;

      this._searchWord = "";

      this._defaultFilters = [];

      this._resultCountElement = document.getElementById(
        "topPanelSearchResult"
      );

      this._list = [];

      if (JsConstants.config.useProductCategory) {
        this._categories = new ProductCategories(function () {
          _this28._filterTilesList();
        });
      }

      this._tiles = tiles;

      this._room = room;

      this._onLoad = onLoad;

      this.additionalSearchFields = String(
        JsConstants.config.ProductInfo.additionalSearchFields || ""
      ).split(",");

      if (JsConstants.config.productFilterSize) {
        this._defaultFilters.push({
          name: "Size",
          field: "size",
          surface: SurfaceType.Floor,
          type: FilterType.Checkbox,
        });

        this._defaultFilters.push({
          name: "Size",
          field: "size",
          surface: SurfaceType.Wall,
          type: FilterType.Checkbox,
        });

		this._defaultFilters.push({

			name: 'Size', field: 'size', surface: SurfaceType.Counter, type: FilterType.Checkbox

		});
      }

    //   if (JsConstants.config.productFilterFinish) {
    //     this._defaultFilters.push({
    //       name: "Finish",
    //       field: "finish",
    //       surface: SurfaceType.Floor,
    //       type: FilterType.Checkbox,
    //     });

    //     this._defaultFilters.push({
    //       name: "Finish",
    //       field: "finish",
    //       surface: SurfaceType.Wall,
    //       type: FilterType.Checkbox,
    //     });
    //   }

      $.ajax({
        url: "/get/filters",

        success: function success(loadedFilters) {
          _this28._init(loadedFilters);
        },
      });

      // TODO remove or optimize

      var accordionFilter =
        document.getElementsByClassName("accordion-filter")[0];

      if (accordionFilter) {
        var eventPath = function eventPath(e) {
          if ("path" in e) {
            return e.path;
          }

          if ("composedPath" in e) {
            return e.composedPath();
          }

          var path = [];

          var currentElem = e && e.target;

          while (currentElem) {
            path.push(currentElem);

            currentElem = currentElem.parentElement;
          }

          if (path.indexOf(window) === -1 && path.indexOf(document) === -1) {
            path.push(document);
          }

          if (path.indexOf(window) === -1) {
            path.push(window);
          }

          return path;
        };

        window.addEventListener("click", function (e) {
          if (e) {
            var path = eventPath(e);

            if (
              Array.isArray(path) &&
              path.some(function (element) {
                return element === accordionFilter;
              })
            ) {
              return;
            }

            $(".filter-accordion").accordion("option", "active", false);
          }
        });
      }
    }

    _createClass(Filters, [
      {
        key: "show",

        value: function show() {
          var _this29 = this;

          if (this._loaded && this._room.currentTiledSurface) {
            this._list.forEach(function (filter) {
              if (filter.surface === _this29._room.currentTiledSurface.type) {
                filter.show();
              } else {
                filter.hide();
              }
            });

            if (this._categories) {
              this._categories.show(this._room.currentTiledSurface.type);
            }

            this._filterTilesList();
          }
        },
      },
      {
        key: "find",

        value: function find(text) {
          if (this._loaded && this._room.currentTiledSurface) {
            this._searchWord = text ? text.toString().trim().toLowerCase() : "";

            this._find();
          }
        },
      },
      {
        key: "_find",

        value: function _find() {
          var _this30 = this;

          var foundTilesCount = 0;

          this._tiles.forEach(function (tile) {
            if (
              tile.li.hidedByFilter ||
              tile.li.rotoHidden ||
              tile.li.dataset.hidden === "hidden" ||
              tile.removed
            ) {
              return;
            }

            if (_this30._matchFields(tile)) {
              tile.show();

              foundTilesCount += 1;
            } else {
              tile.hide();
            }
          });
          console.log("Found Tiles Count = " + foundTilesCount);
          this._showFoundTilesCount(this._searchWord, foundTilesCount);

          this._tiles.showIcons();

          this._updateUrlParams();
        },
      },
      {
        key: "_matchFields",

        value: function _matchFields(tile) {
          var _this31 = this;

          var name = tile.name.toLowerCase();

          if (name.indexOf(this._searchWord) !== -1) {
            return true;
          }

          return this.additionalSearchFields.some(function (field) {
            var fieldText = tile[field.trim()];

            if (typeof fieldText === "string") {
              return (
                fieldText.trim().toLowerCase().indexOf(_this31._searchWord) !==
                -1
              );
            }
          });
        },
      },
      {
        key: "_showFoundTilesCount",

        value: function _showFoundTilesCount(searchWord, count) {

          if (!this._resultCountElement) {

              return;

          }

          if (searchWord) {

              this._resultCountElement.style.display = '';

              if (count === 1) {

                  this._resultCountElement.innerHTML = Locale.lang('FILTER_FOUND_ONE_TILE');

              } else if (count > 1) {

                  this._resultCountElement.innerHTML = Locale.lang('FILTER_FOUND_TILES', count);

              } else {

                  this._resultCountElement.innerHTML = Locale.lang('FILTER_TILES_NOT_FOUND');

              }

          } else if (count === 0 && JsConstants.config.showAllUnfilteredProduct) {

              this._resultCountElement.style.display = '';

              this._resultCountElement.innerHTML = Locale.lang('FILTER_TILES_NOT_FOUND');

          } else {

              this._resultCountElement.style.display = 'block';

              this._resultCountElement.innerHTML = count + " Tiles Found";

          }

      }
      },
      {
        key: "_init",

        value: function _init(loadedFilters) {
          var _this32 = this;

          var filtersList = Array.isArray(loadedFilters)
            ? this._defaultFilters.concat(loadedFilters)
            : this._defaultFilters;

          filtersList.forEach(function (filterOptions, index) {
            var filter = void 0;

            switch (filterOptions.type) {
              case FilterType.Checkbox:
                filter = new CheckboxFilter(
                  filterOptions,
                  _this32._tiles,
                  function () {
                    _this32._filterTilesList();
                  },
                  index
                );

                _this32._addFilter(filter);

                break;

              case FilterType.Slider:
                if (JsConstants.config.layout === "iorena.") {
                  return; // TODO Add SliderFilter for 'iorena' layout
                }

                filter = new SliderFilter(
                  filterOptions,
                  _this32._tiles,
                  function () {
                    _this32._filterTilesList();
                  }
                );

                _this32._addFilter(filter);

                break;

              case FilterType.Accordion:
                filter = new AccordionFilter(
                  filterOptions,
                  _this32._tiles,
                  function () {
                    _this32._filterTilesList();
                  },
                  index,
                  function (value) {
                    _this32._updateAllAccordionFilters(value);
                  }
                );

                _this32._addAccordionFilter(filter);

                break;

              default:
                console.warn("Unknown filter type " + filterOptions.type);
            }
          });

          this._applyUrlFilters();

          this._loaded = true;

          this.show();

          if (typeof this._onLoad === "function") {
            this._onLoad();
          }

          if (
            this._list.some(function (filter) {
              return filter.type === FilterType.Accordion;
            })
          ) {
            document.getElementById("topPanelAccordionFilter").style.display =
              "";

            $(".filter-accordion").accordion({
              active: false,

              collapsible: true,

              heightStyle: "content",
            });
          }
        },
      },
      {
        key: "_addAccordionFilter",

        value: function _addAccordionFilter(filter) {
          var topPanelFilter =
            document.getElementsByClassName("filter-accordion");

          topPanelFilter[0].appendChild(filter.domElement);

          this._list.push(filter);
        },
      },
      {
        key: "_addFilter",

        value: function _addFilter(filter) {
          var topPanelFilter = document.getElementById("topPanelFilter");

          topPanelFilter.appendChild(filter.domElement);

          this._list.push(filter);
        },
      },
      	{
            
		key: '_filterTilesList',
	
		value: function _filterTilesList() {
	
			var _this33 = this;
	
			//CODE BY TPS TO GET NUMBER OF CHECKBOXES CATEOGRY
	
			var forceSelectAll = false;
			if(totalFilterCheckboxesChecked()==0){
				forceSelectAll = true;
			}
			//EMD
			this._tiles.forEach(function (tile) {
	
				if (tile.li.rotoHidden || tile.li.dataset.hidden === 'hidden' || tile.removed) {
	
					return;
	
				}
	
				var correctSurface = !tile.surface || tile.surface === _this33._room.currentTiledSurface.type;
	
				var match = _this33._filterMatch(tile);
	
				//CODE BY TPS TO GET NUMBER OF CHECKBOXES CATEOGRY
				if(forceSelectAll==true){
					match = true;
				}
				//END
	
				var matchCategory = _this33._categories ? _this33._categories.match(tile, _this33._room.currentTiledSurface) : true;
	
	
				if (correctSurface && match && matchCategory || tile.custom) {
	
					// todo fix tile.custom
					tile.show();
	
					if (tile.li.hidedByFilter) {
	
						tile.li.hidedByFilter = false;
	
					}
	
				} else {
	
					tile.hide();
	
					if (!tile.li.hidedByFilter) {
	
						tile.li.hidedByFilter = true;
	
					}
	
				}
	
			});
	
			this._find(forceSelectAll);
	
			this._updateUrlParams();
	
		}
	
		},
		{

			key: '_filterMatch',

			value: function _filterMatch(tile) {

				var _this34 = this;



				var match = this._list.filter(function (filter) {
					//console.log("filter.type = " + filter.type + " - FilterType.Accordion = " + FilterType.Accordion);
					return filter.type !== FilterType.Accordion;

				}).every(function (filter) {
					//console.log("ilter.surface  = " + filter.surface + " - _this34._room.currentTiledSurface.type = " + _this34._room.currentTiledSurface.type);
					if (filter.surface !== _this34._room.currentTiledSurface.type) {

						return true;

					}

					//CODE BY TPS TO RESOLVE FILTER ISSUE
					var count = checkAllBlankCategories(filter.field,_this34._room.currentTiledSurface.type);

					if(count==0)
						return true;
					else
						return filter.match(tile[filter.field]);
					//END

				});

				var accordionFilters = this._list.filter(function (filter) {

					return filter.type === FilterType.Accordion;

				});

				if (accordionFilters.length === 0) {

					return match;

				}

				var accordionFilterMatch = accordionFilters.some(function (filter) {

					if (filter.surface !== _this34._room.currentTiledSurface.type) {

						return false;

					}

					return filter.match(tile[filter.field]);

				});

				return match && accordionFilterMatch;

			}

		},
		{
			key: "_applyUrlFilters",

			value: function _applyUrlFilters() {
			var url = new URL(window.location.href);

			var urlFilters = url.searchParams.get("filters");

			if (!urlFilters) {
				return;
			}

			var filters = JSON.parse(urlFilters);

			if (!filters) {
				return;
			}

			this._searchWord = filters.searchWord
				? filters.searchWord.toString().trim().toLowerCase()
				: "";

			$("#inputSearch").val(this._searchWord);

			this._list.forEach(function (filterItem) {
				if (!Array.isArray(filters.items)) {
				return;
				}

				var filter = filters.items.find(function (item) {
				return (
					filterItem.surface === item.surface &&
					filterItem.field === item.field
				);
				});

				if (filter) {
				filterItem.setValues(filter.values);
				}
			});
			},
		},
		{
			key: "_updateUrlParams",

			value: function _updateUrlParams() {
			if (!JsConstants.config.urlFilters) {
				return;
			}

			var filters = {
				searchWord: this._searchWord,

				items: this._list
				.map(function (item) {
					return item.getValues();
				})
				.filter(function (item) {
					return item;
				}),
			};

			var url = new URL(window.location.href);

			url.searchParams.set("filters", JSON.stringify(filters));

			history.pushState(null, "", url.href);
			},
		},
		{
			key: "_updateAllAccordionFilters",

			value: function _updateAllAccordionFilters(value) {
			this._list.forEach(function (filter) {
				if (filter.type === FilterType.Accordion) {
				filter.updateChecked2(value);
				}
			});
			},
		},
    ]);

    return Filters;
  })();

  var API = (function (window) {
    var vendor = "TracingIdea";

    var app = "TileVisualizer";

    if (!window[vendor]) window[vendor] = {};

    if (!window[vendor][app]) window[vendor][app] = {};

    var api = window[vendor][app];

    return {
      addMethod: function addMethod(name, method) {
        api[name] = method;
      },
    };
  })(window);

  // // import { UI } from '../InteriorUI.js';

  var tiles = [];

  var onTileClick = void 0;

  function Tile(tileData, index) {
    this.id = Number(tileData.id);

    this.index = index;

    this.custom = Boolean(tileData.custom);

    this.name = tileData.name || "";

    this.file = tileData.file || "";

    this.icon = tileData.icon || tileData.file;

    this.width = Number(tileData.width) || 400;

    this.height = Number(tileData.height) || 400;

    this.size = this.width + "x" + this.height;

    this.shape = tileData.shape || "square";

    this.surface = tileData.surface;

    this.grout = Number(tileData.grout) || 0;

    this.price = tileData.price;

    this.url = tileData.url;

    this.rotoPrintSetName = tileData.rotoPrintSetName || "";

    if (
      window.JsConstants.config.Product.rotoPrintSetAsName &&
      this.rotoPrintSetName
    ) {
      this.name = this.rotoPrintSetName;
    }

    this.created_at = tileData.created_at;

    this.shapePreparedSet =
      this.shape === "preparedSet" ||
      this.shape === "notionHerringbon" ||
      this.shape === "riverstoneRohmboid" ||
      this.shape === "rivertsoneChevron" ||
      this.shape === "stoneSystemCombo";

    this.parseExpandableProperties(tileData.expProps);

    this.finish = tileData.finish || ""; // glossy

    this.usedColors = tileData.usedColors || "";

    this.needsRotate = tileData.needsRotate;

    // this.highlighted = Boolean(this.buildersRange);

    if (tileData.li) {
      this.li = tileData.li;
    } else {
      this.createTileLi();
    }
  }

  (function () {
    this.preparedSetOffset = { x: 0, y: 0 };

    var rotoPrintSets = [];

    rotoPrintSets.add = function (setName, surface) {
      var name = setName.trim().toLowerCase();

      var itemExist = rotoPrintSets.some(function (rotoPrintSet) {
        return rotoPrintSet.name === name && rotoPrintSet.surface === surface;
      });

      if (!itemExist) {
        rotoPrintSets.push({ name: name, surface: surface });

        return true;
      }

      return false;
    };

    function selectTile(event, secondLayerTileIndex, secondLayer) {
      var tileIndex = secondLayer ? secondLayerTileIndex : this.dataset.index;

      if (typeof onTileClick === "function") {
        onTileClick(tileIndex, secondLayer);
      }
    }

    function setSecondLayerTile(event) {
      event.stopPropagation();

      selectTile(event, this.dataset.index, true);
    }

    this.parseExpandableProperties = function (expProps) {
      if (expProps) {
        var expandableProperties = JSON.parse(expProps);

        for (var propertyName in expandableProperties) {
          if (
            expandableProperties.hasOwnProperty(propertyName) &&
            !this.hasOwnProperty(propertyName)
          ) {
            this[propertyName] = expandableProperties[propertyName];
          }
        }
      }
    };

    this.getExtraOptionsText = function () {
      var _this35 = this;

      var htmlString = "";

      var options = window.JsConstants.config.tileExtraOptions;

      if (Array.isArray(options)) {
        options.forEach(function (option) {
          if (option && _this35.hasOwnProperty(option) && _this35[option]) {
            var optionText = Locale.lang(option, _this35[option]);

            htmlString += "<p>" + optionText + "</p>";
          }
        });
      }

      return htmlString;
    };

    this.getPriceText = function () {
      if (window.JsConstants.config.ProductInfo.price && this.price) {
        var priceText = Locale.lang("PRICE_TEMPLATE", this.price);

        return '<p class="-price">' + priceText + "</p>";
      }

      return "";
    };

    this.getInfoText = function () {
      var config = window.JsConstants.config.ProductInfo;

      var size = config.size
        ? "<p>" +
          Locale.lang("Size") +
          ": " +
          this.width +
          "mm x " +
          this.height +
          "mm</p>"
        : "";

      var finish =
        config.finish && this.finish
          ? "<p>" +
            Locale.lang("Finish") +
            ": " +
            Locale.lang(this.finish) +
            "</p>"
          : "";

      var url =
        config.url && this.url
          ? '<p><a href="' +
            this.url +
            '" target="blank">' +
            Locale.lang("PRODUCT_URL") +
            "</a></p>"
          : "";

      var usedColors =
        config.colors && this.usedColors
          ? "<p>" + Locale.lang("COLORS_USED") + ": " + this.usedColors + "</p>"
          : "";

      var shape = config.shape
        ? "<p>" + Locale.lang("Shape") + ": " + Locale.lang(this.shape) + "</p>"
        : "";

      var rotoPrintSet =
        config.rotoPrintSet && this.rotoPrintSetName
          ? "<p>" +
            Locale.lang("Roto Print Set") +
            ": " +
            Locale.lang(this.rotoPrintSetName) +
            "</p>"
          : "";

          if (config.style === 'Client3') {

            var urlBtn = url ? '<div class="-url"><p>Order Sample</p>' + url + '</div>' : '';

            return '<div class="tile-list-text">\n                    <p class="-caption">' + this.name + '</p>\n                    <div>' + this.getExtraOptionsText() + ' ' + this.getPriceText() + '</div>\n                    ' + urlBtn + '\n                </div>';

        }



        return '<div class="tile-list-text">\n                <p class="-caption">' + this.name + '</p>\n                ' + size.replace('Size: ', '') + '\n                ' + this.getExtraOptionsText().replace('product code: ', '') + '\n            </div>';


    };

    this.createTileLi = function () {
      this.iconImage = document.createElement("img");

      this.iconImage.class = "tile-list-thumbnail";

      var $imageHolder = $(
        '<div class="tile-list-thumbnail-image-holder"></div>'
      ).append(this.iconImage);

      var $tileText = $(this.getInfoText());

      var liClass = "top-panel-content-tiles-list-item";

      if (this.highlighted)
        liClass += " top-panel-content-tiles-list-item-highlighted";

      var $li = $('<li id="tile_' + this.index + 
        '" data-index="' + this.index + 
        '" data-surface="' + this.surface + 
        '"  data-tile="' + this.id + 
        '" class="' + liClass + 
        '" style="display: none;" onclick="getTileId(this.id)"></li>')
        .click(selectTile)
        .append($imageHolder, $tileText);

    var li = $li[0];

      if (this.rotoPrintSetName) {
        var rotoPrintSetAdded = rotoPrintSets.add(
          this.rotoPrintSetName,
          this.surface
        );

        if (!rotoPrintSetAdded) {
          li.rotoHidden = true;

          li.style.display = "none";
        }
      }

      if (
        this.shape === "square" ||
        this.shape === "rectangle" ||
        this.shape === "diamond"
      ) {
        var $btnLayer1 = $(
          '<button type="button" class="button-tile-list-choose-tile">1</button>'
        );

        var $btnLayer2 = $(
          '<button type="button" data-index="' +
            this.index +
            '" class="button-tile-list-choose-tile">2</button>'
        ).click(setSecondLayerTile);

        li.layer2btn = $btnLayer2[0];

        $li.append(
          $(
            '<div class="buttons-holder-tile-list-choose-tile" style="display: none;"></div>'
          ).append($btnLayer1, $btnLayer2)
        );
      }

      this.li = li;
    };

    this.getRotoPrintSet = function () {
      var _this36 = this;

      // return tiles.getRotoPrintSet(this);

      if (this.rotoPrintSetName && typeof this.rotoPrintSetName === "string") {
        var rotoPrintTiles = [];

        tiles.forEach(function (tile) {
          if (tile.rotoPrintSetName === _this36.rotoPrintSetName) {
            rotoPrintTiles.push(tile);
          }
        });

        return rotoPrintTiles;
      }

      return [this];
    };

    this.getRandomInSet = function () {
      // return tiles.getRotoPrintSet(this);

      var tilesSet = this.getRotoPrintSet();

      if (tilesSet.length > 1) {
        return tilesSet[Math.floor(Math.random() * tilesSet.length)];
      }

      return this;
    };

    this.hide = function () {
      if (this.li.style.display !== "none") this.li.style.display = "none";
    };

    this.show = function () {
      if (this.li.style.display !== "") this.li.style.display = "";
    };

    this.remove = function () {
      this.hide();

      this.removed = true;

      // todo clear surfaces
    };
  }).call(Tile.prototype);

  tiles.getById = function (tileId, custom) {
    var foundTile = void 0;

    var id = Number(tileId);

    if (!isNaN(id)) {
      this.some(function (tile) {
        if (tile.id === id && Boolean(tile.custom) === Boolean(custom)) {
          foundTile = tile;

          return true;
        }
      });
    }

    return foundTile;
  };

  tiles.getIndexById = function (id, custom) {
    var tile = tiles.getById(id, custom);

    return tile && tile.index;
  };

  tiles.isExist = function (id, custom) {
    return Boolean(tiles.getById(id, custom));
  };

  tiles.add = function (tileData) {
    if (tiles.isExist(tileData.id, tileData.custom)) return;

    var tile = new Tile(tileData, tiles.length);

    tiles.push(tile);

    return tile;
  };

  tiles.remove = function (id, custom) {
    var tile = tiles.getById(id, custom);

    if (tile) tile.remove();
  };
  tiles.copyAll = function () {
    // tiles.
  };

  tiles.getRotoPrintSet = function (tile) {
    return tile && tile.getRotoPrintSet();
  };

  tiles.getRandomInSet = function (tile) {
    return tile && tile.getRandomInSet();
  };

  tiles.updateLayerButtons = function (tileIndex) {
    tiles.forEach(function (tile) {
      if (tile.li.layer2btn) {
        if (
          tileIndex === undefined ||
          (tiles[tileIndex].shape !== "hexagon" &&
            tiles[tileIndex].width === tile.width &&
            tiles[tileIndex].height === tile.height)
        ) {
          tile.li.layer2btn.disabled = "";
        } else {
          tile.li.layer2btn.disabled = "disabled";
        }
      }
    });
  };

  tiles.showHideLayerButtons = function (surface, fillTypeIndex) {
    var display = "none";

    if (fillTypeIndex === 1) {
      display = "";

      tiles.updateLayerButtons(surface.tileIndex);
    } else {
      surface.tile2Index = undefined;
    }

    $(".buttons-holder-tile-list-choose-tile").css("display", display);
  };

  // isTilesSame

  tiles.isSame = function (item1, item2) {
    var tile1 =
      typeof item1 === "number"
        ? tiles[item1]
        : (typeof item1 === "undefined" ? "undefined" : _typeof(item1)) ===
          "object"
        ? item1
        : undefined;

    var tile2 =
      typeof item2 === "number"
        ? tiles[item2]
        : (typeof item2 === "undefined" ? "undefined" : _typeof(item2)) ===
          "object"
        ? item2
        : undefined;

    if (
      tile1 &&
      tile2 &&
      tile1.shape === tile2.shape &&
      tile1.width === tile2.width &&
      tile1.height === tile2.height
    ) {
      return true;
    }

    return false;
  };

  tiles.enabledPatternButtons = function (surface) {
    var tile = {};

    if (surface.tileIndex !== undefined) {
      tile = tiles[surface.tileIndex];
    }

    switch (tile.shape) {
      case undefined:
        break;

      case "square":

      case "rectangle":
        document.getElementById("topPanelSurfacePattern_1").disabled = "";

        document.getElementById("topPanelSurfacePattern_2").disabled = "";

        document.getElementById("topPanelSurfacePattern_3").disabled = "";

        break;

      case "diamond":
        if (surface.fillTypeIndex > 1) {
          surface.fillTypeIndex = 0;

          tiles.showHideLayerButtons(surface, 0);

          document.getElementById("topPanelSurfacePattern_0").checked = true;
        }

        document.getElementById("topPanelSurfacePattern_1").disabled = "";

        document.getElementById("topPanelSurfacePattern_2").disabled =
          "disabled";

        document.getElementById("topPanelSurfacePattern_3").disabled =
          "disabled";

        break;

      default:
        // hexagon and etc

        if (surface.fillTypeIndex > 0) {
          surface.fillTypeIndex = 0;

          tiles.showHideLayerButtons(surface, 0);

          document.getElementById("topPanelSurfacePattern_0").checked = true;
        }

        document.getElementById("topPanelSurfacePattern_1").disabled =
          "disabled";

        document.getElementById("topPanelSurfacePattern_2").disabled =
          "disabled";

        document.getElementById("topPanelSurfacePattern_3").disabled =
          "disabled";

        break;
    }

    if (tile.shapePreparedSet) {
      if (surface.rotation === 45 || surface.rotation === 135)
        surface.rotate(0);

      document.getElementById("topPanelSurfaceRotation_0").checked = true;

      document.getElementById("topPanelSurfaceRotation_45").disabled =
        "disabled";

      document
        .getElementById("topPanelSurfaceRotationLabel_45")
        .classList.add("disabled");

      document.getElementById("topPanelSurfaceRotation_135").disabled =
        "disabled";

      document
        .getElementById("topPanelSurfaceRotationLabel_135")
        .classList.add("disabled");
    } else {
      document.getElementById("topPanelSurfaceRotation_45").disabled = "";

      document
        .getElementById("topPanelSurfaceRotationLabel_45")
        .classList.remove("disabled");

      document.getElementById("topPanelSurfaceRotation_135").disabled = "";

      document
        .getElementById("topPanelSurfaceRotationLabel_135")
        .classList.remove("disabled");
    }
  };

  function showTileIcons() {
    // const indexes = tiles.map((tile, index) => index);

    var tilesListBox = document.getElementById("topPanelTilesListBox");

    var showIcons = function showIcons() {
      tiles.forEach(function (tile) {
        if (
          tile.iconImage &&
          !tile.iconImage.src &&
          tile.li.style.display !== "none" &&
          tile.li.offsetTop - tilesListBox.scrollTop <
            window.innerHeight + 1000 &&
          tile.li.offsetTop - tilesListBox.scrollTop > -1000
        ) {
          tile.iconImage.src = tile.icon;
        }
      });
    };

    tilesListBox.addEventListener("scroll", showIcons);

    showIcons();

    return showIcons;
  }

  function fillTilesList(tilesData) {
    if (Array.isArray(tilesData)) {
      tilesData.forEach(function (tileData) {
        return tiles.add(tileData);
      });
    }
  }

  function fillCustomTiles(loadedTiles) {
    function parseTileName(url) {
      if (url && typeof url === "string") {
        var fileName = url.match(/[^/]+(?=\.\w+$)/)[0].replace("_", " ");

        return fileName.charAt(0).toUpperCase() + fileName.slice(1);
      }

      return "Tile";
    }

    if (Array.isArray(loadedTiles)) {
      loadedTiles.forEach(function (tileData) {
        var settings = JSON.parse(tileData.settings);

        tiles.add({
          id: tileData.id,

          custom: true,

          name: parseTileName(settings.baseTileUrl),

          width: tileData.width,

          height: tileData.height,

          shape: tileData.shape,

          file: tileData.file,

          usedColors: settings.usedColorNames.join(" / "),

          needsRotate: tileData.shape === "hexagon",
        });
      });
    }
  }

  // @jscrambler define domainLock {domains:[app001.3droomvisualizer.com, sean.3dtilevisualizer.com, tilevisualizer.pavits.com, vis.florexceramic.in, visualizer.restile.com, visualizer.mahalaxmitiles.com, visualiser.sandstoneworks.com.au, visualiser.tiledepot.co.nz, simulator.stoneline.com.tr, visualizer2d.globalquartz.in, diy.saifurnitureindia.co.in, tilevisualizer.designtiles.com.au, tiledesigner.stile.com.pk, showroom.gulveogfliser.dk, tiledepot.3droomvisualizer.com, visualizer.metztiles.com.au, visualizer.metztiles.com.au, visualizer.alkhaleejceramics.com, floorsdirect.3droomvisualizer.com, tdcc2.3dtilevisualizer.com, simuladorfv.westus.cloudapp.azure.com, tilevisualiser.colortile.com.au, visualizer.cletile.com, floorvisualizer.welspunflooring.com, poplar.3dtilevisualizer.com, visualizer.topcarpetsandfloors.co.za, colorizer.prattandlarson.com]} as dL

  // @jscrambler enable dL

  tiles.load = function (onLoad, onClick) {
    $.ajax({
      url: "/get/tiles",

      success: function success(tilesData) {
        // console.log("get/Tiles:: ", tilesData);
        fillTilesList(tilesData);

        tiles.showIcons = showTileIcons();

        onLoad();

        onTileClick = onClick;
      },
    });
  };

  tiles.fill = function (onClick, loadedData) {
    fillTilesList(loadedData.tiles);

    fillCustomTiles(loadedData.userCustomTiles);

    fillCustomTiles(loadedData.roomCustomTiles);

    onTileClick = onClick;

    tiles.showIcons = showTileIcons();
  };

  /**

	 * Receive custom tile data and add it to Tiles list

	 */

  API.addMethod("addTile", function (tileData) {
    var tile = tiles.add(tileData);

    tile.show();

    tile.iconImage.src = tile.icon;

    var list = document.getElementById("topPanelTilesListUl");

    list.insertBefore(tile.li, list.firstChild); // todo move to UI.js
  });

  /**

	 * Remove custom tile data by id

	 */

  API.addMethod("removeTile", tiles.remove);
  function clearTiles() {
    tiles.map((tile) => {
      tile.tile3d = null;
    });
  }

  var TilesList = tiles;
  var TilesListWall = tiles;
  /**

	 * Code from https://github.com/shutterstock/changeDPI

	 */

  var JPEG = "image/jpeg";

  function changeDpiOnArray(dataArray, dpi, format) {
    if (format === JPEG) {
      dataArray[13] = 1; // 1 pixel per inch or 2 pixel per cm

      dataArray[14] = dpi >> 8; // dpiX high byte

      dataArray[15] = dpi & 0xff; // dpiX low byte

      dataArray[16] = dpi >> 8; // dpiY high byte

      dataArray[17] = dpi & 0xff; // dpiY low byte

      return dataArray;
    }
  }

  function changeDpiDataUrl(base64Image, dpi) {
    var dataSplitted = base64Image.split(",");

    var format = dataSplitted[0];

    if (format.indexOf(JPEG) !== -1) {
      var type = JPEG;

      var headerLength = (18 / 3) * 4;

      var body = dataSplitted[1];

      var stringHeader = body.substring(0, headerLength);

      var restOfData = body.substring(headerLength);

      var headerBytes = atob(stringHeader);

      var dataArray = new Uint8Array(headerBytes.length);

      for (var i = 0; i < dataArray.length; i += 1) {
        dataArray[i] = headerBytes.charCodeAt(i);
      }

      var finalArray = changeDpiOnArray(dataArray, dpi, type);

      var base64Header = btoa(
        String.fromCharCode.apply(String, _toConsumableArray(finalArray))
      );

      return [format, ",", base64Header, restOfData].join("");
    }

    return base64Image;
  }

  function makeIcon(canvas, maxSize) {
    $("#dialogSaveModalBox").modal("hide");

    var width = 100;

    var height = 100;

    var ratio = 1;

    ratio = canvas.width / canvas.height;

    if (canvas.width > canvas.height) {
      width = maxSize;

      height = Math.floor(maxSize / ratio);
    } else {
      width = Math.floor(maxSize * ratio);

      height = maxSize;
    }

    var iconCanvas = document.createElement("canvas");

    iconCanvas.width = width;

    iconCanvas.height = height;

    var iconCanvasContext = iconCanvas.getContext("2d");

    iconCanvasContext.drawImage(canvas, 0, 0, width, height);

    return iconCanvas.toDataURL();
  }

  function canvasImage(canvas) {
    $("#dialogSaveModalBox").modal("hide");

    // render();

    var imageCanvas = document.createElement("canvas");

    imageCanvas.width = canvas.width;

    imageCanvas.height = canvas.height;

    var imageCanvasContext = imageCanvas.getContext("2d");

    imageCanvasContext.drawImage(canvas, 0, 0, canvas.width, canvas.height);

    var companyLogo = document.getElementById("companyLogo");

    imageCanvasContext.drawImage(
      companyLogo,
      20,
      20,
      companyLogo.clientWidth,
      companyLogo.clientHeight
    );

    if (imageCanvas.msToBlob) {
      // for IE

      var blob = imageCanvas.msToBlob();

      window.navigator.msSaveBlob(blob, document.title + ".png");
    } else {
      var imgDataUrl = imageCanvas.toDataURL("image/jpeg");

      var link = document.createElement("a");

      if (typeof link.download === "string") {
        document.body.appendChild(link);

        link.href = changeDpiDataUrl(imgDataUrl, 300);

        link.download = document.title + ".jpg";

        link.click();

        document.body.removeChild(link);
      }
    }
  }

  function userRoom(room, roomSettings, engine, interiorUI) {
    var filters = window.JsConstants.config.urlFilters
      ? new URL(window.location.href).searchParams.get("filters")
      : undefined;

    $.ajax({
      method: "POST",

      url: "/userRoom/save",

      dataType: "json",

      data: {
        _token: $("meta[name=csrf-token]").attr("content"),

        roomId: room.id,

        url: room.savedUrl,

        engine: "",

        image: makeIcon(room.canvas, 1200),

        roomSettings: JSON.stringify(roomSettings),

        note: "?filters=" + encodeURIComponent(filters),
      },

      success: function success(response) {
        if (response.state === "success") {
          $("#savedRoomGoToUrl").hide();

          $("#savedRoomLogin").hide();

          var roomUrl = new URL(window.location.origin + response.fullUrl);

          if (filters) {
            roomUrl.searchParams.set("filters", filters);
          }

          $("#dialogSavedRoomUrlInput").val(roomUrl.href);

          if (!response.loggedIn) {
            $("#savedRoomLogin").show();
          }

          if (room.savedUrl !== response.url) {
            room.savedUrl = response.url;

            window.JsConstants.room.url = response.url;

            interiorUI.showAlert("Room saved to another url.");

            $("#savedRoomGoToUrl").attr("href", roomUrl.href);

            $("#savedRoomGoToUrl").show();
          }

          $("#dialogSavedRoomUrl").modal("show");

          history.pushState(null, "", roomUrl.href);
        } else {
          interiorUI.showAlert("The problem in saving room.", "error"); // response.state
        }
      },

      error: function error() {
        interiorUI.showAlert("The problem in saving room.", "error");
      },

      complete: function complete() {
        RoomLoadProgress.end();
      },
    });

    RoomLoadProgress.start();
  }

  // Only save room

  function userRoom2(room, roomSettings, engine, interiorUI, callback) {
    $.ajax({
      method: "POST",

      url: "/userRoom/save",

      dataType: "json",

      data: {
        _token: $("meta[name=csrf-token]").attr("content"),

        // roomId: 215,

        url: room.savedUrl,

        engine: "ai",

        image: makeIcon(room.canvas, 1200),

        roomSettings: JSON.stringify(roomSettings),
      },

      success: function success(response) {
        if (response.state === "success") {
          if (room.savedUrl !== response.url) {
            room.savedUrl = response.url;

            window.JsConstants.room.url = response.url;
          }

          if (typeof callback === "function") {
            callback();
          }
        } else {
          interiorUI.showAlert("The problem in saving room.", "error"); // response.state
        }
      },

      error: function error() {
        interiorUI.showAlert("The problem in saving room.", "error");
      },
    });
  }

  var Images = (function () {
    function getWidth(image) {
      return image.naturalWidth || image.width || 0;
    }

    function getHeight(image) {
      return image.naturalHeight || image.height || 0;
    }

    function canvasToBinaryJpeg(canvas) {
      var data = canvas
        .toDataURL("image/jpeg")
        .slice("data:image/jpeg;base64,".length);

      return atob(data);
    }

    function resizeImageStep(image, width, height) {
      var canvas = document.createElement("canvas");

      canvas.width = width;

      canvas.height = height;

      var ctx = canvas.getContext("2d");

      ctx.drawImage(image, 0, 0, canvas.width, canvas.height);

      return canvas;
    }

    function steppedResize(image, width, height) {
      var naturalWidth = getWidth(image);

      var naturalHeight = getHeight(image);

      if (naturalWidth <= width * 2 || naturalHeight <= height * 2) {
        return resizeImageStep(image, width, height);
      }

      var imageSmaller = resizeImageStep(
        image,
        naturalWidth / 2,
        naturalHeight / 2
      );

      return steppedResize(imageSmaller, width, height);
    }

    function getSizeInDrawArea(
      originalWidth,
      originalHeight,
      maxWidth,
      maxHeight,
      align
    ) {
      var size = {
        left: 0,

        top: 0,

        width: originalWidth,

        height: originalHeight,
      };

      if (originalWidth < maxWidth && originalHeight < maxHeight) {
        size.left = Math.floor((maxWidth - size.width) / 2);

        size.top = Math.floor((maxHeight - size.height) / 2);
      } else if (maxWidth && maxHeight) {
        var imageAspectRatio = originalWidth / originalHeight;

        if (maxWidth / maxHeight > imageAspectRatio) {
          size.height = maxHeight;

          size.width = maxHeight * imageAspectRatio;
        } else {
          size.width = maxWidth;

          size.height = maxWidth / imageAspectRatio;
        }

        if (size.width < maxWidth)
          size.left = Math.floor((maxWidth - size.width) / 2);

        if (size.height < maxHeight)
          size.top = Math.floor((maxHeight - size.height) / 2);
      }

      if (align === "left") {
        size.left = 0;
      } else if (align === "right") {
        size.left = maxWidth - size.width;
      }

      return size;
    }

    function resize(
      image,
      originalWidth,
      originalHeight,
      maxWidth,
      maxHeight,
      asCanvas,
      align
    ) {
      var size = getSizeInDrawArea(
        originalWidth,
        originalHeight,
        maxWidth,
        maxHeight,
        align
      );

      var canvas = document.createElement("canvas");

      canvas.width = Math.floor(maxWidth);

      canvas.height = Math.floor(maxHeight);

      var ctx = canvas.getContext("2d");

      ctx.fillStyle = "white";

      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.drawImage(image, size.left, size.top, size.width, size.height);

      if (asCanvas) return canvas;

      return canvasToBinaryJpeg(canvas);
    }

    return {
      // canvasToBinaryJpeg: canvasToBinaryJpeg,

      steppedResize: steppedResize,

      /**

			 * Rotates image only to 90, 180, 270 degree, default 90

			 *

			 * @param {HTMLImageElement|HTMLCanvasElement} image

			 * @param {number} deg

			 * @param {Object} options

			 * @param {string} options.background Sets background color

			 * @returns {HTMLCanvasElement}

			 */

      rotate: function rotate(image, deg, options) {
        if (image) {
          var canvas = document.createElement("canvas");

          var ctx = canvas.getContext("2d");

          var background = options && options.background;

          var areaSize = Math.max(canvas.width, canvas.height) * 2;

          if (background) {
            ctx.fillStyle = options.background;
          }

          switch (deg) {
            case 180:
              canvas.width = getWidth(image);

              canvas.height = getHeight(image);

              if (background)
                ctx.fillRect(-areaSize, -areaSize, areaSize, areaSize);

              ctx.rotate(Math.PI);

              ctx.drawImage(
                image,
                -canvas.width,
                -canvas.height,
                canvas.width,
                canvas.height
              );

              break;

            case 270:
              canvas.width = getHeight(image);

              canvas.height = getWidth(image);

              if (background)
                ctx.fillRect(-areaSize, -areaSize, areaSize, areaSize);

              ctx.rotate(4.71238898038469); // Math.PI * 3 / 2

              ctx.drawImage(
                image,
                -canvas.height,
                0,
                canvas.height,
                canvas.width
              );

              break;

            default:
              canvas.width = getHeight(image);

              canvas.height = getWidth(image);

              if (background)
                ctx.fillRect(-areaSize, -areaSize, areaSize, areaSize);

              ctx.rotate(1.5707963267948966); // Math.PI / 2

              ctx.drawImage(
                image,
                0,
                -canvas.width,
                canvas.height,
                canvas.width
              );
          }

          ctx.setTransform(1, 0, 0, 1, 0, 0);

          return canvas;
        }
      },

      adjustImage: function adjustImage(image, maxWidth, maxHeight) {
        return resize(
          image,
          getWidth(image),
          getHeight(image),
          maxWidth,
          maxHeight,
          true
        );
      },

      toCanvas: function toCanvas(image) {
        var canvas = document.createElement("canvas");

        canvas.width = getWidth(image);

        canvas.height = getHeight(image);

        var ctx = canvas.getContext("2d");

        ctx.fillStyle = "white";

        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);

        return canvas;
      },

      getLogo: function getLogo(maxWidth, maxHeight, align) {
        var logo = document.getElementById("companyLogo");

        if (maxWidth || maxHeight) {
          return resize(
            logo,
            getWidth(logo),
            getHeight(logo),
            maxWidth,
            maxHeight,
            true,
            align
          );
        }

        return this.toCanvas(logo);
      },

      toDataURL: function toDataURL(image) {
        var canvas = this.toCanvas(image);

        return canvas.toDataURL("image/png");
      },

      setBackground: function setBackground(image, htmlColor) {
        var canvas = document.createElement("canvas");

        var ctx = canvas.getContext("2d");

        canvas.width = getWidth(image);

        canvas.height = getHeight(image);

        ctx.fillStyle = htmlColor || "#ffffff";

        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);

        return canvas;
      },

      load: function load(url, onLoad, saveIndexes) {
        if (typeof onLoad !== "function") return;

        if (url && typeof url === "string") {
          var image = new Image();

          image.onload = function () {
            onLoad(image);
          };

          image.src = url;
        } else if (Array.isArray(url) && url.length > 0) {
          var images = [];

          var loadingCount = 0;

          if (saveIndexes === true) {
            var loadedCount = 0;

            url.forEach(function (url) {
              var image = void 0;

              if (url && typeof url === "string") {
                loadingCount += 1;

                image = new Image();

                image.onload = function () {
                  loadedCount += 1;

                  if (loadedCount === loadingCount) {
                    onLoad(images);
                  }
                };

                image.onerror = function () {
                  loadedCount += 1;

                  if (loadedCount === loadingCount) {
                    onLoad(images);
                  }
                };

                image.src = url;
              }

              images.push(image);
            });
          } else {
            url.forEach(function (url) {
              if (url && typeof url === "string") {
                loadingCount += 1;

                var _image = new Image();

                _image.onload = function () {
                  images.push(_image);

                  if (images.length === loadingCount) {
                    onLoad(images);
                  }
                };

                _image.src = url;
              }
            });
          }
        } else {
          onLoad();
        }
      },

      getFitSizes: function getFitSizes(image, maxWidth, maxHeight) {
        var increase =
          arguments.length > 3 && arguments[3] !== undefined
            ? arguments[3]
            : true;

        var naturalWidth = getWidth(image);

        var naturalHeight = getHeight(image);

        var imageAspect = naturalWidth / naturalHeight;

        var maxAspect = maxWidth / maxHeight;

        if (!increase && naturalWidth < maxWidth && naturalHeight < maxHeight) {
          return {
            width: naturalWidth,

            height: naturalHeight,

            left: (maxWidth - naturalWidth) / 2,

            top: (maxHeight - naturalHeight) / 2,
          };
        }

        if (imageAspect >= maxAspect) {
          var height = naturalHeight * (maxWidth / naturalWidth);

          return {
            width: maxWidth,

            height: height,

            left: 0,

            top: (maxHeight - height) / 2,
          };
        }

        var width = naturalWidth * (maxHeight / naturalHeight);

        return {
          width: width,

          height: maxHeight,

          left: (maxWidth - width) / 2,

          top: 0,
        };
      },
    };
  })();

  var ImageDoc = (function () {
    function ImageDoc() {
      var width =
        arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 210;

      var height =
        arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 297;

      var dpi =
        arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 144;

      _classCallCheck(this, ImageDoc);

      this._dpi = dpi;

      this._dpmm = dpi / 25.4; // Dot per mm

      this._width = width;

      this._height = height;

      this._fontSize = 10 * 0.35 * this._dpmm;

      this._fontType = "";

      this._fontFamily = "sans-serif";

      this.pages = [];

      this.addPage();
    }

    _createClass(ImageDoc, [
      {
        key: "addImage",

        value: function addImage(image, type, left, top, width, height) {
          if (width && height) {
            this._context.drawImage(
              image,
              left * this._dpmm,
              top * this._dpmm,
              width * this._dpmm,
              height * this._dpmm
            );
          } else {
            this._context.drawImage(
              image,
              left * this._dpmm,
              top * this._dpmm,
              image.width * (this._dpi / 96),
              image.height * (this._dpi / 96)
            );
          }

          return this;
        },
      },
      {
        key: "text",

        value: function text(_text, left, top) {
          var _this37 = this;

          var lines = String(_text).split("\n");

          lines.forEach(function (line, i) {
            var lineTop = top * _this37._dpmm + _this37._fontSize * 1.16 * i;

            _this37._context.fillText(line, left * _this37._dpmm, lineTop);
          });

          return this;
        },
      },
      {
        key: "addPage",

        value: function addPage() {
          this._page = document.createElement("canvas");

          this._page.width = this._width * this._dpmm;

          this._page.height = this._height * this._dpmm;

          this._context = this._page.getContext("2d");

          this._context.fillStyle = "#ffffff";

          this._context.fillRect(0, 0, this._page.width, this._page.height);

          this._context.fillStyle = "#000000";

          this._updateFont();

          this.pages.push(this._page);

          return this;
        },
      },
      {
        key: "line",

        value: function line(x0, y0, x1, y1) {
          this._context.beginPath();

          this._context.moveTo(x0 * this._dpmm, y0 * this._dpmm);

          this._context.lineTo(x1 * this._dpmm, y1 * this._dpmm);

          this._context.stroke();
        },
      },
      {
        key: "_updateFont",

        value: function _updateFont() {
          this._context.font =
            this._fontType + " " + this._fontSize + "px " + this._fontFamily;
        },
      },
      {
        key: "setFont",

        value: function setFont(fontName) {
          // , fontStyle

          if (fontName && typeof fontName === "string") {
            this._fontFamily = fontName;

            this._updateFont();
          }

          return this;
        },
      },
      {
        key: "setFontSize",

        value: function setFontSize(size) {
          var fontSize = Number(size);

          if (fontSize) {
            this._fontSize = fontSize * 0.35 * this._dpmm;

            this._updateFont();
          }

          return this;
        },
      },
      {
        key: "setFontType",

        value: function setFontType() {
          var type =
            arguments.length > 0 && arguments[0] !== undefined
              ? arguments[0]
              : "";

          type = type.toLowerCase();

          this._fontType = type.indexOf("bold") === -1 ? "" : "bold ";

          if (type.indexOf("normal") !== -1) {
            this._fontType += "normal";
          } else if (type.indexOf("italic") !== -1) {
            this._fontType += "italic";
          } else if (type.indexOf("oblique") !== -1) {
            this._fontType += "oblique";
          }

          this._updateFont();

          return this;
        },
      },
      {
        key: "save",

        value: function save(fileName) {
          var totalPages = this.pages.length;

          this.pages.forEach(function (page, i) {
            var pageNumber =
              totalPages > 1
                ? " (page " + (i + 1) + " of " + totalPages + ")"
                : "";

            var name = (fileName || document.title) + pageNumber;

            if (page.msToBlob) {
              // for IE

              var blob = page.msToBlob();

              window.navigator.msSaveBlob(blob, name + ".png");
            } else {
              var imgDataUrl = page.toDataURL("image/jpeg");

              var link = document.createElement("a");

              if (typeof link.download === "string") {
                document.body.appendChild(link);

                link.href = imgDataUrl;

                link.download = name + ".jpg";

                link.click();

                document.body.removeChild(link);
              }
            }
          });

          return this;
        },
      },
    ]);

    return ImageDoc;
  })();

  /* global jsPDF */

  var DPI = 96; // or 3.78 dorts per mm

  var PAGE_WIDTH = 210; // A4 8.27 × 11.7 or 210 × 297 mm

  var PAGE_HEIGHT = 297; // mm

  var MARGIN_TOP = 16; // mm

  var MARGIN_BOTTOM = MARGIN_TOP;

  var MARGIN_LEFT = 14; // mm

  var MARGIN_RIGHT = MARGIN_LEFT;

  var LINE_HEIGHT = 5; // mm

  var FONT_SIZE_HEADER = 16;

  var FONT_SIZE_TEXT = 9;

  var FONT_SIZE_CAPTION = 14;

  // function pointsToMilimeters(points) {

  //     return points / DPI * 25.4;

  // }

  function milimetersToPoints(milimeters) {
    var dpi =
      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DPI;

    return (milimeters / 25.4) * dpi;
  }

  /**

	 * Adds new page to pdf document if blockHeight not fits to page

	 *

	 * @param {jsPDF|ImageData} doc

	 * @param {number} currentLine

	 * @param {number} blockHeight

	 * @returns {number} currentLine

	 */

  function addNewPage(doc, currentLine, blockHeight) {
    if (currentLine + blockHeight > PAGE_HEIGHT - MARGIN_BOTTOM) {
      doc.addPage();

      return MARGIN_TOP;
    }

    return currentLine;
  }

  function getCategory(ids) {
    var categories = window.JsConstants.room.productCategories;

    if (!Array.isArray(categories) || categories.length === 0) return "";

    if (!Array.isArray(ids) || ids.length === 0) return "";

    var category = categories.find(function (cat) {
      return Number(cat.id) === Number(ids[0]);
    });

    if (!category) return "";

    if (!category.parent_id)
      return (
        Locale.lang("Category") + ": " + Locale.lang(category.name) + " \n"
      );

    var parentCategory = categories.find(function (cat) {
      return Number(cat.id) === Number(category.parent_id);
    });

    if (!parentCategory)
      return (
        Locale.lang("Category") + ": " + Locale.lang(category.name) + " \n"
      );

    return (
      Locale.lang("Category") +
      ": " +
      Locale.lang(parentCategory.name) +
      " / " +
      Locale.lang(category.name) +
      " \n"
    );
  }

  function getTileExtraOptionsText(tile) {
    var text = "";

    var options = window.JsConstants.config.tileExtraOptions;

    if (Array.isArray(options)) {
      options.forEach(function (option) {
        if (option && tile.hasOwnProperty(option) && tile[option]) {
          var optionText = Locale.lang(option, tile[option]);

          text += optionText + "\n";
        }
      });
    }

    return text;
  }

  function productInfoAssText(tile, surfaceName, surfaceIndex) {
    var config = window.JsConstants.config.ProductInfo;

    var size = config.size
      ? Locale.lang("Size") + ": " + tile.width + "mm x " + tile.height + "mm\n"
      : "";

    var finish =
      config.finish && tile.finish
        ? Locale.lang("Finish") + ": " + Locale.lang(tile.finish) + "\n"
        : "";

    var price =
      config.price && tile.price
        ? Locale.lang("Price") + ": " + tile.price + "\n"
        : "";

    var url =
      config.url && tile.url
        ? Locale.lang("Product page") + ": " + tile.url + "\n"
        : "";

    var shape = config.shape
      ? Locale.lang("Shape") + ": " + Locale.lang(tile.shape) + " \n"
      : "";

    var rotoPrintSet =
      config.rotoPrintSet && tile.rotoPrintSetName
        ? Locale.lang("Roto Print Set") +
          ": " +
          Locale.lang(tile.rotoPrintSetName) +
          " \n"
        : "";

    var category = config.category ? getCategory(tile.categories) : "";

    var extraOptions = getTileExtraOptionsText(tile);

    var usedColors =
      config.colors && tile.usedColors
        ? Locale.COLORS_USED + ": " + tile.usedColors + "\n"
        : "";

    if (usedColors.length > 55) {
      var colors = usedColors.split(" / ");

      colors[3] = "\n" + colors[3];

      usedColors = colors.join(" / ");
    }

    return {
      surfaceName: Locale.lang(surfaceName),

      surfaceIndex: surfaceIndex,

      tile: tile,

      // file: tile.file,

      // name: tile.name,

      // shape: tile.shape,

      text:
        size +
        shape +
        finish +
        price +
        url +
        category +
        extraOptions +
        usedColors +
        rotoPrintSet,
    };
  }

  function getSurfaceGroups(surfaces) {
    var groupIds = [];

    var surfaceGroups = [];

    surfaces.forEach(function (surface) {
      if (!surface.group || groupIds.indexOf(surface.group) === -1) {
        groupIds.push(surface.group);

        surfaceGroups.push(surface);
      }
    });

    return surfaceGroups;
  }

  function addProductInfo(room, tiles) {
    var productInfoTilesList = [];

    var surfaceGroups = getSurfaceGroups(room.tiledSurfaces);

    surfaceGroups.forEach(function (surface, index) {
      var tileApplied =
        typeof surface.tileIndex !== "undefined" ||
        typeof surface.tile2Index !== "undefined" ||
        (surface.freeDesignTiles && surface.freeDesignTiles.length > 0);

      if (tileApplied) {
        var usedTileIds = [];

        if (!surface.name) {
          if (room.surfaceTypes && surface.type) {
            surface.name = room.surfaceTypes[surface.type];
          } else if (surface.type) {
            surface.name = surface.type;
          } else {
            surface.name = "Surface " + (1 + index);
          }
        }

        if (surface.tileIndex !== undefined) {
          productInfoTilesList.push(
            productInfoAssText(tiles[surface.tileIndex], surface.name, index)
          );

          usedTileIds.push({
            id: tiles[surface.tileIndex].id,

            custom: tiles[surface.tileIndex].custom,
          });
        }

        if (
          surface.tile2Index !== undefined &&
          surface.tile2Index !== surface.tileIndex
        ) {
          productInfoTilesList.push(
            productInfoAssText(tiles[surface.tile2Index], surface.name, index)
          );

          usedTileIds.push({
            id: tiles[surface.tile2Index].id,

            custom: tiles[surface.tile2Index].custom,
          });
        }

        if (surface.freeDesignTiles) {
          surface.freeDesignTiles.forEach(function (freeDesignTile) {
            var tileUsed = usedTileIds.some(function (usedTile) {
              return (
                freeDesignTile.id === usedTile.id &&
                freeDesignTile.custom === usedTile.custom
              );
            });

            if (!tileUsed) {
              var tile = tiles.getById(
                freeDesignTile.id,
                freeDesignTile.custom
              );

              productInfoTilesList.push(
                productInfoAssText(tile, surface.name, index)
              );

              usedTileIds.push({
                id: freeDesignTile.id,

                custom: freeDesignTile.custom,
              });
            }
          });
        }
      }
    });

    return productInfoTilesList;
  }

  function addWatermark(canvas) {
    var logo = document.getElementById("companyLogo");

    var width = logo.naturalWidth || logo.width;

    var height = logo.naturalHeight || logo.height;

    var widthScale = canvas.width / 3 / width;

    var heightScale = canvas.height / 3 / height;

    var scale = Math.min(widthScale, heightScale);

    var ctx = canvas.getContext("2d");

    ctx.globalAlpha = window.JsConstants.config.watermarkedAlpha || 0.15;

    ctx.drawImage(
      logo,
      (canvas.width - width * scale) / 2,
      (canvas.height - height * scale) / 2,
      width * scale,
      height * scale
    );

    return canvas;
  }

  /**

	 * Create PDF using jsPDF require jsPDF.min.js

	 * Or crete Image using ImageDoc

	 *

	 * Page size in pixels for drawing images:

	 * A4: [595.28, 841.89]

	 * LETTER: [612.00, 792.00],

	 *

	 * @param {Object} room

	 * @param {Array} tiles

	 * @param {String} docType set 'image' to create ImageDoc

	 * @param {Boolean} pdfAsImage set true to save ImageDoc to PDF

	 */

  function saveDoc(room, tiles, docType, pdfAsImage) {
    var tilesInfo = addProductInfo(room, tiles);

    var urls = tilesInfo.map(function (tileInfo) {
      return tileInfo.tile.file;
    });

    Images.load(
      urls,
      function (tileImages) {
        $("#dialogSaveModalBox").modal("hide");

        var currentLine = MARGIN_TOP;

        var doc =
          docType === "image" ? new ImageDoc(210, 297, 300) : new jsPDF(); // eslint-disable-line new-cap

        var headerWidth = 0;

        if (window.JsConstants.config.pdfHeaderText) {
          headerWidth = window.JsConstants.config.pdfHeaderTextWidth;

          var lines = window.JsConstants.config.pdfHeaderText.split(",");

          doc.setFontSize(FONT_SIZE_CAPTION);

          currentLine -= 3;

          lines.forEach(function (line) {
            doc.text(
              line,
              PAGE_WIDTH - MARGIN_RIGHT - headerWidth,
              (currentLine += LINE_HEIGHT + 2)
            );
          });

          currentLine += LINE_HEIGHT;
        }

        var logoMaxWidth = window.JsConstants.config.pdfHeaderText
          ? PAGE_WIDTH - MARGIN_LEFT - MARGIN_RIGHT - 5 - headerWidth
          : PAGE_WIDTH - MARGIN_LEFT - MARGIN_RIGHT;

        var logoWidth = milimetersToPoints(
          Math.min(logoMaxWidth, window.JsConstants.config.pdfLogoMaxWidth)
        );

        var logo = Images.getLogo(
          logoWidth,
          96,
          window.JsConstants.config.pdfLogoAlign
        );

        doc.addImage(logo, "JPEG", MARGIN_LEFT, MARGIN_TOP);

        if (currentLine < MARGIN_TOP + 35) {
          currentLine = MARGIN_TOP + 35;
        }

        var ratio = room.canvas.width / room.canvas.height;

        var imageWidth = PAGE_WIDTH - (MARGIN_LEFT + MARGIN_RIGHT);

        var imageHeight = imageWidth / ratio;

        var watermarkedImage = addWatermark(room.canvas, logo);

        doc.addImage(
          watermarkedImage,
          "JPEG",
          MARGIN_LEFT,
          currentLine,
          imageWidth,
          imageHeight
        );

        currentLine += imageHeight + LINE_HEIGHT;

        var lastSurfaceIndex = void 0;

        var tileImageMaxWidth = 25;

        var tileImageMaxHeight = tileImageMaxWidth;

        tilesInfo.forEach(function (tileInfo, i) {
          currentLine = addNewPage(
            doc,
            currentLine,
            tileImageMaxHeight + LINE_HEIGHT * 2
          );

          if (lastSurfaceIndex !== tileInfo.surfaceIndex) {
            lastSurfaceIndex = tileInfo.surfaceIndex;

            doc.setFontSize(FONT_SIZE_CAPTION).setFontType("normal");

            doc.text(
              tileInfo.surfaceName,
              MARGIN_LEFT,
              (currentLine += LINE_HEIGHT)
            );

            doc.line(
              MARGIN_LEFT,
              (currentLine += 2),
              PAGE_WIDTH - MARGIN_RIGHT,
              currentLine
            ); // horizontal line
          }

          var tileImage = Images.adjustImage(tileImages[i], 256, 256);

          doc.addImage(
            tileImage,
            "JPEG",
            MARGIN_LEFT,
            (currentLine += 2),
            tileImageMaxWidth,
            tileImageMaxHeight
          );

          doc.setFontSize(FONT_SIZE_CAPTION).setFontType("bold");

          doc.text(
            tileInfo.tile.name,
            MARGIN_LEFT + tileImageMaxHeight + 6,
            currentLine + LINE_HEIGHT
          );

          doc.setFontSize(FONT_SIZE_TEXT).setFontType("normal");

          doc.text(
            tileInfo.text,
            MARGIN_LEFT + tileImageMaxHeight + 6,
            currentLine + LINE_HEIGHT * 2
          );

          currentLine += tileImageMaxHeight + LINE_HEIGHT;
        });

        if (pdfAsImage) {
          var pdf = new jsPDF(); // eslint-disable-line new-cap

          doc.pages.forEach(function (page, i) {
            if (i > 0) pdf.addPage();

            pdf.addImage(page, "JPEG", 0, 0, 210, 297);
          });

          pdf.save(Locale.PDF_VISUALIZER_FILE + ".pdf");
        } else {
          var fileExtension = docType === "image" ? "" : ".pdf";

          doc.save(Locale.PDF_VISUALIZER_FILE + fileExtension);
        }
      },
      true
    );
  }

  /**

	 * Create PDF using pdfmake (http://pdfmake.org)

	 * require pdfmake.min.js and vfs_fonts.js

	 *

	 * Page size in pixels for drawing images:

	 * A4: [595.28, 841.89] 72 DPI

	 * LETTER: [612.00, 792.00],

	 *

	 * @param {Object} room

	 * @param {Array} tiles

	 */

  function docVisualizer(room, tiles) {
    window.$("#dialogSaveModalBox").modal("hide");

    loadingAnimation.show();

    var tilesInfo = addProductInfo(room, tiles);

    var urls = tilesInfo.map(function (tileInfo) {
      return tileInfo.tile.file;
    });

    var logoMaxWidth = window.JsConstants.config.pdfHeaderText
      ? PAGE_WIDTH -
        MARGIN_LEFT -
        MARGIN_RIGHT -
        5 -
        window.JsConstants.config.pdfHeaderTextWidth
      : PAGE_WIDTH - MARGIN_LEFT - MARGIN_RIGHT;

    var logoWidth = milimetersToPoints(
      Math.min(logoMaxWidth, window.JsConstants.config.pdfLogoMaxWidth),
      72
    );

    Images.load(
      urls,
      function (tileImages) {
        var header = window.JsConstants.config.pdfHeaderText
          ? {
              columns: [
                {
                  width: milimetersToPoints(logoMaxWidth, 72),

                  image: Images.getLogo().toDataURL("image/png"),

                  fit: [logoWidth, 72],

                  alignment: window.JsConstants.config.pdfLogoAlign,

                  margin: [5, 0, 0, 5],
                },
                {
                  text: window.JsConstants.config.pdfHeaderText.replace(
                    /,/g,
                    "\n"
                  ),

                  fontSize: FONT_SIZE_HEADER,
                },
              ],
            }
          : {
              width: milimetersToPoints(logoMaxWidth, 72),

              image: Images.getLogo().toDataURL("image/png"),

              fit: [logoWidth, 72],

              alignment: window.JsConstants.config.pdfLogoAlign,
            };

        var doc = {
          content: [
            header,
            {
              image: room.canvas.toDataURL("image/png"),

              fit: [
                milimetersToPoints(PAGE_WIDTH - MARGIN_LEFT - MARGIN_RIGHT, 72),
                320,
              ],

              alignment: "center",

              margin: [0, 10, 0, 10],
            },
          ],
        };

        var point = document.createElement("canvas");

        point.width = 1;

        point.height = 1;

        var ctx = point.getContext("2d");

        ctx.fillStyle = "#888888";

        ctx.fillRect(0, 0, 1, 1);

        var lastSurfaceIndex = void 0;

        tilesInfo.forEach(function (tile, i) {
          if (lastSurfaceIndex !== tile.surfaceIndex) {
            lastSurfaceIndex = tile.surfaceIndex;

            doc.content.push([
              {
                text: tile.surfaceName,

                margin: [5, 5, 5, 0],
              },
              {
                image: point.toDataURL("image/png"),

                width: milimetersToPoints(
                  PAGE_WIDTH - MARGIN_LEFT - MARGIN_RIGHT,
                  72
                ),

                height: 1,
              },
            ]);
          }

          doc.content.push({
            columns: [
              {
                width: 100,

                image: Images.adjustImage(tileImages[i], 256, 256).toDataURL(
                  "image/png"
                ),

                fit: [84, 84],

                margin: [0, 5],
              },
              [
                {
                  text: tile.tile.name,

                  bold: true,

                  margin: [0, 5, 0, 3],
                },
                {
                  text: tile.text,

                  fontSize: 10,

                  margin: [0, 0, 0, 5],
                },
              ],
            ],
          });
        });

        window.pdfMake
          .createPdf(doc)
          .download(Locale.PDF_VISUALIZER_FILE, function () {
            loadingAnimation.hide();
          });
      },
      true
    );
  }

  function saveRoomPdf(room, tiles) {
    if (window.JsConstants.config.pdfLib === "pdfMake") {
      docVisualizer(room, tiles); // using pdfMake lib
    } else {
      saveDoc(room, tiles); // using jsPDF lib
    }
  }

  function imageAsDoc(room, tiles) {
    saveDoc(room, tiles, "image");
  }

  /**

	 * Class for prepare and work with ColorPicker

	 *

	 * see

	 * https://tovic.github.io/color-picker

	 */

  /* global CP */

  var ColorPicker = (function () {
    function ColorPicker(elementId, onUpdate) {
      var _this38 = this;

      _classCallCheck(this, ColorPicker);

      if (!elementId && typeof elementId !== "string") return;

      if (typeof onUpdate !== "function") return;

      this._target = document.getElementById(elementId);

      if (!this._target) return;

      this._picker = new CP(this._target);

      /**

			 * default color Red

			 * to set default color use data-color="#ffffff"

			 * or uncomment this line

			 */

      // this.set('#ffffff');

      this._picker.on("exit", function () {
        return _this38._onPickEnd(onUpdate);
      });

      this._picker.on("stop", function () {
        return _this38._onPickEnd(onUpdate);
      });

      this._picker.on("change", function (color) {
        return _this38._updateTarget(color);
      });
    }

    _createClass(ColorPicker, [
      {
        key: "set",

        value: function set(color) {
          if (this._picker) {
            this._picker.set(color);

            this._updateTarget(color);
          }
        },
      },
      {
        key: "_onPickEnd",

        value: function _onPickEnd(onUpdate) {
          var color = "#" + CP._HSV2HEX(this._picker.get());

          if (this._currentColor !== color) {
            this._currentColor = color;

            onUpdate(color);
          }
        },
      },
      {
        key: "_updateTarget",

        value: function _updateTarget() {
          var color = "#" + CP._HSV2HEX(this._picker.get());

          this._target.setAttribute("data-color", color);

          this._target.value = color;

          this._target.style.background = color;
        },
      },
    ]);

    return ColorPicker;
  })();

  /** @abstract */

  var Room = (function () {
    function Room(data) {
      _classCallCheck(this, Room);

      Object.assign(this, data.roomData);

      this.savedUrl = data.url; // todo optimize
      this.tiledSurfaces = [];
      this._ui = new UI(this);
      this._createView(data);
      this._fillTiles(data);
      this._initElements();
    }

    _createClass(Room, [
      {
        key: "_createView",
        value: function _createView() {
          /** Needs override */
        },
      },
      {
        key: "_getSettings",
        value: function _getSettings() {
          return {
            surfaces: this.tiledSurfaces.map(function (tiledSurface) {
              return tiledSurface.getSettings();
            }),
          };
        },
      },
      {
        key: "_save",
        value: function _save() {
          var settings = this._getSettings();
          userRoom(this, settings, this._engineType, this._ui);
        },
      },
      {
        key: "_share",
        value: function _share(event) {
          event.preventDefault();
          var settings = this._getSettings();
          var _this = this;
          userRoom2(this, settings, this._engineType, this._ui, function () {
            return _this._ui.share(event);
          });
        },
      },
      {
        key: "_isSurfaceSelected",
        value: function _isSurfaceSelected() {
          if (this.currentTiledSurface) return true;

          this._ui.showAlert(
            "Surface not selected. To select surface click on wall or floor.",
            "warning"
          );

          return false;
        },
      },
      {
        key: "_setSurfaceColor",
        value: function _setSurfaceColor(color) {
          if (!this._isSurfaceSelected()) return;
          this._getGroupSurfaces(this.currentTiledSurface).forEach(function (
            surface
          ) {
            return surface.setColor(color);
          });
        },
      },
      {
        key: "_setGroutSize",
        value: function _setGroutSize(event) {
          if (!this._isSurfaceSelected()) return;
          var value = event?.currentTarget?.value;
          this._getGroupSurfaces(this.currentTiledSurface).forEach(function (
            surface
          ) {
            return surface.setGroutSize(value);
          });
          this._ui.changeGroutSize(this.currentTiledSurface.groutSize);
        },
      },
      {
        key: "_setGroutColor",
        value: function _setGroutColor(color) {
          if (!this._isSurfaceSelected()) return;
          this._getGroupSurfaces(this.currentTiledSurface).forEach(function (
            surface
          ) {
            return surface.setGroutColor(color);
          });
        },
      },
      {
        key: "_setGroutColorPredefined",
        value: function _setGroutColorPredefined(event) {
          if (!this._isSurfaceSelected()) return;

          const color = event?.currentTarget?.dataset?.color;
          if (color) {
            this._getGroupSurfaces(this.currentTiledSurface).forEach(
              (surface) => {
                return surface.setGroutColor(color);
              }
            );
          }

          this._groutColorPicker.set(color);
        },
      },
      {
        key: "_setCheckFreeDesign",
        value: function _setCheckFreeDesign(event) {
          if (!this._isSurfaceSelected()) return;
          var checked = event?.currentTarget?.checked;
          this._getGroupSurfaces(this.currentTiledSurface).forEach(function (
            surface
          ) {
            return surface.setFreeDesign(checked);
          });
        },
      },
      {
        key: "_setPattern",
        value: function _setPattern(event) {
          if (!this._isSurfaceSelected()) return;
          var value = event?.currentTarget?.value;
          this._getGroupSurfaces(this.currentTiledSurface).forEach(function (
            surface
          ) {
            surface.setFillType(value);
            TilesList.showHideLayerButtons(surface, surface.fillTypeIndex);
          });
          this._ui.updateSkewSizeButtons(
            this.currentTiledSurface.fillTypeIndex
          );
        },
      },
      {
        key: "_setSkewSize",
        value: function _setSkewSize(event) {
          if (!this._isSurfaceSelected()) return;
          var value = event?.currentTarget?.value;
          this._getGroupSurfaces(this.currentTiledSurface).forEach(function (
            surface
          ) {
            return surface.setSkewSize(value);
          });
        },
      },
      {
        key: "_setPatternRotation",
        value: function _setPatternRotation(event) {
          if (!this._isSurfaceSelected()) return;
          var value = event?.currentTarget?.value;
          this._getGroupSurfaces(this.currentTiledSurface).forEach(function (
            surface
          ) {
            return surface.rotate(value);
          });
        },
      },
      {
        key: "_find",
        value: function _find(event) {
          var value = event?.currentTarget?.value;
          this._filters.find(value);
        },
      },
      {
        key: "_showRoomInfo",
        value: function _showRoomInfo() {
          this._ui.addProductInfo(this, TilesList);
          this._ui.switchTopPanel("productInfoPanel");
        },
      },
      {
        key: "_getGroupSurfaces",
        value: function _getGroupSurfaces(currentSurface) {
          if (!currentSurface.group) return [currentSurface];
          return this.tiledSurfaces.filter(function (surface) {
            return surface.group === currentSurface.group;
          });
        },
      },
      {
        key: "_clear",
        value: function _clear() {
          this.tiledSurfaces.forEach(function (surface) {
            return surface.removeAllTiles();
          });
          // TilesList.forEach(tile => {
          //   if(tile.tile3d==null){

          //   }
          // });
        },
      },
      {
        key: "_onTileClick",
        value: function _onTileClick(tileIndex, secondLayer) {
          if (!this._isSurfaceSelected()) return;
          var surface = this.currentTiledSurface;
          var surfaces = this._getGroupSurfaces(surface);
          var tile = TilesList[tileIndex];
          if (surface.freeDesign) {
            surfaces.forEach(function (surface) {
              return surface.setFreeDesignTile(tile);
            });
          } else if (secondLayer) {
            surfaces.forEach(function (surface) {
              return surface.setTile2(tile);
            });
          } else {
            if (surface.tile2 && !TilesList.isSame(tile, surface.tile2)) {
              surfaces.forEach(function (surface) {
                return surface.clearTile2();
              });
            }
            surfaces.forEach(function (surface) {
              surface.setTile(tile);
              TilesList.enabledPatternButtons(surface);
            });
            TilesList.updateLayerButtons(tileIndex);
            this._ui.changeGroutSize(surface.groutSize);
          }
          if (window.JsConstants.config.useProductCategory && this._filters)
            this._filters.show();
          this._ui.topPanelHide();
          this._ui.hideProductInfoPanel();
        },
      },
      {
        key: "_onSurfaceClick",
        value: function _onSurfaceClick(surface) {
          this.currentTiledSurface = surface;
          
          // Set the surface name in the Blade file - Added by TPS
          document.getElementById("optionText").textContent = surface.type.charAt(0).toUpperCase() + surface.type.slice(1);


          var topPanel = document.getElementById("topPanel");
          if (topPanel && topPanel.style.display !== "flex") {
            this._ui.switchTopPanel("topPanel", "flex");
          }
          var rotate = document.getElementById(
            "topPanelCheckFreeDesignRotate"
          ).checked;
          if (
            (rotate && (surface.tile || surface.tile2)) ||
            (surface.freeDesign && surface.freeDesignTile)
          ) {
            this._ui.topPanelHide();
          } else {
            this._ui.topPanelShow();
          }
          if (this._filters) this._filters.show();
          TilesList.enabledPatternButtons(surface);
          TilesList.showHideLayerButtons(surface, surface.fillTypeIndex);
          this._ui.updateValues(surface);
          this._groutColorPicker.set(surface.groutColor);
          this._surfaceColorPicker.set(surface.color);
          this._ui.hideProductInfoPanel();
        },
      },
      {
        key: "_fillTiles",
        value: function _fillTiles(data) {
          var _this = this;
          var onClick = function onClick(tileIndex, secondLayer) {
            return _this._onTileClick(tileIndex, secondLayer);
          };
          TilesList.fill(onClick, data);
          this._ui.tiles = TilesList;
          var sortOrder = $("topPanelTilesSort").val();
          this._ui.addTilesToList(sortOrder);
          this._filters = new Filters(
            TilesList,
            this,
            this._ui.hideTilesPreloader
          );
          this._ui.filtersShow = function () {
            return _this._filters.show();
          };
        },
      },
      {
        key: "_initElements",
        value: function _initElements() {
          // // Clean up old event handlers
          this._clear();
          var _this41 = this;
          $("#inputSearch").off("input");
          $("#topPanelGroutSizeRange").off("change");
          $("#grout-predefined-color .-btn").off("click");
          $("#topPanelCheckFreeDesign").off("change");
          $(".radio-surface-pattern > input").off("change");
          $(".radio-surface-pattern > li").off("click");
          $(".radio-skew-size input").off("change");
          $(".radio-surface-rotation > input").off("click");
          $(".radio-surface-rotation > li").off("click");
          $("#bottomMenuRoomInfo").off("click");
          $("#btnDialogSaveImage").off("click");
          $("#btnDialogSavePdf").off("click");
          $("#btnDialogSaveScene").off("click");
          $(".social-share a").off("click");
          $("#bottomMenuMail").off("click");
          $(".clear-all").off("click");
          $("#shadow-menu").off();

          // Use arrow functions to preserve context
            $('#inputSearch').on('input', function (event) {

                return _this41._find(event);

            });
            $('#topPanelGroutSizeRange').change(function (event) {

                return _this41._setGroutSize(event);

            });
            this._groutColorPicker = new ColorPicker('grout-color-picker', function (color) {

                return _this41._setGroutColor(color);

            });
            $('#grout-predefined-color .-btn').click(function (event) {

            return _this41._setGroutColorPredefined(event);

            });
            this._surfaceColorPicker = new ColorPicker('surface-color-picker', function (color) {

                return _this41._setSurfaceColor(color);

            });
            $("#topPanelCheckFreeDesign").change((event) =>
                this._setCheckFreeDesign(event)
            );
            $(".radio-surface-pattern > input").change((event) =>
                this._setPattern(event)
            );
            $(".radio-surface-pattern > li").click((event) =>
                this._setPattern(event)
            );
            $(".radio-skew-size input").change((event) =>
                this._setSkewSize(event)
            );
            //   $(".radio-surface-rotation > input").click((event) =>
            //     this._setPatternRotation(event)
            //   );
            //   $(".radio-surface-rotation > li").click((event) =>
            //     this._setPatternRotation(event)
            //   );

            //CODE BY TPS

            $("#topPanelSurfaceRotation_0").click(function (event) {
                return _this41._setPatternRotation(event);
            });
            $("#topPanelSurfaceRotation_45").click(function (event) {
                return _this41._setPatternRotation(event);
            });
            $("#topPanelSurfaceRotation_90").click(function (event) {
                return _this41._setPatternRotation(event);
            });
            $("#topPanelSurfaceRotation_135").click(function (event) {
                return _this41._setPatternRotation(event);
            });
            $("#topPanelSurfaceRotation_180").click(function (event) {
                return _this41._setPatternRotation(event);
            });


          $("#bottomMenuRoomInfo").click(() => this._showRoomInfo());
          if (window.JsConstants.config.saveImageAsDoc) {
            $("#btnDialogSaveImage").click(() => imageAsDoc(this, TilesList));
          } else {
            $("#btnDialogSaveImage").click(() => canvasImage(this.canvas));
          }
          $("#btnDialogSavePdf").click(() => saveRoomPdf(this, TilesList));
          $("#btnDialogSaveScene").click(() => this._save());
          $(".social-share a").click((event) => this._share(event));
          $("#bottomMenuMail").click((event) => this._share(event));
          $(".clear-all").click(() => this._clear());

          $("#shadow-menu").on("change", (event) => {
            this._setShadowIntensity(event.target.value / 100);
          });
        },
      },
      {
        key: "_setShadowIntensity",
        value: async function _setShadowIntensity(intensity) {
          const image = await loadImage(this.image);
          const mask = await loadImage(this.mask);
          const shadowMap = await loadImage(this.sh_map);
          const reflectionMap = await loadImage(this.reflect);
          const wallmask = await loadImage(this.wallmask);
          const processed = processMaps(
            image,
            mask,
            shadowMap,
            reflectionMap,
            intensity,
            wallmask
          );

          const shadow = await loadImage(processed.shadow);

          //this._engine2d._shadowGlossy = shadow;
          this._engine2d._shadowMatt = shadow;

          this._render();
        },
      },
    ]);

    return Room;
  })();

  var Engine2D = (function () {
    function Engine2D(canvas, width, height) {
      _classCallCheck(this, Engine2D);

      this.canvas = canvas;

      this.canvasContext = canvas.getContext("2d");

      this.width = Number(width) || 1600;

      this.height = Number(height) || 900;

      this._surfaceCanvas = document.createElement("canvas");

      this._surfaceCanvasCtx = this._surfaceCanvas.getContext("2d");

      this._foreground = null;

      this._shadowGlossy = null;

      this._shadowMatt = null;

      this._mask = null;

      this._wallmask = null;

      this.offscreenCanvas = document.createElement("canvas");
      this.offscreenCtx = this.offscreenCanvas.getContext("2d");
    }

    _createClass(Engine2D, [
      {
        key: "_drawSurfaceCanvas",

        value: function _drawSurfaceCanvas(surface) {
          // Clear canvas

          this._surfaceCanvas.width = this.width;

          this._surfaceCanvas.height = this.height;

          // this._surfaceCanvasCtx.clearRect(0, 0, this.width, this.height);

          // Draw surface color

          this._surfaceCanvasCtx.fillStyle = surface.color;

          this._surfaceCanvasCtx.fillRect(0, 0, this.width, this.height);

          // Draw surface tiles
          // // console.log(
          //   "==+>Engine2D Before surface.projection.render:",
          //   "iD:",
          //   surface[0],
          //   "      Type:",
          //   surface[176]
          // );
          surface.projection.render(undefined, this._cameraDirection);
          // var link = document.createElement("a");
          // link.download = `${surface[0]}-${surface[176]}.png`;
          // link.href = surface.projection.canvas.toDataURL();
          // link.click();

          this._surfaceCanvasCtx.drawImage(
            surface.projection.canvas,
            0,
            0,
            this.width,
            this.height
          );

          // Draw surface tiles BackLight for hovered surface

          if (
            Array.isArray(this._backLightSurfaces) &&
            this._backLightSurfaces.indexOf(surface) !== -1
          ) {
            this._surfaceCanvasCtx.fillStyle =
              window.JsConstants.config.surfaceBacklightColor;

            this._surfaceCanvasCtx.fillRect(0, 0, this.width, this.height);
          }

          // Draw shadow

          var shadow =
            surface.getFinish() === "matt" || surface.getFinish() === "textured"
              ? this._shadowMatt
              : this._shadowGlossy;

          this._surfaceCanvasCtx.globalCompositeOperation = "multiply";

          this._surfaceCanvasCtx.drawImage(
            shadow,
            0,
            0,
            this.width,
            this.height
          );

          this._surfaceCanvasCtx.globalCompositeOperation = "source-over";
        },
      },
      {
        key: "_drawTiledShape",

        value: function _drawTiledShape(surface) {
          var _this42 = this;
          // // console.log("surface:", surface);
          // // console.log("_this42:", _this42);
          if (surface) {
            surface.projection.setSize(this.width, this.height);
            // Create an offscreen canvas (only once)
            // if (!_this42.offscreenCanvas) {
            //   _this42.offscreenCanvas = document.createElement("canvas");
            //   _this42.offscreenCanvas.width = _this42.width;
            //   _this42.offscreenCanvas.height = _this42.height;
            //   _this42.offscreenCtx = _this42.offscreenCanvas.getContext("2d");
            // }
            this.canvasContext.save();
            const maskImage =
              surface[176] == "floor" ? _this42._mask : _this42._wallmask;
            if (maskImage && surface[176] == "floor") {
              _this42.offscreenCanvas.width = this.width;
              _this42.offscreenCanvas.height = this.height;
              // Clear the offscreen canvas
              // Draw the surface onto the offscreen canvas
              _this42._drawSurfaceCanvas(surface);

              this.offscreenCtx.drawImage(
                maskImage,
                0,
                0,
                _this42.width,
                _this42.height
              );
              // Apply the mask as an alpha filter
              this.offscreenCtx.globalCompositeOperation = "source-in";
              this.offscreenCtx.drawImage(
                _this42._surfaceCanvas,
                0,
                0,
                _this42.width,
                _this42.height
              );

              // Reset blend mode
              // this.offscreenCtx.globalCompositeOperation = "source-over";

              // Draw the masked surface onto the main canvas
              _this42.canvasContext.drawImage(
                this.offscreenCanvas,
                0,
                0,
                _this42.width,
                _this42.height
              );
            } else {
              //===>Clip path method
              this.canvasContext.beginPath();

              surface[11].forEach(function (maskPoint) {
                _this42.canvasContext.lineTo(maskPoint[0], maskPoint[1]);
              });

              this.canvasContext.closePath();

              this.canvasContext.clip();

              this._drawSurfaceCanvas(surface);

              this.canvasContext.drawImage(
                this._surfaceCanvas,
                0,
                0,
                this.width,
                this.height
              );

              this.canvasContext.restore();
            }
          }
        },
      },
      {
        key: "_drawTiledSurfaces",

        value: function _drawTiledSurfaces(surfaces) {
          var _this43 = this;

          if (Array.isArray(surfaces)) {
            surfaces.forEach(function (surface) {
              return _this43._drawTiledShape(surface);
            });
          }
        },
      },
      {
        key: "_render",

        value: function _render(surfaces) {
          if (this._foreground && this._shadowMatt && this._shadowGlossy) {
            this.canvas.width = this.width;

            this.canvas.height = this.height;

            this.canvasContext.clearRect(0, 0, this.width, this.height);

            this.canvasContext.drawImage(
              this._shadowGlossy,
              0,
              0,
              this.width,
              this.height
            ); // Background

            this._drawTiledSurfaces(surfaces);

            this.canvasContext.drawImage(
              this._foreground,
              0,
              0,
              this.width,
              this.height
            );
          }
        },
      },
      {
        key: "_loadImage",

        value: function _loadImage(
          imageUrl,
          onLoad,
          onProgress,
          setSize,
          surfaces
        ) {
          var _this44 = this;

          if (imageUrl) {
            var img = new Image();

            img.onload = function () {
              if (setSize) {
                _this44.width = img.naturalWidth || img.width;

                _this44.height = img.naturalHeight || img.height;
              }

              _this44._imagesLoadedCount += 1;

              if (_this44._imagesLoadedCount >= _this44._imagesTotalCount) {
                _this44._render(surfaces);

                if (onLoad) onLoad();
              }

              if (onProgress)
                onProgress(
                  _this44._imagesLoadedCount,
                  _this44._imagesTotalCount
                );
            };

            img.src = imageUrl;

            return img;
          }
        },
      },
      {
        key: "render",

        value: function render(surfaces, backLightSurfaces, cameraDirection) {
          this._cameraDirection = cameraDirection;

          this._backLightSurfaces = backLightSurfaces;

          this._render(surfaces);
        },
      },
      {
        key: "loadImages",

        value: function loadImages(urls, onLoad, onProgress, surfaces) {
          this._imagesTotalCount = 0;

          this._imagesLoadedCount = 0;
          // console.log("urls", urls);
          if (urls.image) this._imagesTotalCount += 1;

          if (urls.shadow) this._imagesTotalCount += 1;

          if (urls.shadow_matt) this._imagesTotalCount += 1;

          if (urls.mask) this._imagesTotalCount += 1;

          if (urls.wallmask) this._imagesTotalCount += 1;

          this._foreground = this._loadImage(
            urls.image,
            onLoad,
            onProgress,
            true,
            surfaces
          );

          var shadowGlossy = this._loadImage(
            urls.shadow,
            onLoad,
            onProgress,
            false,
            surfaces
          );

          var shadowMatt = this._loadImage(
            urls.shadow_matt,
            onLoad,
            onProgress,
            false,
            surfaces
          );

          if (urls.wallmask) {
            var wallmask = this._loadImage(
              urls.wallmask,
              onLoad,
              onProgress,
              false,
              surfaces
            );
            this._wallmask = wallmask;
          }
          if (urls.mask) {
            var mask = this._loadImage(
              urls.mask,
              onLoad,
              onProgress,
              false,
              surfaces
            );
            this._mask = mask;
          }

          this._shadowGlossy = shadowGlossy || shadowMatt;

          this._shadowMatt = shadowMatt || shadowGlossy;
        },
      },
      {
        key: "setImages",

        value: function setImages(images) {
          this._foreground = images.foreground;

          this._shadowGlossy = images.shadow || images.shadowMatt;

          this._shadowMatt = images.shadowMatt || images.shadow;
        },
      },
      {
        key: "isPointOnShape",

        value: function isPointOnShape(point, shapePoints) {
          var _this45 = this;

          if (Array.isArray(shapePoints) && shapePoints.length > 2) {
            // this.canvasContext.save();

            this.canvasContext.beginPath();

            shapePoints.forEach(function (shapePoint) {
              return _this45.canvasContext.lineTo(shapePoint[0], shapePoint[1]);
            });

            this.canvasContext.closePath();

            if (
              this.canvasContext.isPointInPath(point.x, point.y) ||
              this.canvasContext.isPointInStroke(point.x, point.y)
            ) {
              return true;
            }

            // this.canvasContext.restore();
          }
        },
      },
    ]);

    return Engine2D;
  })();

  /* global THREE */

  var SURFACE_DEFAULTS = {
    color: "#ffffff",

    groutSize: Number(window.JsConstants.config.TiledSurface.groutSize) || 0,

    groutColor: "#ffffff",

    rotation: 0,

    fillTypeIndex:
      Number(window.JsConstants.config.TiledSurface.fillTypeIndex) || 0,

    freeDesign: false,

    // tile: undefined,

    // tileIndex: undefined,

    // tile2: undefined,

    // tile2Index: undefined,

    // texture: undefined,

    textureIndex: 0,

    skewSize: Number(window.JsConstants.config.TiledSurface.skewSize) || 0.5,
  };

  var TiledSurface = (function () {
    function TiledSurface(surfaceData) {
      _classCallCheck(this, TiledSurface);

      Object.assign(this, SURFACE_DEFAULTS);

      this.type = surfaceData.type;

      this.group = Number(surfaceData.group) || 0;

      // this.setGroutColor();
    }

    _createClass(TiledSurface, [
      {
        key: "setColor",

        value: function setColor() {
          var color =
            arguments.length > 0 && arguments[0] !== undefined
              ? arguments[0]
              : 0xffffff;

          this.mesh.material.color.set(color);

          this.color = "#" + this.mesh.material.color.getHexString();
        },
      },
      {
        key: "setGroutColor",

        value: function setGroutColor() {
          var color =
            arguments.length > 0 && arguments[0] !== undefined
              ? arguments[0]
              : 0xffffff;

          if (this.groutMaterial) {
            this.groutMaterial.color.set(color);
          } else {
            this.groutMaterial = new THREE.MeshBasicMaterial({
              color: color,

              // depthWrite: false,

              polygonOffset: true,
              polygonOffsetUnits: 1,
              polygonOffsetFactor: 1,
              // polygonOffsetFactor: -1,
            });
          }

          this.groutColor = "#" + this.groutMaterial.color.getHexString();

          // this._update();
        },
      },
      {
        key: "_useGrout",

        value: function _useGrout(tile) {
          if (tile && tile.grout) {
            if (!this.groutSize && this._reservedGroutSize) {
              this.groutSize = this._reservedGroutSize;
            }
          } else if (this.groutSize) {
            this._reservedGroutSize = this.groutSize;

            this.groutSize = 0;
          }
        },
      },
      {
        key: "setGroutSize",

        value: function setGroutSize(value) {
          var groutSize =
            value === undefined ? SURFACE_DEFAULTS.groutSize : value;

          this.groutSize = Math.max(0, Math.min(24, groutSize)) || 0;

          // this._update();

          // this._updateMask();
        },
      },
      {
        key: "setFillType",

        value: function setFillType(value) {
          // this.clear();

          this.fillTypeIndex = Number(value) || 0;

          // const drawEver = this.fillTypeIndex === 1 ? 0 : undefined; // Chess

          // this._tiles.fill(drawEver);

          // this._updateMask();
        },
      },
      {
        key: "setSkewSize",

        value: function setSkewSize(value) {
          this.skewSize = Math.max(
            0.1,
            Math.min(0.9, Number(value) || SURFACE_DEFAULTS.skewSize)
          );
        },
      },
      {
        key: "rotate",

        value: function rotate(angle) {
          this.rotation = Number(angle) || 0;

          // this.rotationRadians = THREE.Math.degToRad(this.rotation);

          // this._update();

          // this._updateMask();
        },
      },
      {
        key: "getSettings",

        value: function getSettings() {
          return {
            color: this.color,

            groutSize: this.groutSize || undefined,

            groutColor: this.groutColor,

            rotation: this.rotation || undefined,

            fillTypeIndex: this.fillTypeIndex || undefined,

            tileId: this.tile ? this.tile.id : undefined,

            tileCustom: this.tile ? this.tile.custom : undefined,

            tile2Id: this.tile2 ? this.tile2.id : undefined,

            tile2Custom: this.tile2 ? this.tile2.custom : undefined,

            skewSize: this.skewSize,

            freeDesign: this.freeDesign || undefined,

            freeDesignTiles: this.freeDesign
              ? this._getFreeDesignTilesSettings()
              : undefined,
          };
        },
      },
      {
        key: "restoreSettings",

        value: function restoreSettings(sets) {
          // console.log("restoreSettings (on new Rooms/tilesurface): ", sets);
          if (
            (typeof sets === "undefined" ? "undefined" : _typeof(sets)) ===
            "object"
          ) {
            if (sets.color) this.color = sets.color;

            if (sets.groutSize) this.groutSize = sets.groutSize;

            if (sets.groutColor) this.setGroutColor(sets.groutColor);

            if (sets.rotation) this.rotate(sets.rotation);

            if (sets.fillTypeIndex) this.fillTypeIndex = sets.fillTypeIndex;

            if (sets.skewSize) this.skewSize = sets.skewSize;

            if (sets.tileId) {
              var tile = TilesList.getById(sets.tileId, sets.tileCustom);

              this.setTile(tile);
            }

            if (sets.tile2Id) {
              var _tile = TilesList.getById(sets.tile2Id, sets.tile2Custom);

              this.setTile2(_tile);
            }

            if (sets.freeDesign) {
              this.freeDesign = sets.freeDesign;

              this._restoreFreeDesignTiles(sets.freeDesignTiles);
            }

            // this._update();

            // this._updateMask();
          }
        },
      },
      {
        key: "setTile",

        value: function setTile(tile) {
          this._useGrout(tile);

          if (
            (typeof tile === "undefined" ? "undefined" : _typeof(tile)) ===
            "object"
          ) {
            this.tile = tile;

            this.tileIndex = tile.index;
          } else {
            this.tile = undefined;

            this.tileIndex = undefined;
          }
        },

        /**

			 * Set tile for second layer of chess pattern

			 * @param {Object} tile

			 */
      },
      {
        key: "setTile2",

        value: function setTile2(tile) {
          if (
            (typeof tile === "undefined" ? "undefined" : _typeof(tile)) ===
            "object"
          ) {
            this.tile2 = tile;

            this.tile2Index = tile.index;
          } else {
            this.tile2 = undefined;

            this.tile2Index = undefined;
          }
        },
      },
      {
        key: "clearTile2",

        value: function clearTile2() {
          this.tile2 = undefined;

          this.tile2Index = undefined;
        },
      },
      {
        key: "setFreeDesign",

        value: function setFreeDesign(value) {
          this.freeDesign = Boolean(value); // value === true

          // this._freeDesignTiles.clear();

          // this._updateMask();
        },
      },
      {
        key: "_getFreeDesignTilesSettings",

        value: function _getFreeDesignTilesSettings() {
          return this.freeDesignTiles;
        },
      },
      {
        key: "_restoreFreeDesignTiles",

        value: function _restoreFreeDesignTiles(tilesSettings) {
          this.freeDesignTiles = tilesSettings;
        },
      },
      {
        key: "isTiledSurface",

        get: function get() {
          return true;
        },
      },
    ]);

    return TiledSurface;
  })();

  /* global THREE */

  var Tile3d = (function () {
    function Tile3d(anisotropy) {
      _classCallCheck(this, Tile3d);

      this._anisotropy = anisotropy || 1;
    }

    _createClass(Tile3d, [
      {
        key: "_nextPowerOf2",

        value: function _nextPowerOf2(x) {
          return Math.min(
            Math.pow(2, Math.ceil(Math.log(x) / Tile3d.Log2)),
            Tile3d.MaxTextureSize
          );
        },
      },
      {
        key: "_resizeImageToPowerOfTwo",

        value: function _resizeImageToPowerOfTwo(image) {
          var canvas = document.createElement("canvas");

          var ctx = canvas.getContext("2d");

          canvas.width = this._nextPowerOf2(image.width);

          canvas.height = this._nextPowerOf2(image.height);

          ctx.drawImage(image, 0, 0, canvas.width, canvas.height);

          return canvas;
        },
      },
      {
        key: "_rotateImage",

        value: function _rotateImage(image) {
          if (!image) return;

          var canvas = document.createElement("canvas");

          canvas.width = image.height;

          canvas.height = image.width;

          var ctx = canvas.getContext("2d");

          ctx.rotate(1.5707963267948966); // 90 * Math.PI / 180

          ctx.drawImage(image, 0, -image.height, image.width, image.height);

          ctx.setTransform(1, 0, 0, 1, 0, 0);

          return canvas;
        },
      },
      {
        key: "_getGeometry",

        value: function _getGeometry(shape) {
          if (!Tile3d.Shapes[shape].geometry) {
            var loader = new THREE.LegacyJSONLoader();

            var newTile = loader.parse(Tile3d.Shapes[shape].meshData);

            Tile3d.Shapes[shape].geometry = newTile.geometry;
          }

          return Tile3d.Shapes[shape].geometry;
        },

        // _htmlHexToColor(htmlHex) {

        //     const hex = htmlHex.replace('#', '0x');

        //     return new THREE.Color(0xffffff).setHex(hex);

        // }
      },
      {
        key: "_getGroutMesh",

        value: function _getGroutMesh(geometry, size, material) {
          // const material = new THREE.MeshBasicMaterial({

          //     color: this._htmlHexToColor(color),

          //     polygonOffset: true,

          //     // polygonOffsetFactor: 2

          // });

          var mesh = new THREE.Mesh(geometry, material);

          mesh.position.y = -0.02;

          mesh.scale.x = this._tileMesh.scale.x + size * 2;

          mesh.scale.z = this._tileMesh.scale.z + size * 2;

          return mesh;
        },
      },
      {
        key: "_getTexture",

        value: function _getTexture(image) {
          var canvas = this._resizeImageToPowerOfTwo(image);

          this.texture = new THREE.Texture(canvas);

          this.texture.premultiplyAlpha = false;

          this.texture.needsUpdate = true;

          this.texture.anisotropy = this._anisotropy;

          return this.texture;
        },
      },
      {
        key: "updateGrout",

        value: function updateGrout(size) {
          // , color

          if (this._groutMesh) {
            // this._groutMesh.material.color.set(this._htmlHexToColor(color));

            this._groutMesh.scale.x = this._tileMesh.scale.x + size * 2;

            this._groutMesh.scale.z = this._tileMesh.scale.z + size * 2;
          }
        },
      },
      {
        key: "make",

        value: function make(tileImage, tile, groutSize, groutColor) {
          if (this.mesh) return this.mesh;

          var image = tile.needsRotate
            ? this._rotateImage(tileImage)
            : tileImage;

          var geometry = this._getGeometry(tile.shape);

          this.mesh = new THREE.Group();

          this.mesh.rotation.x = Tile3d.HalfPI;

          this.material = new THREE.MeshBasicMaterial({
            map: this._getTexture(image),
          });

          if (tile.shapePreparedSet) {
            this.material.transparent = true;

            this.material.depthWrite = false;
          }

          this._tileMesh = new THREE.Mesh(geometry, this.material);

          this._tileMesh.scale.x = tile.width;

          this._tileMesh.scale.z = tile.height;

          this.mesh.add(this._tileMesh);

          if (!tile.shapePreparedSet) {
            this._groutMesh = this._getGroutMesh(
              geometry,
              groutSize,
              groutColor
            );

            this.mesh.add(this._groutMesh);
          }

          return this.mesh;
        },
      },
      {
        key: "makePlane",

        value: function makePlane(plane) {
          if (this.mesh) {
            return this.mesh;
          }
          // console.log("INSIDE :Make Plane:");
          var geometry = this._getGeometry(plane.shape);

          var material = new THREE.MeshBasicMaterial();

          this.mesh = new THREE.Mesh(geometry, material);

          this.mesh.rotation.x = Tile3d.HalfPI;

          this.mesh.scale.x = plane.width;

          this.mesh.scale.z = plane.height;

          return this.mesh;
        },
      },
    ]);

    return Tile3d;
  })();

  var SQUARE_PLANE_CORNERS_POINTS = [
    [0, 0],
    [1, 0],
    [1, 1],
    [0, 1],
  ];

  var SQUARE_PLANE_MESH_DATA = {
    metadata: {
      type: "Geometry",

      normals: 1,

      version: 3,

      faces: 1,

      vertices: 4,

      uvs: 1,

      generator: "io_three",
    },

    faces: [41, 0, 1, 3, 2, 0, 1, 2, 3, 0, 0, 0, 0],

    vertices: [-0.5, 0, 0.5, 0.5, 0, 0.5, -0.5, 0, -0.5, 0.5, 0, -0.5],

    uvs: [[0, 0, 1, 0, 1, 1, 0, 1]],

    normals: [0, 1, 0],
  };

  Tile3d.Log2 = Math.log(2);

  Tile3d.HalfPI = Math.PI / 2;

  Tile3d.MaxTextureSize = 1024;

  Tile3d.Shapes = {
    square: {
      name: "square",

      cornersPoints: SQUARE_PLANE_CORNERS_POINTS,

      meshData: SQUARE_PLANE_MESH_DATA,

      rotationStep: Math.PI / 2,
    },

    rectangle: {
      name: "rectangle",

      cornersPoints: SQUARE_PLANE_CORNERS_POINTS,

      meshData: SQUARE_PLANE_MESH_DATA,

      rotationStep: Math.PI,
    },

    hexagon: {
      name: "hexagon",

      cornersPoints: [
        [0.25, 0],
        [0.75, 0],
        [1, 0.5],
        [0.75, 1],
        [0.25, 1],
        [0, 0.5],
      ],

      meshData: {
        metadata: {
          type: "Geometry",

          normals: 4,

          version: 3,

          faces: 4,

          vertices: 6,

          uvs: 1,

          generator: "io_three",
        },

        faces: [
          40, 0, 1, 2, 5, 0, 1, 0, 0, 0, 40, 2, 3, 4, 1, 2, 3, 1, 1, 1, 40, 4,
          5, 0, 3, 4, 5, 2, 2, 2, 40, 2, 4, 0, 1, 3, 5, 3, 3, 3,
        ],

        vertices: [
          0.5, 0, 0, 0.25, 0, -0.5, -0.25, 0, -0.5, -0.5, 0, 0, -0.25, 0, 0.5,
          0.25, 0, 0.5,
        ],

        uvs: [[0.75, 1, 0.25, 1, 0, 0.5, 0.25, 0, 0.75, 0, 1, 0.5]],

        normals: [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0],
      },

      rotationStep: Math.PI / 3,
    },

    diamond: {
      name: "diamond",

      cornersPoints: [
        [0.5, 0],
        [1, 0.5],
        [0.5, 1],
        [0, 0.5],
      ],

      meshData: {
        metadata: {
          type: "Geometry",

          normals: 1,

          version: 3,

          faces: 1,

          vertices: 4,

          uvs: 1,

          generator: "io_three",
        },

        faces: [41, 0, 1, 3, 2, 0, 1, 2, 3, 0, 0, 0, 0],

        vertices: [-0.5, 0, 0, 0, 0, 0.5, 0, -0, -0.5, 0.5, 0, 0],

        uvs: [[0, 0.5, 0.5, 0, 1, 0.5, 0.5, 1]],

        normals: [0, 1, 0],
      },

      rotationStep: Math.PI,
    },

    quadSet: {
      name: "quadSet",

      cornersPoints: SQUARE_PLANE_CORNERS_POINTS,

      meshData: SQUARE_PLANE_MESH_DATA,

      rotationStep: Math.PI / 2,
    },

    preparedSet: {
      name: "preparedSet",

      cornersPoints: SQUARE_PLANE_CORNERS_POINTS,

      meshData: SQUARE_PLANE_MESH_DATA,
    },

    notionHerringbon: {
      name: "notionHerringbon",

      title: "Notion Herringbon",

      cornersPoints: SQUARE_PLANE_CORNERS_POINTS,

      meshData: SQUARE_PLANE_MESH_DATA,

      // width: 302,

      // height: 294,

      // offsetX: 20,

      // offsetY: 68,
    },

    riverstoneRohmboid: {
      name: "riverstoneRohmboid",

      title: "Riverstone Rohmboid",

      cornersPoints: SQUARE_PLANE_CORNERS_POINTS,

      meshData: SQUARE_PLANE_MESH_DATA,

      // width: 328,

      // height: 264,

      // offsetX: 65,

      // offsetY: 37,
    },

    rivertsoneChevron: {
      name: "rivertsoneChevron",

      title: "Rivertsone Chevron",

      cornersPoints: SQUARE_PLANE_CORNERS_POINTS,

      meshData: SQUARE_PLANE_MESH_DATA,

      // width: 238,

      // height: 298,

      // offsetX: 0,

      // offsetY: 55,
    },

    stoneSystemCombo: {
      name: "stoneSystemCombo",

      title: "Stone System Combo",

      cornersPoints: SQUARE_PLANE_CORNERS_POINTS,

      meshData: SQUARE_PLANE_MESH_DATA,

      // width: 711,

      // height: 416, // 306

      // offsetX: 60,

      // offsetY: 0,
    },
  };

  // @ts-check

  var NEAR = 0.1;

  var FAR = 20000;

  var FOV = 30;

  var MAX_FOV = 170;

  var WIDTH = 1600;

  var HEIGHT = 900;

  var CAMERA_POSITION = 100;

  var MAX_CAMERA_LAYERS = 32;

  var SurfaceProjection = (function () {
    function SurfaceProjection(fov, horizontalOffset, verticalOffset) {
      _classCallCheck(this, SurfaceProjection);

      var viewAngle = Number(fov) || FOV;

      this.width = WIDTH;

      this.height = HEIGHT;

      this._renderer = new THREE.WebGLRenderer({
        alpha: true,

        antialias: true,

        preserveDrawingBuffer: true,
      });

      this._renderer.setSize(this.width, this.height);

      var aspectRatio = this.width / this.height;

      this.maxAnisotropy = this._renderer.capabilities.getMaxAnisotropy();

      this._camera = new THREE.PerspectiveCamera(
        viewAngle,
        aspectRatio,
        NEAR,
        FAR
      );

      this._camera.position.set(0, 0, CAMERA_POSITION);

      this.setViewOffset(horizontalOffset, verticalOffset);

      this._scene = new THREE.Scene();

      this.canvas = this._renderer.domElement;
    }

    _createClass(SurfaceProjection, [
      {
        key: "addObject",

        value: function addObject(object) {
          this._scene.add(object);
        },
      },
      {
        key: "getIntersect",

        value: function getIntersect(point, object, direction) {
          this._changeCameraDirection(direction);

          return this._getRaycaster(point).intersectObject(object);
        },
      },
      {
        key: "getIntersects",

        value: function getIntersects(point, objects, direction) {
          this._changeCameraDirection(direction);

          return this._getRaycaster(point).intersectObjects(objects, true);
        },
      },
      {
        key: "render",

        value: function render(layers, direction) {
          this._setCameraLayers(layers);

          this._changeCameraDirection(direction);

          this._render();
        },
      },
      {
        key: "setCameraFov",

        value: function setCameraFov(value) {
          var fov = Number(value) || FOV;

          if (fov > 0) {
            this._camera.fov = Math.max(1, Math.min(MAX_FOV, fov));

            this._camera.updateProjectionMatrix();
          }
        },
      },
      {
        key: "setSize",

        value: function setSize(width, height) {
          if (this.width === width && this.height === height) {
            return;
          }

          this.width = width;

          this.height = height;

          this._renderer.setSize(width, height);

          this._camera.aspect = width / height;

          this._camera.updateProjectionMatrix();
        },
      },
      {
        key: "setViewOffset",

        value: function setViewOffset(horizontalOffset, verticalOffset) {
          var hOffset = Number(horizontalOffset) || 0;

          var fullWidth = this.width + Math.abs(hOffset) * 2;

          var left = hOffset >= 0 ? 0 : fullWidth - this.width;

          var vOffset = Number(verticalOffset) || 0;

          var fullHeight = this.height + Math.abs(vOffset) * 2;

          var top = vOffset >= 0 ? 0 : fullHeight - this.height;

          this._camera.setViewOffset(
            fullWidth,
            fullHeight,
            left,
            top,
            this.width,
            this.height
          );
        },
      },
      {
        key: "_changeCameraDirection",

        value: function _changeCameraDirection(direction) {
          if (direction && this._sideDirection !== direction) {
            this._sideDirection = direction;

            this._camera.position.set(0, 0, 0);

            this._camera.lookAt(direction.position);
          }
        },
      },
      {
        key: "_getRaycaster",

        value: function _getRaycaster(point) {
          if (!this._raycaster) {
            this._raycaster = new THREE.Raycaster();
          }

          this._render();

          this._raycaster.setFromCamera(point, this._camera);

          return this._raycaster;
        },
      },
      {
        key: "_render",

        value: function _render() {
          this._renderer.render(this._scene, this._camera);
        },
      },
      {
        key: "_setCameraLayers",

        value: function _setCameraLayers(value) {
          if (value !== undefined) {
            var layers = Math.floor(Number(value) || 0);

            this._camera.layers.set(
              Math.max(0, Math.min(MAX_CAMERA_LAYERS, layers))
            );
          }
        },
      },
    ]);

    return SurfaceProjection;
  })();

  var DEG = Math.PI / 180;

  var ROTATION_90_DEG = Math.PI / 2;

  var ROTATION_180_DEG = Math.PI;

  var ROTATION_270_DEG = (Math.PI * 3) / 2;

  var MAX_TILED_PLANE_SIZE = 10000; // mm

  var PLANE_SIZE = 200000;

  var HEXAGON_ASPECT_RATIO$1 = 0.866;

  var DIAMOND_ASPECT_RATIO = 0.707;

  var fillTypes = [
    { name: "Standard" },
    { name: "Chess", drawEver: 0 }, // 0 or 1 for even or odd

    { name: "Horizontal Skew" },
    { name: "Vertical Skew" },
  ];

  var TiledSurface2d = (function (_TiledSurface) {
    _inherits(TiledSurface2d, _TiledSurface);

    function TiledSurface2d(surfaceData, roomData, render) {
      _classCallCheck(this, TiledSurface2d);

      var _this46 = _possibleConstructorReturn(
        this,
        (
          TiledSurface2d.__proto__ || Object.getPrototypeOf(TiledSurface2d)
        ).call(this, surfaceData)
      );

      _this46._surfaceData = surfaceData;

      _this46._render = render;

      _this46._gridHelper = false;

      _this46.layers = undefined;

      _this46._tilePositions();

      _this46._freeDesignTileApproxPositions();

      _this46.setGroutColor();

      _this46.clear(surfaceData);
      _this46._init(roomData);

      return _this46;
    }

    _createClass(TiledSurface2d, [
      {
        key: "clear",

        value: function clear(surfaceData) {
          // Object.assign(this, SURFACE_DEFAULTS);
          this._surfaceData = null;
          this._surfaceData = surfaceData;
          this.freeDesignTiles = [];
        },
      },
      {
        key: "_createIntersectsPlane",

        value: function _createIntersectsPlane() {
          var geometry = new window.THREE.PlaneGeometry(PLANE_SIZE, PLANE_SIZE); // plane size 200x200 meters actual size 100x100 meters

          var material = new window.THREE.MeshBasicMaterial({
            color: 0xff0000,

            transparent: true,

            opacity: 0,
          });

          var mesh = new window.THREE.Mesh(geometry, material);

          // mesh.position.z = -0.02;

          return mesh;
        },
      },
      {
        key: "_setData",

        value: function _setData(data) {
          this[0] = data[0]; //  : 1, // tile_type

          this[1] = data[1]; //  : -64,   // Position(xyz)

          this[2] = data[2]; //  : -17.4, // Position(xyz)

          this[3] = data[3]; //  : 22,    // Position(xyz)

          this[4] = data[4]; //  : 0, // Rotation(xyz axises)

          this[5] = data[5]; //  : 0, // Rotation(xyz axises)

          this[6] = data[6]; //  : 0, // Rotation(xyz axises)

          this[7] = data[7]; //  : 70,    // Plane Size(height-width)

          this[8] = data[8]; //  : 150,   // Plane Size(height-width)

          this[9] = data[9]; //  : 12,    // Scaling(height-width)

          this[10] = data[10]; //  : 12,   // Scaling(height-width)

          this[11] = data[11]; //  : [] =  // Mask Path Points

          this[12] = data[12]; //  : 2,    // Grout v-Width !!! Unused !!!

          this[13] = data[13]; //  : 2,    // Grout h-Width !!! Unused !!!

          this[14] = data[14]; //  : 0,    // Skew(vertical-horizontal) !!! Unused !!!

          this[15] = data[15]; //  : 0,    // Skew(vertical-horizontal) !!! Unused !!!

          this[177] = data[177]; //  : 0,   // !!! Unused !!!

          this[176] = data[176]; //  : 'Wall'  // type

          this.cameraFov = data.cameraFov;

          this.viewVerticalOffset = data.viewVerticalOffset;

          this.viewHorizontalOffset = data.viewHorizontalOffset;

          this.sidesMaskPathPoints = data.sidesMaskPathPoints;
          // console.log("this._surfaceData", this._surfaceData);
          this.type = this._surfaceData["176"].trim().toLowerCase();

          this.width = this[8];

          this.height = this[7];

          this.maxScale = Math.max(this[9], this[10]) / 1000;

          this.maxSize = Math.min(
            Math.max(this.width, this.height),
            MAX_TILED_PLANE_SIZE
          );

          this.container.position.x = this[1];

          this.container.position.y = this[2];

          this.container.position.z = this[3];

          this.container.rotation.x = this[4] * DEG;

          this.container.rotation.y = this[5] * DEG;

          this.container.rotation.z = this[6] * DEG;

          this.container.scale.set(this.maxScale, this.maxScale, 1);
        },

        // @jscrambler define domainLock {domains:[app001.3droomvisualizer.com, sean.3dtilevisualizer.com, tilevisualizer.pavits.com, vis.florexceramic.in, visualizer.restile.com, visualizer.mahalaxmitiles.com, visualiser.sandstoneworks.com.au, visualiser.tiledepot.co.nz, simulator.stoneline.com.tr, visualizer2d.globalquartz.in, diy.saifurnitureindia.co.in, tilevisualizer.designtiles.com.au, tiledesigner.stile.com.pk, showroom.gulveogfliser.dk, tiledepot.3droomvisualizer.com, visualizer.metztiles.com.au, visualizer.metztiles.com.au, visualizer.alkhaleejceramics.com, floorsdirect.3droomvisualizer.com, tdcc2.3dtilevisualizer.com, simuladorfv.westus.cloudapp.azure.com, tilevisualiser.colortile.com.au, visualizer.cletile.com, floorvisualizer.welspunflooring.com, poplar.3dtilevisualizer.com, visualizer.topcarpetsandfloors.co.za, colorizer.prattandlarson.com]} as dL

        // @jscrambler enable dL
      },
      {
        key: "_init",

        value: function _init(roomData) {
          // this.clear();
          //set TileList here
          this.container = new window.THREE.Group();

          this._setData(this._surfaceData);

          this.tilesContainer = new window.THREE.Group();

          this.container.add(this.tilesContainer);

          this.freeDesignTilesContainer = new window.THREE.Group();

          this.container.add(this.freeDesignTilesContainer);

          this.freeDesignTilesContainer.position.z = 0.04;

          this.intersectsPlane = this._createIntersectsPlane();

          this.container.add(this.intersectsPlane);

          this.projection = new SurfaceProjection(
            this.cameraFov,
            this.viewHorizontalOffset,
            this.viewVerticalOffset
          );

          this.projection.addObject(this.container);

          if (true && localStorage.getItem("shouldInit") === "1") {
            // console.log("TiledSurface2d => INIT: ", this[11], roomData);
            /// override the transform by 4 points (https://jsfiddle.net/512rL8sb/1/)
            const W = roomData.width;
            const H = roomData.height;

            // Determine the points array based on the type
            let points = this[11].map((p) => ({ x: p[0], y: p[1] }));
            // if (
            //   false &&
            //   this.type === "floor" &&
            //   roomData.floors &&
            //   roomData.floors[0].length > 3
            // ) {
            //   points = roomData.floors[0]; // Use the first array of floor points
            // } else if (
            //   this.type === "floor" &&
            //   roomData.wallsPts &&
            //   roomData.wallsPts[0].length > 3
            // ) {
            //   points = roomData.wallsPts[1]; // Use the first array of wall points
            // } else {
            //   throw new Error(
            //     "No valid points array found for the given type."
            //   );
            // }

            // console.log("points", points);
            // FIXME: _drawTiledShape will reset WxH...
            this.projection.setSize(W, H);

            // Translate the corner points so that the center of the view plane is at the origin (0, 0)
            // and the positive y-axis is pointing up.
            const translatedPoints = points.map((point) => ({
              x: point.x - W / 2,
              y: H / 2 - point.y,
            }));

            // console.log("Before points::", points);
            // console.log("translatedPoints::", translatedPoints);

            // Focal length (= distance at which xy = screen xy)
            const f =
              (0.5 * H) /
              Math.tan((0.5 * this.projection._camera.fov * Math.PI) / 180);

            this.projection._camera.near = f / 10;
            this.projection._camera.far = f * 100;
            this.projection._camera.aspect = W / H;
            this.projection._camera.clearViewOffset();
            this.projection._camera.updateProjectionMatrix();

            const m = new window.THREE.Matrix4();

            // Use the first three points to create a basis matrix
            m.makeBasis(
              new window.THREE.Vector3(
                -translatedPoints[1].x,
                -translatedPoints[1].y,
                f
              ),
              new window.THREE.Vector3(
                translatedPoints[2].x,
                translatedPoints[2].y,
                -f
              ),
              new window.THREE.Vector3(
                -translatedPoints[3].x,
                -translatedPoints[3].y,
                f
              )
            );

            m.setPosition(
              new window.THREE.Vector3(
                translatedPoints[0].x,
                translatedPoints[0].y,
                -f
              )
            );

            m.getInverse(m);

            const s =
              1 / Math.min(m.elements[12], m.elements[13], m.elements[14]);

            // Scale the points
            const scaledPoints = translatedPoints.map((point, index) =>
              new window.THREE.Vector3(point.x, point.y, -f).multiplyScalar(
                s * (index > 0 ? m.elements[11 + index] : 1)
              )
            );
            // console.log("translatedPoints:", translatedPoints);
            // console.log("scaledPoints:", scaledPoints);
            // Debug
            // const S = 0.0005;
            const S = 0.0005; //custom aligned values

            const T = scaledPoints[0]
              .clone()
              .add(scaledPoints[2])
              .multiplyScalar(0.5);

            const X = scaledPoints[1]
              .clone()
              .add(scaledPoints[2])
              .multiplyScalar(0.5)
              .sub(T)
              .multiplyScalar(S);

            const Y = scaledPoints[0]
              .clone()
              .add(scaledPoints[1])
              .multiplyScalar(0.5)
              .sub(T)
              .multiplyScalar(S);
            // console.log("T,X,Y =>", T, X, Y);
            // Heuristics, need to understand this better
            const X1 = X.clone().normalize();
            const Y1 = Y.clone().normalize();

            const diagonality = Math.min(
              Math.abs(X1.x * X1.z),
              Math.abs(Y1.x * Y1.z)
            );

            let fixStrength = Math.min(1, diagonality / 0.5);

            fixStrength =
              fixStrength +
              (1 - fixStrength) *
                Math.min(
                  1,
                  // > 0 if aspect ratio is not 1 (e.g., 4 / 3 - 1 = 0.33)
                  (Math.max(W / H, H / W) - 1) / 0.33
                );

            let xL = X.length(),
              yL = Y.length(),
              aL = 0.5 * (xL + yL);

            X.normalize().multiplyScalar(
              aL * fixStrength + xL * (1 - fixStrength)
            );

            Y.normalize().multiplyScalar(
              aL * fixStrength + yL * (1 - fixStrength)
            );

            const Z = X.clone().cross(Y).normalize().multiplyScalar(aL);

            this.container.matrixAutoUpdate = false;

            this.container.matrix.makeBasis(X, Y, Z);

            this.container.matrix.setPosition(T);

            this.projection._camera.updateMatrixWorld();

            this.container.matrix.premultiply(this.projection._camera.matrix);

            // console.log("peez", scaledPoints, ...scaledPoints.map((p) => p.z));
            // Why tf does this need extra scaling now?
            this.projection._camera.far = Math.max(
              this.projection._camera.far,
              -3 * Math.min(...scaledPoints.map((p) => p.z))
            );

            this.projection._camera.updateProjectionMatrix();

            const position = new THREE.Vector3();
            const quaternion = new THREE.Quaternion();
            const scale = new THREE.Vector3();

            const euler = new THREE.Euler();

            this.container.matrix.decompose(position, quaternion, scale);
            euler.setFromQuaternion(quaternion);
          }
          // localStorage.removeItem("shouldInit");

          // this._render();
        },
      },
      {
        key: "update",

        value: function update(data) {
          this._setData(data);

          this.projection.setCameraFov(data.cameraFov);

          this.projection.setViewOffset(
            data.viewHorizontalOffset,
            data.viewVerticalOffset
          );
        },
      },
      {
        key: "_isEven",

        value: function _isEven(number) {
          if (Math.round(number % 2) === 0) {
            return true;
          }

          return false;
        },
      },
      {
        key: "_isOdd",

        value: function _isOdd(number) {
          if (Math.round(Math.abs(number % 2)) === 1) {
            return true;
          }

          return false;
        },
      },
      {
        key: "_getRandomTile",

        value: function _getRandomTile(tilesArray, tiles$$1, i, j) {
          if (Array.isArray(tiles$$1) && tiles$$1.length > 1) {
            var tile = tiles$$1[Math.floor(Math.random() * tiles$$1.length)];

            if (tile.shape === "square" || tile.shape === "rectangle") {
              if (
                tiles$$1.length > 2 &&
                (tile === tilesArray[j][i - 1] ||
                  (j > 0 && tile === tilesArray[j - 1][i]))
              ) {
                return this._getRandomTile(tilesArray, tiles$$1, i, j);
              }
            } else if (tile.shape === "hexagon") {
              if (tiles$$1.length > 3) {
                if (this._isEven(j)) {
                  if (
                    (j > 0 && tile === tilesArray[j - 1][i - 1]) ||
                    (j > 1 && tile === tilesArray[j - 2][i]) ||
                    (j > 0 && tile === tilesArray[j - 1][i])
                  ) {
                    return this._getRandomTile(tilesArray, tiles$$1, i, j);
                  }
                } else if (
                  (j > 0 && tile === tilesArray[j - 1][i + 1]) ||
                  (j > 0 && tile === tilesArray[j - 1][i]) ||
                  (j > 1 && tile === tilesArray[j - 2][i])
                ) {
                  return this._getRandomTile(tilesArray, tiles$$1, i, j);
                }
              }
            } else if (tile.shape === "diamond") {
              if (tiles$$1.length > 2) {
                if (this._isEven(j)) {
                  if (
                    (j > 0 && tile === tilesArray[j - 1][i - 1]) ||
                    (j > 0 && tile === tilesArray[j - 1][i])
                  ) {
                    return this._getRandomTile(tilesArray, tiles$$1, i, j);
                  }
                } else if (
                  (j > 0 && tile === tilesArray[j - 1][i + 1]) ||
                  (j > 0 && tile === tilesArray[j - 1][i])
                ) {
                  return this._getRandomTile(tilesArray, tiles$$1, i, j);
                }
              }
            }

            return tile;
          }

          return tiles$$1[0];
        },

        // getTilesSet(currentTile) {

        //     if (currentTile && currentTile.rotoPrintSetName) {

        //         var rotoPrintTiles = [];

        //         TilesList.forEach(tile => {

        //             if (tile.rotoPrintSetName === currentTile.rotoPrintSetName) {

        //                 rotoPrintTiles.push(tile);

        //             }

        //         });

        //         return rotoPrintTiles;

        //     }

        //     return [currentTile];

        // }
      },
      {
        key: "removeAllTiles",

        value: function removeAllTiles() {
          this._gridHelper = false;

          while (this.tilesContainer.children.length > 0) {
            this.tilesContainer.remove(this.tilesContainer.children[0]);
          }

          while (this.freeDesignTilesContainer.children.length > 0) {
            this.freeDesignTilesContainer.remove(
              this.freeDesignTilesContainer.children[0]
            );
          }
        },
      },
      {
        key: "_setLayers",

        value: function _setLayers(object) {
          var _this47 = this;

          if (this.layers !== undefined && object) {
            object.layers.set(this.layers);

            if (Array.isArray(object.children)) {
              object.children.forEach(function (child) {
                child.layers.set(_this47.layers);

                _this47._setLayers(child);
              });
            }
          }
        },
      },
      {
        key: "_addTileToContainer",

        value: function _addTileToContainer(tile, container, position) {
          var mesh = tile.tile3d.mesh.clone();

          mesh.tile = tile;

          mesh.position.x = position.x + tile.width / 2;

          mesh.position.y = -(position.y + tile.height / 2);

          if (position.rotation) mesh.rotation.y = position.rotation;

          container.add(mesh);

          this._setLayers(mesh);

          return mesh;
        },
      },
      {
        key: "_tilePositions",

        value: function _tilePositions() {
          var _this48 = this;

          this._getTilePosition = {
            square: function square(options, tile) {
              var x = options.xIndex * (tile.width + _this48.groutSize);

              var y = options.yIndex * (tile.height + _this48.groutSize);

              if (
                fillTypes[_this48.fillTypeIndex].name === "Horizontal Skew" &&
                _this48._isOdd(options.yIndex)
              ) {
                x += (tile.width + _this48.groutSize) * _this48.skewSize;
              }

              if (
                fillTypes[_this48.fillTypeIndex].name === "Vertical Skew" &&
                _this48._isOdd(options.xIndex)
              ) {
                y += (tile.height + _this48.groutSize) * _this48.skewSize;
              }

              return { x: x, y: y };
            },

            hexagon: function hexagon(options, tile) {
              var x = void 0;

              var groutSizeX = _this48.groutSize * HEXAGON_ASPECT_RATIO$1;

              if (_this48._isEven(options.yIndex)) {
                x = options.xIndex * (tile.width * 1.5 + groutSizeX * 2);
              } else {
                x =
                  options.xIndex * (tile.width * 1.5 + groutSizeX * 2) +
                  tile.width * 0.75 +
                  groutSizeX;
              }

              var y = (options.yIndex * (tile.height + _this48.groutSize)) / 2;

              return { x: x, y: y };
            },

            diamond: function diamond(options, tile) {
              var x = void 0;

              var groutSizeX = _this48.groutSize * DIAMOND_ASPECT_RATIO;

              if (_this48._isEven(options.yIndex)) {
                x = options.xIndex * (tile.width + groutSizeX * 2);
              } else {
                x =
                  options.xIndex * (tile.width + groutSizeX * 2) +
                  (tile.width / 2 + groutSizeX);
              }

              var y =
                options.yIndex *
                (tile.height + _this48.groutSize - tile.height / 2);

              return { x: x, y: y };
            },

            preparedSet: function preparedSet(options, tile) {
              var x =
                options.xIndex *
                (tile.width + _this48.groutSize - tile.preparedSetOffset.x);

              var y =
                options.yIndex *
                (tile.height + _this48.groutSize - tile.preparedSetOffset.y);

              return { x: x, y: y };
            },

            quadSet: function quadSet(options, tile) {
              var x = options.xIndex * (tile.width + _this48.groutSize);

              var y = options.yIndex * (tile.height + _this48.groutSize);

              var rotation = 0;

              if (
                _this48._isOdd(options.xIndex) &&
                _this48._isEven(options.yIndex)
              ) {
                rotation = ROTATION_270_DEG;
              } else if (
                _this48._isEven(options.xIndex) &&
                _this48._isOdd(options.yIndex)
              ) {
                rotation = ROTATION_90_DEG;
              } else if (
                _this48._isOdd(options.xIndex) &&
                _this48._isOdd(options.yIndex)
              ) {
                rotation = ROTATION_180_DEG;
              }

              return { x: x, y: y, rotation: rotation };
            },
          };

          this._getTilePosition.rectangle = this._getTilePosition.square;

          this._getTilePosition.notionHerringbon =
            this._getTilePosition.preparedSet;

          this._getTilePosition.riverstoneRohmboid =
            this._getTilePosition.preparedSet;

          this._getTilePosition.rivertsoneChevron =
            this._getTilePosition.preparedSet;

          this._getTilePosition.stoneSystemCombo =
            this._getTilePosition.preparedSet;
        },
      },
      {
        key: "_addTile",

        value: function _addTile(options) {
          var position = this._getTilePosition[options.tile.shape](
            options,
            options.tile
          );

          this._addTileToContainer(options.tile, options.container, position);
        },
      },
      {
        key: "_getTilesCount",

        value: function _getTilesCount(tile) {
          var count = {
            width: this.maxSize / tile.width,

            height: this.maxSize / tile.height,
          };

          if (tile.shape === "diamond") {
            count.height *= 2;
          } else if (tile.shape === "hexagon") {
            count.width *= 0.66; // 1.75 / 0.75 * count.width;

            count.height *= 2;
          } else if (tile.shapePreparedSet) {
            count.width *= 1 / (1 - tile.preparedSetOffset.x / tile.width);

            count.height *= 1 / (1 - tile.preparedSetOffset.y / tile.height);
          }

          count.width = Math.ceil(count.width + 4 - (count.width % 4));

          count.height = Math.ceil(count.height + 4 - (count.height % 4));

          return count;
        },
      },
      {
        key: "_fillSurface",

        value: function _fillSurface(tiles$$1, drawEver) {
          // let tile = tiles[0];

          var tilesCount = this._getTilesCount(tiles$$1[0]);

          var tilesArray = [];

          for (var j = -tilesCount.height; j < tilesCount.height; j += 1) {
            tilesArray[j + tilesCount.height] = [];

            for (var i = -tilesCount.width; i < tilesCount.width; i += 1) {
              var tile = this._getRandomTile(
                tilesArray,
                tiles$$1,
                i + tilesCount.width,
                j + tilesCount.height
              );

              tilesArray[j + tilesCount.height][i + tilesCount.width] = tile;

              var tileOptions = {
                container: this.tilesContainer,

                tile: tile,

                xIndex: i,

                yIndex: j,
              };

              if (fillTypes[this.fillTypeIndex].name === "Chess") {
                if (tile.shape === "square" || tile.shape === "rectangle") {
                  if (Math.round((i + j) % 2) === drawEver) {
                    this._addTile(tileOptions);
                  } else if (Math.round(Math.abs((i + j) % 2)) === drawEver) {
                    this._addTile(tileOptions);
                  }
                } else if (tile.shape === "diamond") {
                  if (this._isEven(j) && drawEver === 0) {
                    this._addTile(tileOptions);
                  } else if (this._isOdd(j) && drawEver === 1) {
                    this._addTile(tileOptions);
                  }
                } else {
                  this._addTile(tileOptions);
                }
              } else {
                this._addTile(tileOptions);
              }
            }
          }
        },
      },
      {
        key: "_prepareTile",

        value: function _prepareTile(tile, image) {
          if (tile.tile3d) {
            tile.tile3d.updateGrout(this.groutSize); // , this.groutColor
          } else {
            tile.tile3d = new Tile3d(this.projection.maxAnisotropy);
            tile.tile3d.make(image, tile, this.groutSize, this.groutMaterial);
          }
        },
      },
      {
        key: "_drawTiles",

        value: function _drawTiles(tile, drawEver) {
          var _this49 = this;
          var tilesSet = TilesList.getRotoPrintSet(tile);
          // console.log("tilesSet:", tilesSet);
          // const images = [];

          var loadedImages = 0;

          tilesSet.forEach(function (tile) {
            loadingAnimation.show();

            var image = new Image();
            // console.log("_drawTiles loop", tile);
            image.onload = function () {
              _this49._prepareTile(tile, image);

              loadedImages += 1;

              if (loadedImages >= tilesSet.length) {
                _this49._fillSurface(tilesSet, drawEver);

                _this49._render();
              }

              loadingAnimation.hide();
            };

            image.onerror = loadingAnimation.hide;

            image.src = tile.file;

            // images.push(image);
          });
        },

        /** @override */
      },
      {
        key: "setColor",

        value: function setColor() {
          var color =
            arguments.length > 0 && arguments[0] !== undefined
              ? arguments[0]
              : "#ffffff";

          this.color = color;

          this._render();
        },

        /** @override */
      },
      {
        key: "setFillType",

        value: function setFillType(value) {
          this.fillTypeIndex = Number(value) || 0;

          this.draw(); // todo check
        },

        /** @override */
      },
      {
        key: "setSkewSize",

        value: function setSkewSize(value) {
          _get(
            TiledSurface2d.prototype.__proto__ ||
              Object.getPrototypeOf(TiledSurface2d.prototype),
            "setSkewSize",
            this
          ).call(this, value);

          this.draw(); // todo check
        },

        /** @override */
      },
      {
        key: "setGroutSize",

        value: function setGroutSize(value) {
          _get(
            TiledSurface2d.prototype.__proto__ ||
              Object.getPrototypeOf(TiledSurface2d.prototype),
            "setGroutSize",
            this
          ).call(this, value);

          this.draw(); // todo check
        },

        /** @override */
      },
      {
        key: "setGroutColor",

        value: function setGroutColor(color) {
          _get(
            TiledSurface2d.prototype.__proto__ ||
              Object.getPrototypeOf(TiledSurface2d.prototype),
            "setGroutColor",
            this
          ).call(this, color);

          this._render();
        },
      },
      {
        key: "_rotate",

        value: function _rotate(angle) {
          // angle - 0 - 360 degree

          this.rotation = Number(angle) || 0;

          var rotationInRadians = this.rotation * DEG;

          this.tilesContainer.rotation.z = rotationInRadians;

          this.freeDesignTilesContainer.rotation.z = rotationInRadians;

          this.intersectsPlane.rotation.z = rotationInRadians;
        },

        /** @override */
      },
      {
        key: "rotate",

        value: function rotate(angle) {
          this._rotate(angle);

          this._render();
        },

        // getRandomTileInSet(tileIndex) {

        //     var tilesSet = getTilesSet(tileIndex);

        //     if (tilesSet.length > 1) {

        //         return tilesSet[Math.floor(Math.random() * tilesSet.length)];

        //     }

        //     return tilesSet[0];

        // }
      },
      {
        key: "_checkTilePlace",

        value: function _checkTilePlace(mesh) {
          this.projection.render();

          var intersects = this.projection.getIntersects(
            this.clickPoint,
            mesh.children
          );

          if (intersects.length > 0) {
            return true;
          }
        },

        /** @override */
      },
      {
        key: "setTile",

        value: function setTile(tile) {
          _get(
            TiledSurface2d.prototype.__proto__ ||
              Object.getPrototypeOf(TiledSurface2d.prototype),
            "setTile",
            this
          ).call(this, tile);

          this.draw();
        },

        /** @override */
      },
      {
        key: "setTile2",

        value: function setTile2(tile) {
          _get(
            TiledSurface2d.prototype.__proto__ ||
              Object.getPrototypeOf(TiledSurface2d.prototype),
            "setTile2",
            this
          ).call(this, tile);

          this.draw();
        },
      },
      {
        key: "setFreeDesign",

        value: function setFreeDesign(value) {
          _get(
            TiledSurface2d.prototype.__proto__ ||
              Object.getPrototypeOf(TiledSurface2d.prototype),
            "setFreeDesign",
            this
          ).call(this, value);

          if (!this.freeDesign) {
            // tileDrawer.clearFreeDesignTiles();

            this._render();
          }
        },
      },
      {
        key: "setFreeDesignTile",

        value: function setFreeDesignTile(tile) {
          this.freeDesignTile = tile;
        },
      },
      {
        key: "clearTile2",

        value: function clearTile2() {
          this.tile2 = undefined;

          this.tile2Index = undefined;
        },
      },
      {
        key: "_freeDesignTileApproxPositions",

        value: function _freeDesignTileApproxPositions() {
          var _this50 = this;

          this._freeDesignTileApproxPosition = {
            square: function square(point, tile) {
              var xIndex = Math.floor(
                point.x / (tile.width + _this50.groutSize)
              );

              var yIndex = Math.floor(
                point.y / (tile.height + _this50.groutSize)
              );

              return { xIndex: xIndex, yIndex: yIndex };
            },

            hexagon: function hexagon(point, tile) {
              var groutSizeX = _this50.groutSize * HEXAGON_ASPECT_RATIO$1;

              var xIndex = Math.floor(
                point.x / (tile.width * 1.5 + groutSizeX * 2)
              );

              var yIndex = Math.floor(
                point.y / (tile.height * 0.5 + _this50.groutSize * 0.5)
              );

              return { xIndex: xIndex, yIndex: yIndex };
            },

            diamond: function diamond(point, tile) {
              var groutSizeX = _this50.groutSize * DIAMOND_ASPECT_RATIO;

              var xIndex = Math.floor(point.x / (tile.width + groutSizeX * 2));

              var yIndex = Math.floor(
                point.y / (tile.height * 0.5 + _this50.groutSize)
              );

              return { xIndex: xIndex, yIndex: yIndex };
            },

            preparedSet: function preparedSet(point, tile) {
              var xIndex = Math.floor(
                point.x /
                  (tile.width + _this50.groutSize - tile.preparedSetOffset.x)
              );

              var yIndex = Math.floor(
                point.y /
                  (tile.height + _this50.groutSize - tile.preparedSetOffset.y)
              );

              return { xIndex: xIndex, yIndex: yIndex };
            },
          };

          this._freeDesignTileApproxPosition.rectangle =
            this._freeDesignTileApproxPosition.square;

          this._freeDesignTileApproxPosition.quadSet =
            this._freeDesignTileApproxPosition.square;

          this._freeDesignTileApproxPosition.notionHerringbon =
            this._freeDesignTileApproxPosition.preparedSet;

          this._freeDesignTileApproxPosition.riverstoneRohmboid =
            this._freeDesignTileApproxPosition.preparedSet;

          this._freeDesignTileApproxPosition.rivertsoneChevron =
            this._freeDesignTileApproxPosition.preparedSet;

          this._freeDesignTileApproxPosition.stoneSystemCombo =
            this._freeDesignTileApproxPosition.preparedSet;
        },
      },
      {
        key: "_moveFreeDesignTile",

        value: function _moveFreeDesignTile(mesh, tile, cell) {
          var tilePosition = this._getTilePosition[tile.shape](cell, tile);

          mesh.position.x = tilePosition.x + tile.width / 2;

          mesh.position.y = -(tilePosition.y + tile.height / 2); // + surface.groutSize;

          mesh.rotation.y = tilePosition.rotation || 0;
        },
      },
      {
        key: "_putFreeDesignTileToCell",

        value: function _putFreeDesignTileToCell(tile, point) {
          var _this51 = this;

          // , tileSize

          var neighborTileCells = [
            [0, 0],
            [-1, -1],
            [0, -1],
            [1, -1],
            [-1, 0],
            [1, 0],
            [-1, 1],
            [0, 1],
            [1, 1],
          ];

          var cell = this._freeDesignTileApproxPosition[tile.shape](
            point,
            tile
          );

          var mesh = this._addTileToContainer(
            tile,
            this.freeDesignTilesContainer,
            { x: 0, y: 0 }
          );

          neighborTileCells.some(function (neighborTileCell) {
            _this51._moveFreeDesignTile(mesh, tile, {
              xIndex: cell.xIndex + neighborTileCell[0],
              yIndex: cell.yIndex + neighborTileCell[1],
            });

            if (_this51._checkTilePlace(mesh)) {
              mesh.freeDesignTileData = {
                id: tile.id,

                xIndex: cell.xIndex + neighborTileCell[0],

                yIndex: cell.yIndex + neighborTileCell[1],

                custom: tile.custom,
              };

              _this51.freeDesignTiles.push(mesh.freeDesignTileData);

              return true;
            }
          });
        },
      },
      {
        key: "drawFreeDesignTiles",

        value: function drawFreeDesignTiles() {
          var _this52 = this;

          var loadedImages = 0;

          this.freeDesignTiles.forEach(function (freeDesignTile) {
            var tile = TilesList.getById(
              freeDesignTile.id,
              freeDesignTile.custom
            );

            if (tile) {
              loadingAnimation.show();

              var image = new Image();

              image.onload = function () {
                _this52._prepareTile(tile, image);

                var mesh = _this52._addTileToContainer(
                  tile,
                  _this52.freeDesignTilesContainer,
                  { x: 0, y: 0 }
                );

                _this52._moveFreeDesignTile(mesh, tile, freeDesignTile);

                mesh.freeDesignTileData = freeDesignTile;

                loadedImages += 1;

                if (loadedImages >= _this52.freeDesignTiles.length) {
                  _this52._render();
                }

                loadingAnimation.hide();
              };

              image.onerror = loadingAnimation.hide;

              image.src = tile.file;
            }
          });
        },
      },
      {
        key: "_addFreeDesignTile",

        value: function _addFreeDesignTile(intersect) {
          var _this53 = this;

          if (this.freeDesignTile) {
            loadingAnimation.show();

            var tile = TilesList.getRandomInSet(this.freeDesignTile);

            var image = new Image();

            image.onload = function () {
              _this53._prepareTile(tile, image);

              var x = (intersect.uv.x - 0.5) * PLANE_SIZE;

              var y = -(intersect.uv.y - 0.5) * PLANE_SIZE;

              _this53._putFreeDesignTileToCell(tile, { x: x, y: y });

              _this53._render();

              loadingAnimation.hide();
            };

            image.onerror = loadingAnimation.hide;

            image.src = tile.file;
          }
        },
      },
      {
        key: "_rotateTile",

        value: function _rotateTile(mesh) {
          var angle = Tile3d.Shapes[mesh.tile.shape].rotationStep;

          if (angle !== 0) {
            mesh.rotation.y -= angle || Math.PI;

            this._render();
          }
        },
      },
      {
        key: "_removeFreeDesignTile",

        value: function _removeFreeDesignTile(tileMesh) {
          var tileIndex = this.freeDesignTiles.indexOf(
            tileMesh.freeDesignTileData
          );

          if (tileIndex !== -1) {
            this.freeDesignTiles.splice(tileIndex, 1);
          }

          this.freeDesignTilesContainer.remove(tileMesh);

          this._render();
        },
      },
      {
        key: "freeDesignTileClick",

        value: function freeDesignTileClick(point, direction) {
          this.clickPoint = point;

          var intersects = this.projection.getIntersects(
            point,
            this.freeDesignTilesContainer.children,
            direction
          );

          if (intersects.length > 0) {
            var rotate = document.getElementById(
              "topPanelCheckFreeDesignRotate"
            ).checked;

            if (rotate) {
              this._rotateTile(intersects[0].object.parent);
            } else {
              this._removeFreeDesignTile(intersects[0].object.parent);
            }
          } else {
            intersects = this.projection.getIntersect(
              point,
              this.intersectsPlane
            );

            if (intersects.length > 0) {
              this._addFreeDesignTile(intersects[0]);
            }
          }
        },
      },
      {
        key: "click",

        value: function click(point, direction) {
          var rotate = document.getElementById(
            "topPanelCheckFreeDesignRotate"
          ).checked;

          if (rotate) {
            var intersects = this.projection.getIntersects(
              point,
              this.tilesContainer.children,
              direction
            );

            if (intersects.length > 0) {
              this._rotateTile(intersects[0].object.parent);
            }
          }
        },
      },
      {
        key: "draw",

        value: function draw() {
          this.removeAllTiles();

          if (this.tileIndex !== undefined) {
            this._drawTiles(TilesList[this.tileIndex], 0);
          }

          if (this.tile2Index !== undefined) {
            this._drawTiles(TilesList[this.tile2Index], 1);
          }
        },
      },
      {
        key: "restoreSettings",

        value: function restoreSettings(savedData) {
          if (!savedData) {
            return;
          }

          if (typeof savedData.color !== "undefined")
            this.color = savedData.color;

          if (typeof savedData.groutSize !== "undefined")
            this.groutSize = Number(savedData.groutSize);

          if (typeof savedData.groutColor !== "undefined")
            this.groutColor = savedData.groutColor;

          if (typeof savedData.fillTypeIndex !== "undefined")
            this.fillTypeIndex = Number(savedData.fillTypeIndex);

          if (typeof savedData.tileId !== "undefined")
            this.tileIndex = TilesList.getIndexById(
              savedData.tileId,
              savedData.tileCustom
            );

          if (typeof savedData.tile2Id !== "undefined")
            this.tile2Index = TilesList.getIndexById(
              savedData.tile2Id,
              savedData.tile2Custom
            );

          if (typeof savedData.freeDesign !== "undefined")
            this.freeDesign = savedData.freeDesign;

          if (typeof savedData.freeDesignTiles !== "undefined")
            this.freeDesignTiles = savedData.freeDesignTiles;

          if (typeof savedData.skewSize !== "undefined")
            this.skewSize = savedData.skewSize;

          if (typeof savedData.rotation !== "undefined")
            this._rotate(savedData.rotation);

          this.draw();

          if (this.freeDesign) this.drawFreeDesignTiles();
        },
      },
      {
        key: "_getFreeDesignTilesData",

        value: function _getFreeDesignTilesData() {
          return this.freeDesignTilesContainer.children.map(function (tile) {
            return {
              id: tile.freeDesignTileData.id,

              xIndex: tile.freeDesignTileData.xIndex,

              yIndex: tile.freeDesignTileData.yIndex,

              custom: tile.freeDesignTileData.custom,
            };
          });
        },
      },
      {
        key: "getSettings",

        value: function getSettings() {
          var tile = TilesList[this.tileIndex];

          var tile2 = TilesList[this.tile2Index];

          return {
            color: this.color,

            groutSize: this.groutSize,

            groutColor: this.groutColor,

            rotation: this.rotation,

            fillTypeIndex: this.fillTypeIndex,

            tileId: tile ? tile.id : undefined,

            tileCustom: tile ? tile.custom : undefined,

            tile2Id: tile2 ? tile2.id : undefined,

            tile2Custom: tile2 ? tile2.custom : undefined,

            skewSize: this.skewSize,

            freeDesign: this.freeDesign,

            freeDesignTiles: this._getFreeDesignTilesData(),
          };
        },
      },
      {
        key: "drawGridHelper",

        value: function drawGridHelper(imageFile, size) {
          var _this54 = this;

          if (this._gridHelper) {
            this.removeAllTiles();

            this._render();
          } else {
            this.removeAllTiles();

            this._gridHelper = true;

            loadingAnimation.show();

            var image = new Image();

            image.onload = function () {
              var grid = new Tile3d(_this54.projection.maxAnisotropy);

              var plane = {
                shape: "square",

                width: size,

                height: size,
              };

              var texture = new window.THREE.Texture(image);

              grid.makePlane(plane);

              grid.mesh.material.map = texture;

              texture.needsUpdate = true;

              _this54.tilesContainer.add(grid.mesh);

              _this54._render();

              loadingAnimation.hide();
            };

            image.onerror = loadingAnimation.hide;

            image.src = imageFile;
          }
        },
      },
      {
        key: "getFinish",

        value: function getFinish() {
          if (this.tileIndex !== undefined && TilesList[this.tileIndex]) {
            return TilesList[this.tileIndex].finish;
          }
        },
      },
    ]);

    return TiledSurface2d;
  })(TiledSurface);

  function Backlight(canvas, surfaces, engine2d) {
    var backLightedSurface = void 0;

    function getGroupSurfaces(currentSurface) {
      if (!currentSurface.group) return [currentSurface];

      return surfaces.filter(function (surface) {
        return surface.group === currentSurface.group;
      });
    }

    function show(surface) {
      if (!backLightedSurface || backLightedSurface !== surface) {
        backLightedSurface = surface;

        if (window.JsConstants.config.surfaceBacklight) {
          var backLightedSurfaces = getGroupSurfaces(surface);

          engine2d.render(surfaces, backLightedSurfaces);
        }

        UI.updateCanvasStyle(surface.type);
      }
    }

    function clear() {
      if (backLightedSurface) {
        backLightedSurface = undefined;

        if (window.JsConstants.config.surfaceBacklight) {
          engine2d.render(surfaces);
        }

        UI.updateCanvasStyle();
      }
    }

    function backlightSurface(event) {
      if (surfaces.length > 0) {
        var point = {
          x: (event.offsetX / canvas.offsetWidth) * canvas.width,

          y: (event.offsetY / canvas.offsetHeight) * canvas.height,
        };

        var surfaceFound = surfaces.some(function (surface) {
          if (engine2d.isPointOnShape(point, surface[11])) {
            show(surface);

            return true;
          }
        });

        if (!surfaceFound) {
          clear();
        }
      }
    }

    canvas.addEventListener("mousemove", backlightSurface);

    canvas.addEventListener("mouseout", clear);
  }

  var SurfaceSelectButton = (function () {
    function SurfaceSelectButton(maskPoints, width, height, onClick) {
      _classCallCheck(this, SurfaceSelectButton);

      if (
        UI.isMobileDevice() &&
        window.JsConstants.config.surfaceSelectBrushButtons
      ) {
        var center = this._center(maskPoints);

        var element = this._createElement(onClick);

        element.style.left = (center.x / (width || 1600)) * 100 + "%";

        element.style.top = (center.y / (height || 900)) * 100 + "%";
      }
    }

    _createClass(SurfaceSelectButton, [
      {
        key: "_center",

        value: function _center(maskPoints) {
          var left = maskPoints[0][0];

          var right = maskPoints[0][0];

          var top = maskPoints[0][1];

          var bottom = maskPoints[0][1];

          maskPoints.forEach(function (point) {
            left = Math.min(left, point[0]);

            right = Math.max(right, point[0]);

            top = Math.min(top, point[1]);

            bottom = Math.max(bottom, point[1]);
          });

          return {
            x: (left + right) / 2,

            y: (top + bottom) / 2,
          };
        },
      },
      {
        key: "_createElement",

        value: function _createElement(onClick) {
          var img = document.createElement("img");

          img.src = "/img/icons/brush-select-surface.png";

          var element = document.createElement("div");

          element.onclick = onClick;

          element.className = "surface-select";

          element.appendChild(img);

          var container = document.getElementById("container");

          container.appendChild(element);

          return element;
        },
      },
    ]);

    return SurfaceSelectButton;
  })();

  var Room2d = (function (_Room) {
    _inherits(Room2d, _Room);

    function Room2d(data) {
      _classCallCheck(this, Room2d);

      var _this = _possibleConstructorReturn(
        this,
        (Room2d.__proto__ || Object.getPrototypeOf(Room2d)).call(this, data)
      );

      _this._engineType = "2d";
      _this._createSurfaces(data.roomData);
      _this._restoreSettings(data.roomSettings);

      // Explicitly bind methods
      // _this._setGroutColorPredefined =
      //   _this._setGroutColorPredefined.bind(_this);
      // _this._isSurfaceSelected = _this._isSurfaceSelected.bind(_this);

      return _this;
    }

    _createClass(Room2d, [
      {
        key: "_initElements",
        value: function _initElements() {
          clearTiles();
          // tiledSurfaces;
          // // Clean up old event handlers
          $("#inputSearch").off("input");
          $("#topPanelGroutSizeRange").off("change");
          $("#grout-predefined-color .-btn").off("click");
          $("#topPanelCheckFreeDesign").off("change");
          $(".radio-surface-pattern > input").off("change");
          $(".radio-surface-pattern > li").off("click");
          $(".radio-skew-size input").off("change");
          $(".radio-surface-rotation > input").off("click");
          $(".radio-surface-rotation > li").off("click");
          $("#bottomMenuRoomInfo").off("click");
          $("#btnDialogSaveImage").off("click");
          $("#btnDialogSavePdf").off("click");
          $("#btnDialogSaveScene").off("click");
          $(".social-share a").off("click");
          $("#bottomMenuMail").off("click");
          $(".clear-all").off("click");
          $("#shadow-menu").off();

          this._groutColorPicker = new ColorPicker(
            "grout-color-picker",
            (color) => this._setGroutColor(color)
          );
          // Bind new event handlers to the current instance
          $("#inputSearch").on("input", (event) => this._find(event));
          $("#topPanelGroutSizeRange").change((event) =>
            this._setGroutSize(event)
          );
          $("#grout-predefined-color .-btn").click((event) =>
            this._setGroutColorPredefined(event)
          );
          $("#topPanelCheckFreeDesign").change((event) =>
            this._setCheckFreeDesign(event)
          );
          $(".radio-surface-pattern > input").change((event) =>
            this._setPattern(event)
          );
          $(".radio-surface-pattern > li").click((event) =>
            this._setPattern(event)
          );
          $(".radio-skew-size input").change((event) =>
            this._setSkewSize(event)
          );
          $(".radio-surface-rotation > input").click((event) =>
            this._setPatternRotation(event)
          );
          $(".radio-surface-rotation > li").click((event) =>
            this._setPatternRotation(event)
          );
          $("#bottomMenuRoomInfo").click(() => this._showRoomInfo());

          if (window.JsConstants.config.saveImageAsDoc) {
            $("#btnDialogSaveImage").click(() => imageAsDoc(this, TilesList));
          } else {
            $("#btnDialogSaveImage").click(() => canvasImage(this.canvas));
          }

          $("#btnDialogSavePdf").click(() => saveRoomPdf(this, TilesList));
          $("#btnDialogSaveScene").click(() => this._save());
          $(".social-share a").click((event) => this._share(event));
          $("#bottomMenuMail").click((event) => this._share(event));
          $(".clear-all").click(() => this._clear());

          $("#shadow-menu").on("change", (event) => {
            this._setShadowIntensity(event.target.value / 100);
          });

          // Call the parent class's _initElements
          _Room.prototype._initElements.call(this);
        },
      },
      // {
      //   key: "_setShadowIntensity",
      //   value: async function _setShadowIntensity(intensity) {
      //     console.log("_setShadowIntensity:", this);
      //     const image = await loadImage(this.image);
      //     const mask = await loadImage(this.mask);
      //     const shadowMap = await loadImage(this.sh_map);
      //     const reflectionMap = await loadImage(this.reflect);
      //     const wallmask = await loadImage(this.wallmask);

      //     const processed = processMaps(
      //       image,
      //       mask,
      //       shadowMap,
      //       reflectionMap,
      //       intensity,
      //       wallmask
      //     );
      //     const shadow = await loadImage(processed.shadow);

      //     //this._engine2d._shadowGlossy = shadow;
      //     this._engine2d._shadowMatt = shadow;
      //     this._render();
      //   },
      // },
      {
        key: "_createView",
        value: function _createView() {
          var _this = this;
          this.canvas = document.getElementById("roomCanvas");
          this.canvas.addEventListener("click", (event) =>
            this._sceneMouseClick(event)
          );
          this._engine2d = new Engine2D(this.canvas);
          this._engine2d.loadImages(
            this,
            RoomLoadProgress.end,
            RoomLoadProgress.progress,
            this.tiledSurfaces
          );
          Backlight(this.canvas, this.tiledSurfaces, this._engine2d);
        },
      },
      {
        key: "_render",
        value: function _render() {
          this._engine2d.render(this.tiledSurfaces);
        },
      },
      {
        key: "_setGroutSizeValue",
        value: function _setGroutSizeValue(value) {
          this._getGroupSurfaces(this.currentTiledSurface).forEach(function (
            surface
          ) {
            return surface.setGroutSize(value);
          });
          this._ui.changeGroutSize(this.currentTiledSurface.groutSize);
        },
      },
      {
        key: "_restoreSettings",
        value: function _restoreSettings(settings) {
          var _this = this;
          var tile0;
          var url = new URL(window.location.href);
          var productName = url.searchParams.get("product-name");
          if (productName && typeof productName === "string") {
            var name = productName.trim().toLowerCase();
            TilesList.some(function (tile) {
              var tileName = tile.name.trim().toLowerCase();
              if (tileName === name) {
                tile0 = tile;
                if (!settings) {
                  settings = {
                    surfaces: Array(_this.tiledSurfaces.length).fill(undefined),
                  };
                }
                return true;
              }
            });
          } else {
            var productCode = url.searchParams.get("product-code");
            if (productCode && typeof productCode === "string") {
              TilesList.some(function (tile) {
                if (tile["product code"] === productCode) {
                  tile0 = tile;
                  if (!settings) {
                    settings = {
                      surfaces: Array(_this.tiledSurfaces.length).fill(
                        undefined
                      ),
                    };
                  }
                  return true;
                }
              });
            }
          }
          if (settings && Array.isArray(settings.surfaces)) {
            settings.surfaces.forEach(function (surfaceSettings, index) {
              if (tile0 && _this.tiledSurfaces[index].type === tile0.surface) {
                if (surfaceSettings) {
                  surfaceSettings.tileId = tile0.id;
                } else {
                  surfaceSettings = { tileId: tile0.id };
                }
              }
              _this.tiledSurfaces[index].restoreSettings(surfaceSettings);
            });
          }
        },
      },
      {
        key: "_sceneMouseClick",
        value: function _sceneMouseClick(event) {
          var _this = this;
          if (this.tiledSurfaces.length > 0) {
            var point = {
              x:
                (event.offsetX / this._engine2d.canvas.offsetWidth) *
                this._engine2d.canvas.width,
              y:
                (event.offsetY / this._engine2d.canvas.offsetHeight) *
                this._engine2d.canvas.height,
            };
            var scrollWidth = event?.currentTarget?.scrollWidth;
            var scrollHeight = event?.currentTarget?.scrollHeight;
            var normalizedPoint = {
              x: (event.offsetX / scrollWidth) * 2 - 1,
              y: (-event.offsetY / scrollHeight) * 2 + 1,
            };
            this.tiledSurfaces.some(function (surface) {
              const bool = _this._engine2d.isPointOnShape(point, surface[11]);
              if (bool) {
                _this._onSurfaceClick(surface);
                if (surface.freeDesign) {
                  if (surface.freeDesignTile) {
                    surface.freeDesignTileClick(normalizedPoint);
                  } else {
                    _this._ui.alertWarning("Tile not selected.");
                  }
                } else {
                  surface.click(normalizedPoint);
                }
                return true;
              }
            });
          }
        },
      },
      {
        key: "_createSurfaces",
        value: function _createSurfaces(roomData) {
          var _this = this;
          this.surfacesData = JSON.parse(this.surfaces);
          if (Array.isArray(this.surfacesData)) {
            this.surfacesData.forEach(function (surfaceData) {
              var surface = new TiledSurface2d(
                surfaceData,
                roomData,
                function () {
                  return _this._render();
                }
              );
              _this.tiledSurfaces.push(surface);
              new SurfaceSelectButton(
                surface[11],
                surface.projection.width,
                surface.projection.height,
                function () {
                  return _this._onSurfaceClick(surface);
                }
              );
            });
          }
        },
      },
    ]);

    return Room2d;
  })(Room);

  function clearOldRoom2d(roomInstance) {
    if (!roomInstance) return;

    try {
      // Clean up canvas event listeners
      if (roomInstance.canvas) {
        roomInstance.canvas.removeEventListener(
          "click",
          roomInstance._sceneMouseClick
        );
        roomInstance.canvas = null; // Remove reference to the canvas
      }

      // Dispose of the 2D engine
      if (
        roomInstance._engine2d &&
        typeof roomInstance._engine2d.dispose === "function"
      ) {
        roomInstance._engine2d.dispose();
        roomInstance._engine2d = null; // Remove reference to the engine
      }

      // Clean up tiled surfaces
      if (Array.isArray(roomInstance.tiledSurfaces)) {
        roomInstance.tiledSurfaces.forEach((surface) => {
          if (surface && typeof surface.dispose === "function") {
            surface.dispose();
          }
        });
        roomInstance.tiledSurfaces.length = 0; // Clear the array
        roomInstance.tiledSurfaces = null; // Remove reference to the array
      }

      // Clean up the UI
      if (roomInstance._ui && typeof roomInstance._ui.destroy === "function") {
        roomInstance._ui.destroy();
        roomInstance._ui = null; // Remove reference to the UI
      }

      // Clean up any other resources
      if (roomInstance._groutColorPicker) {
        roomInstance._groutColorPicker.destroy(); // Assuming a destroy method exists
        roomInstance._groutColorPicker = null;
      }

      if (roomInstance._surfaceColorPicker) {
        roomInstance._surfaceColorPicker.destroy(); // Assuming a destroy method exists
        roomInstance._surfaceColorPicker = null;
      }

      // Clean up event listeners bound to DOM elements
      $("#grout-predefined-color .-btn").off("click");
      $("#topPanelGroutSizeRange").off("change");
      $("#inputSearch").off("input");
      // Add other event listeners here...

      // Nullify other properties
      roomInstance.currentTiledSurface = null;
      roomInstance.savedUrl = null;
      roomInstance._filters = null;
    } catch (error) {
      console.error("Error while cleaning up Room2d instance:", error);
    }
  }

  const withImageAndFOV = function (image, then) {
    EXIF.getData(image, function () {
      const af = image.height > image.width ? image.height / image.width : 1;

      const fl = image.exifdata.FocalLengthIn35mmFilm;

      const fov = fl
        ? 2 * Math.atan((af * 36) / (2 * fl)) * 57.295779513
        : 42 * af;

      // console.log("Setting fov to", fov);

      then(image, fov);
    });
  };

  function processMaps_old(image, mask, sh_map, reflectMap, shadowIntensity) {
    shadowIntensity = Math.max(0, Math.min(shadowIntensity, 1));

    const canvas = document.createElement("canvas");

    const context = canvas.getContext("2d", {
      willReadFrequently: true,
    });

    canvas.width = image.width;
    canvas.height = image.height;

    context.drawImage(image, 0, 0, canvas.width, canvas.height);

    const imageData = context.getImageData(0, 0, canvas.width, canvas.height);

    canvas.width = canvas.width;

    // Reflect map resize
    context.drawImage(reflectMap, 0, 0, canvas.width, canvas.height);

    const reflectData = context.getImageData(0, 0, canvas.width, canvas.height);

    canvas.width = canvas.width;

    context.drawImage(mask, 0, 0, canvas.width, canvas.height);

    const maskData = context.getImageData(0, 0, canvas.width, canvas.height);

    canvas.width = canvas.width;

    context.drawImage(sh_map, 0, 0, canvas.width, canvas.height);

    const shadowData = context.getImageData(0, 0, canvas.width, canvas.height);

    for (let p = 0; p < imageData.data.length; p += 4) {
      const m = maskData.data[p] / 255,
        m1 = 1 - m;

      const shadow = shadowData.data[p];
      const shadowM =
        (shadowIntensity * shadow + (1 - shadowIntensity) * 255) * m;

      // sh_map -> shadow

      shadowData.data[p + 0] = shadowM + imageData.data[p + 0] * m1;
      shadowData.data[p + 1] = shadowM + imageData.data[p + 1] * m1;
      shadowData.data[p + 2] = shadowM + imageData.data[p + 2] * m1;

      // image -> image - mask

      imageData.data[p + 3] = 255 * m1;
    }

    canvas.width = canvas.width;

    context.putImageData(imageData, 0, 0);

    const imageUrl = canvas.toDataURL();

    canvas.width = canvas.width;

    context.putImageData(shadowData, 0, 0);

    const shadow = canvas.toDataURL();

    // Reflect map

    context.putImageData(reflectData, 0, 0);
    const reflectUrl = canvas.toDataURL();

    return { image: imageUrl, shadow, reflect: reflectUrl };
  }

  function processMaps(
    image,
    mask,
    sh_map,
    reflectMap,
    shadowIntensity,
    wallmask
  ) {
    shadowIntensity = Math.max(0, Math.min(shadowIntensity, 1));

    const canvas = document.createElement("canvas");
    const context = canvas.getContext("2d", {
      willReadFrequently: true,
    });

    canvas.width = image.width;
    canvas.height = image.height;

    // Draw the original image and get its pixel data
    context.drawImage(image, 0, 0, canvas.width, canvas.height);
    const imageData = context.getImageData(0, 0, canvas.width, canvas.height);

    // Draw the reflection map and get its pixel data
    context.clearRect(0, 0, canvas.width, canvas.height);
    context.drawImage(reflectMap, 0, 0, canvas.width, canvas.height);
    const reflectData = context.getImageData(0, 0, canvas.width, canvas.height);

    // Draw the mask and get its pixel data
    context.clearRect(0, 0, canvas.width, canvas.height);
    context.drawImage(mask, 0, 0, canvas.width, canvas.height);
    const maskData = context.getImageData(0, 0, canvas.width, canvas.height);

    // Draw the wallmask (if provided) and get its pixel data
    let wallmaskData = null;
    if (wallmask) {
      context.clearRect(0, 0, canvas.width, canvas.height);
      context.drawImage(wallmask, 0, 0, canvas.width, canvas.height);
      wallmaskData = context.getImageData(0, 0, canvas.width, canvas.height);
    }

    // Draw the shadow map and get its pixel data
    context.clearRect(0, 0, canvas.width, canvas.height);
    context.drawImage(sh_map, 0, 0, canvas.width, canvas.height);
    const shadowData = context.getImageData(0, 0, canvas.width, canvas.height);
    for (let p = 0; p < imageData.data.length; p += 4) {
      const m = maskData.data[p] / 255; // Original mask value
      const m1 = 1 - m;

      // Apply wallmask (if provided)
      let wallMaskValue = 1; // Default to no wallmask effect
      if (wallmask && wallmaskData) {
        wallMaskValue = wallmaskData.data[p] / 255; // Wallmask value
      }

      // Combine masks (union)
      const combinedMask = Math.max(m, wallMaskValue); // Use the maximum of both masks
      const combinedM1 = 1 - combinedMask; // Inverse of the combined mask

      const shadow = shadowData.data[p];
      const shadowM =
        (shadowIntensity * shadow + (1 - shadowIntensity) * 255) * combinedMask;

      // Apply shadow to the image with combined masks
      shadowData.data[p + 0] = shadowM + imageData.data[p + 0] * combinedM1;
      shadowData.data[p + 1] = shadowM + imageData.data[p + 1] * combinedM1;
      shadowData.data[p + 2] = shadowM + imageData.data[p + 2] * combinedM1;

      // Adjust alpha channel based on combined masks
      imageData.data[p + 3] = 255 * combinedM1;
    }
    // Generate the processed image URL
    context.putImageData(imageData, 0, 0);
    const imageUrl = canvas.toDataURL();

    // Generate the shadow URL
    context.putImageData(shadowData, 0, 0);
    const shadow = canvas.toDataURL();

    // Generate the reflection URL
    context.putImageData(reflectData, 0, 0);
    const reflectUrl = canvas.toDataURL();

    return { image: imageUrl, shadow, reflect: reflectUrl };
  }

  async function loadImage(src) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = src;
    });
  }

  function cropServerImage(image, aspect, isMask) {
    let width = image.width;
    let height = image.height;
    let vMargin = 0;
    let hMargin = 0;

    if (aspect >= 1) {
      width = 1200;
      height = width / aspect;
      vMargin = (1200 - height) / 2;
    } else {
      height = 1200;
      width = height * aspect;
      hMargin = (1200 - width) / 2;
    }

    const c = document.createElement("canvas");
    c.width = width;
    c.height = height;
    const ctx = c.getContext("2d");
    ctx.drawImage(image, hMargin, vMargin, width, height, 0, 0, width, height);
    return c.toDataURL(isMask ? "image/png" : "image/jpeg", 1.0);
  }

  function uniqueID() {
    const timestamp = Date.now();
    const randomNum = Math.floor(Math.random() * 1000000);
    const uniqueID = parseInt(
      (timestamp.toString() + randomNum.toString()) / 100
    );
    return uniqueID;
  }

  function setLoadingMessage(value) {
    $("#loadingMessage").text(value);
  }

  const handleImage = async function (image, fov, json, aspect) {
    localStorage.setItem("shouldInit", "1");
    // // console.log("HandleImage got res:", json);
    aspect = aspect || 1;

    // create compatible images...

    let sh_map = await loadImage(json.sh_map);
    const serverWidth = sh_map.width;
    const serverHeight = sh_map.height;
    json.sh_map = cropServerImage(sh_map, aspect);
    sh_map = await loadImage(json.sh_map);

    const reflectCanvas = await dilateImage(
      json.reflect,
      serverWidth,
      serverHeight,
      [6, 6]
    );
    let reflectImg = await loadImage(reflectCanvas.toDataURL());
    json.reflect = cropServerImage(reflectImg, aspect);
    reflectImg = await loadImage(json.reflect);

    // Clean up mask
    const maskCanvas = await dilateImage(json.mask, serverWidth, serverHeight);
    let mask = await loadImage(maskCanvas.toDataURL());

    const ctxMsk = maskCanvas.getContext("2d");
    const maskData = ctxMsk.getImageData(0, 0, serverWidth, serverHeight);

    for (let i = 0; i < maskData.data.length; i += 4) {
      let grayscale = maskData.data[i]; // Use R channel (same as G & B in grayscale)
      maskData.data[i + 3] = grayscale; // Set grayscale as alpha (white = visible, black = transparent)
    }
    ctxMsk.putImageData(maskData, 0, 0);
    let transparentMask = await loadImage(maskCanvas.toDataURL());

    mask = await loadImage(cropServerImage(transparentMask, aspect, true));
    json.mask = cropServerImage(transparentMask, aspect, true);
    // // console.log("json.mask", json.mask);
    //  = await loadImage(json.mask);

    // Clean up mask
    // const maskCanvas = await dilateImage(json.mask, serverWidth, serverHeight);
    // let mask = await loadImage(maskCanvas.toDataURL());
    // json.mask = cropServerImage(mask, aspect);

    let wallmask = null;
    let wallmaskCanvas = null;
    if (json.wallmask) {
      wallmaskCanvas = await dilateImage(
        json.wallmask,
        serverWidth,
        serverHeight
      );

      wallmask = await loadImage(wallmaskCanvas.toDataURL());
      const ctx = wallmaskCanvas.getContext("2d");
      const wallMaskData = ctx.getImageData(0, 0, serverWidth, serverHeight);

      for (let i = 0; i < wallMaskData.data.length; i += 4) {
        let grayscale = wallMaskData.data[i]; // Use R channel (same as G & B in grayscale)
        wallMaskData.data[i + 3] = grayscale; // Set grayscale as alpha (white = visible, black = transparent)
      }
      ctx.putImageData(wallMaskData, 0, 0);
      // wallmask = await loadImage(wallmaskCanvas.toDataURL());

      json.wallmask = wallmaskCanvas.toDataURL("image/png", 1.0);
      // // console.log("json.wallmask ", json.wallmask);
      // wallmask = await loadImage(json.wallmask);
    }

    const processed = processMaps(
      image,
      mask,
      sh_map,
      reflectImg,
      0.6,
      wallmask
    );

    json.image = processed.image;
    json.shadow_matt = processed.shadow;
    json.shadow = processed.reflect;

    json.width = image.width;
    json.height = image.height;

    const loader = new Loader();

    loader.onLoad = function (data) {
      if (window.currentRoom2d) {
        clearOldRoom2d(window.currentRoom2d);
      }
      // console.log("Loader.onLoad::", { ...data }, { ...json });
      const wallObj = {
        0: 4, // tile type

        1: 0,
        2: 0,
        3: 0, // position

        4: 0,
        5: 0,
        6: 0, // rotation

        7: 5000,
        8: 5000,
        9: 14,
        10: 14,

        11: [
          [0, 165.33],
          [0, 648],
          [33.33, 681.33],
          [33.33, 129.33],
        ],
        // [
        //   [0, 0],
        //   [json.width / 2, 0],
        //   [json.width / 2, json.height / 2],
        //   [0, json.height / 2],
        // ],

        176: "wall",

        group: 3,
        viewVerticalOffset: 0,
        viewHorizontalOffset: 0,

        cameraFov: fov,
      };
      const surfacesWalls = data.roomData.wallsPts.map((wall, index) => {
        const wallcopy = { ...wallObj };
        wallcopy[11] = wall.map((pt) => [pt.x, pt.y]);
        wallcopy[0] = index;
        wallcopy.group = 2;
        return wallcopy;
      });
      const surfaceFloors = data.roomData.floors.map((floor, index) => {
        const floorcopy = { ...wallObj };
        floorcopy[11] = floor.map((pt) => [pt.x, pt.y]);
        floorcopy[0] = surfacesWalls.length + index;
        floorcopy[176] = "floor";
        floorcopy.group = 1;
        return floorcopy;
      });
      // console.log("surfaces:", surfacesWalls);
      data.roomData.surfaceTypes = {
        wall: "Wall",
        floor: "Floor",
        furniture: "Furniture",
        counter: "Counter",
        outdoor: "Outdoor",
      };
      data.roomData.surfaces = JSON.stringify(
        [...surfacesWalls, ...surfaceFloors]
        // [
        //   {
        //     0: 4, // tile type

        //     1: 0,
        //     2: 0,
        //     3: 0, // position

        //     4: 0,
        //     5: 0,
        //     6: 0, // rotation

        //     7: 5000,
        //     8: 5000, // plane size

        //     9: 5,
        //     10: 5, // scaling

        //     11: [
        //       // Mask Path Points
        //       [0, 0],
        //       [json.width, 0],
        //       [json.width, json.height],
        //       [0, json.height],
        //     ],

        //     176: "floor",

        //     group: 3,
        //     viewVerticalOffset: 0,
        //     viewHorizontalOffset: 0,

        //     cameraFov: fov,
        //   },
        // ]
      );
      window.currentRoom2d = new Room2d(data);
      return window.currentRoom2d;
    };

    loader._loadData(
      "data:application/json;base64," + btoa(JSON.stringify(json))
    );

    document.getElementById("companyLogo").closest("a").style.pointerEvents =
      "none";
  };

  // user-uploaded image
  // <form action="http://184.105.3.223:8022/run_fast" method="POST" enctype="multipart/form-data">
  // <input type="file" name="img" />
  function fileUpload() {
    const form = document.createElement("form");
    form.enctype = "multipart/form-data";
    const input = document.createElement("input");
    input.name = "img";
    input.type = "file";
    input.accept = "image/*";
    form.appendChild(input);

    const toDataURI = (image, w, h, q = 0.6) => {
      const c = document.createElement("canvas");
      c.width = w;
      c.height = h;
      const ctx = c.getContext("2d");
      ctx.drawImage(image, 0, 0, w, h);
      return c.toDataURL("image/jpeg", q);
    };

    function resizeImageForUpload(img, maxWidth = 1200, maxHeight = 1200) {
      const canvas = document.createElement("canvas");
      let width = img.width;
      let height = img.height;

      // Check if resizing is necessary
      const aspectRatio = width / height;

      if (width > height) {
        width = maxWidth;
        height = width / aspectRatio;
      } else {
        height = maxHeight;
        width = height * aspectRatio;
      }

      // Set canvas dimensions
      canvas.width = width;
      canvas.height = height;

      // Draw image on canvas
      const ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0, width, height);

      // Convert canvas to base64 encoded image
      return canvas.toDataURL("image/jpeg", 1.0); // adjust quality as needed
    }

    input.addEventListener("change", function () {
      RoomLoadProgress.start();
      setLoadingMessage("Uploading image to the server.");

      setTimeout(() => {
        setLoadingMessage("Processing the image, please wait a few seconds");
      }, Math.random() * 2000 + 4000);

      const reader = new FileReader();

      reader.onload = function () {
        const image = new Image();
        image.src = reader.result;

        image.onload = async function () {
          withImageAndFOV(image, async function (image, fov) {
            /*
                fetch(
                    'http://184.105.3.223:8022/run_fast',
                  //'https://3dtour.3droomvisualizer.com/js/room/test/image00002.json',
                {
                    body: new FormData(form), method: 'post'
                }).then(function(response) {
                    return response.json();
                }).then(function(json) {
                    handleImage(image, fov, json);
                });
            */

            const aspect = image.width / image.height;

            // Resize to 1600
            const hqImage = resizeImageForUpload(image, 1600, 1600, 1.0);

            // resize to 1200
            const uploadedImage = resizeImageForUpload(image);

            let base64Img = uploadedImage.split("base64,")[1]; // Replace with actual Base64 string for img
            const im = await base64ToMat(base64Img);
            const shmap = await createShadowMapAsBase64(im);

            ws.onmessage = async function (e) {
              ws.onmessage = null;

              const input = JSON.parse(e.data);

              // input is { msk, shmap, pts }
              // output needs to be { mask, sh_map, x1, y1... y4 }
              // console.log("Res from WS:", aspect, input);
              var output = {
                // mask: getWhiteMask(),
                mask: "data:image/jpeg;base64," + input.msk,
                wallmask: "data:image/jpeg;base64," + input.wallmsk,
                sh_map: "data:image/jpeg;base64," + shmap,
                reflect: "data:image/jpeg;base64," + input.reflect,
              };

              if (!input.reflect) {
                output.reflect = output.sh_map;
              }

              const reg = /\[|\]|,/g;
              var pts_old = input.pts
                .split("][")
                .map((s) => s.trim().replace(reg, ""));
              var pts = transformArray(
                input.pts.split("][").map((s) => s.trim().replace(reg, ""))
              );
              var wallsPts = transformArray(
                input.wallpts.split("][").map((s) => s.trim().replace(reg, ""))
              );
              // var wallpts = chunkArray(
              //   input.wallpts.split("][").map((s) => s.trim().replace(reg, "")),
              //   4
              // );

              // here pts are [ "436 901", "7 2641", "0 1002", "1085 1338" ]

              // but the order is incorrect...
              // console.log("wallsPts", wallsPts);
              // console.log("pts", pts);
              const order =
                input.vptype == "single" ? [2, 1, 4, 3] : [2, 4, 1, 3];
              const orderWall = [1, 4, 3, 2];
              const scale = 1600 / 1200; // To scale the pairs

              let vMargin = 0;
              let hMargin = 0;

              if (aspect >= 1) {
                const height = 1200 / aspect;
                vMargin = (1200 - height) / 2;
              } else {
                const width = 1200 * aspect;
                hMargin = (1200 - width) / 2;
              }

              pts_old.forEach((s, i) => {
                var pair = s.trim().split(/\s+/);
                output["x" + order[i]] = (Number(pair[0]) - hMargin) * scale;
                output["y" + order[i]] = (Number(pair[1]) - vMargin) * scale;
              });

              // output.floor = new Array(4).fill({ x: 0, y: 0 });
              // pts.forEach((s, i) => {
              //   var pair = s.trim().split(/\s+/);
              //   output.floor[order[i]] = {
              //     x: (Number(pair[0]) - hMargin) * scale,
              //     y: (Number(pair[1]) - vMargin) * scale,
              //   };
              // });
              output.floors = [];
              pts.forEach((floor, index) => {
                output.floors[index] = [];
                floor.forEach((arr, i) => {
                  let el = {
                    x: (Number(arr[0]) - hMargin * 1) * scale,
                    y: (Number(arr[1]) - vMargin * 1) * scale,
                  };
                  // const el = { Landscape
                  //   x: (Number(arr[0]) - hMargin * 1) * scale,
                  //   y: (Number(arr[1]) - vMargin * 1) * scale,
                  // };
                  output.floors[index][order[i] - 1] = el;
                });
              });

              output.wallsPts = [];
              // output.wallsPts=new Array(4).fill(new Array(4).fillnew Array(4).fill({x: 0, y: 0}))
              wallsPts.forEach((wall, index) => {
                output.wallsPts[index] = [];
                wall.forEach((arr, i) => {
                  // Portrait
                  let el = {
                    x: Number(arr[0]),
                    y: Number(arr[1]),
                  };
                  if (aspect >= 1) {
                    // Landscape
                    el = {
                      x: Number(arr[0]) * scale,
                      y: Number(arr[1]) * scale,
                    };
                  }
                  // const el = { portrait
                  //   x: (Number(arr[0]) - hMargin * 0) * 1,
                  //   y: (Number(arr[1]) - vMargin * 0) * 1,
                  // };
                  // const el = { Landscape
                  //   x: (Number(arr[0]) - hMargin * 0) * scale,
                  //   y: (Number(arr[1]) - vMargin * 0) * scale,
                  // };
                  output.wallsPts[index][orderWall[i] - 1] = el;
                });
              });

               // Mark loading as complete
               allLoadCompleted();

              // get new image, too
              image = new Image();

              image.onload = function () {
                handleImage(image, fov, output, aspect);
              };

              image.src = hqImage;
            };

            // send to a websocket
            ws.send(
              JSON.stringify({
                id: uniqueID(),
                reflect_flag: "0",
                image: uploadedImage.split("base64,")[1],
              })
            );
          });
        };
      };

      reader.readAsDataURL(input.files[0]);
    });

    return { input, form };
  }

  window.addEventListener("load", function () {
    localStorage.removeItem("shouldInit");
    const script = document.createElement("script");
    script.src = "https://cdn.jsdelivr.net/npm/exif-js@2.3.0/exif.js";
    document.head.appendChild(script);

    if (location.hash === "#test") {
      const select = document.createElement("select");
      select.style.position = "absolute";
      select.style.left = "50%";
      select.style.top = "50%";
      select.style.transform = "translate(-50%,-50%)";
      select.style.marginTop = "30px";

      const inames = [
        "exif-no-1.png",
        "exif-no-3.png",
        "exif-no-kit-din1.jpg",

        "image00001.jpeg",
        "image00002.jpeg",
        "image00003.jpeg",
        "image00019.jpeg",
      ];

      for (let i = -1; i < inames.length; i++) {
        const option = document.createElement("option");

        option.textContent = inames[i] || "Select an image:";

        if (i < 0) {
          option.disabled = option.selected = true;
        } else {
          option.value =
            "//3dtour.3droomvisualizer.com/js/room/test/" + inames[i];
        }

        select.appendChild(option);
      }

      const uploadOption = document.createElement("option");
      uploadOption.textContent = "upload your image";
      uploadOption.value = "";
      select.appendChild(uploadOption);

      document
        .getElementById("sourceLoadProgressBarContainer")
        .appendChild(select);

      select.onchange = function () {
        select.remove();

        const image = new Image();

        if (select.value) {
          // preprocessed images
          image.src = select.value;

          image.onload = function () {
            withImageAndFOV(image, function (image, fov) {
              $.getJSON(
                select.value.replace(/\.[^\.]+$/, ".json"),
                function (json) {
                  handleImage(image, fov, json);
                }
              );
            });
          };
        } else {
          const { input } = fileUpload();
          input.click();
        }
      };
    } else if (window.JsConstants.room.isDefault) {
      // Show room select popup
      $("#dialogRoomSelect").modal("show");
      RoomLoadProgress.end();
    } else {
      new Loader().loadRoom("/get/room2d/", function (data) {
        // console.log("INSIDE onload!:", data);

        if (window.currentRoom2d) {
          clearOldRoom2d(window.currentRoom2d);
        }

        window.currentRoom2d = new Room2d(data);

        return window.currentRoom2d;
      });
    }

    $("#upload-image").on("click", function () {
      const { input } = fileUpload();

      input.addEventListener("change", function () {
        $("#dialogRoomSelect").modal("hide");
      });

      input.click();
    });

    $("#change-room").on("click", function () {
      $("#dialogRoomSelect").modal("show");

      window.addEventListener("load", function () {
        new Loader().loadRoom("/get/room2d/", function (data) {
          if (window.currentRoom2d) {
            clearOldRoom2d(window.currentRoom2d);
          }
          window.currentRoom2d = new Room2d(data);
          return window.currentRoom2d;
        });
      });
    });
  });
})();


function chunkArray(arr, chunkSize) {
  const result = [];
  for (let i = 0; i < arr.length; i += chunkSize) {
    result.push(arr.slice(i, i + chunkSize));
  }
  return result;
}
function transformArray(arr) {
  // Split each string into two numbers and convert them to arrays
  const splitArrays = arr.map((str) => str.trim().split(/\s+/).map(Number));
  // console.log("transformArray", arr, splitArrays);
  // Group the split arrays into chunks of 4
  const result = [];
  for (let i = 0; i < splitArrays.length; i += 4) {
    result.push(splitArrays.slice(i, i + 4));
  }
  // console.log("result", result);

  return result;
}

function getWhiteMask() {
  // Create a canvas element
  const canvas = document.createElement("canvas");
  canvas.width = 1200;
  canvas.height = 800;

  // Get the 2D context
  const ctx = canvas.getContext("2d");

  // Fill the canvas with white
  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Convert the canvas to a Base64 image (PNG format)
  const base64String = canvas.toDataURL("image/png");

  // Remove the canvas from the DOM (cleanup)
  canvas.remove();

  // console.log(base64String);
  return base64String;
}

// Compute transformation matrix
function computeTransformation(renderer, points2D, camera) {
  // console.log("camera", camera);
  camera.updateMatrixWorld();
  const f =
    (0.5 * renderer.domElement.height) /
    Math.tan((0.5 * camera.fov * Math.PI) / 180);
  camera.near = 0.01;
  camera.far = 1200000;
  camera.updateProjectionMatrix();

  const [x0, y0] = [points2D[0].x, points2D[0].y];
  const [x1, y1] = [points2D[1].x, points2D[1].y];
  const [x2, y2] = [points2D[2].x, points2D[2].y];
  const [x3, y3] = [points2D[3].x, points2D[3].y];

  const m = new THREE.Matrix4();
  m.makeBasis(
    new THREE.Vector3(-x1, -y1, f),
    new THREE.Vector3(x2, y2, -f),
    new THREE.Vector3(-x3, -y3, f)
  );
  m.setPosition(new THREE.Vector3(x0, y0, -f));
  m.getInverse(m);

  const s = 1 / Math.min(m.elements[12], m.elements[13], m.elements[14]);
  const P0 = new THREE.Vector3(x0, y0, -f).multiplyScalar(s);
  const P1 = new THREE.Vector3(x1, y1, -f).multiplyScalar(s * m.elements[12]);
  const P2 = new THREE.Vector3(x2, y2, -f).multiplyScalar(s * m.elements[13]);
  const P3 = new THREE.Vector3(x3, y3, -f).multiplyScalar(s * m.elements[14]);

  const T = P0.clone().add(P2).multiplyScalar(0.5);
  const X = P1.clone().add(P2).multiplyScalar(0.5).sub(T);
  const Y = P0.clone().add(P1).multiplyScalar(0.5).sub(T);
  const Z = X.clone().cross(Y);

  return { T, X, Y, Z };
}

// Apply transformation to the mesh
function applyTransformation(mesh, transformation, camera) {
  const { T, X, Y, Z } = transformation;
  mesh.matrix.makeBasis(X, Y, Z);
  mesh.matrix.setPosition(T);
  mesh.matrix.premultiply(camera.matrix);

  mesh.matrixAutoUpdate = false;
}

// Compute and apply transformation
function updateTransformation(renderer, mesh, points2D, camera) {
  const transformation = computeTransformation(renderer, points2D, camera);
  applyTransformation(mesh, transformation, camera);
}

// ==================== HELPER FUNCTIONS ====================
function downloadBase64Image(base64, filename = "output.jpg") {
  // Create a link element
  const link = document.createElement("a");
  link.href = `data:image/jpeg;base64,${base64}`; // Set the Base64 data as the href
  link.download = filename; // Set the filename for the downloaded file
  document.body.appendChild(link); // Append the link to the DOM
  link.click(); // Trigger the download
  document.body.removeChild(link); // Remove the link from the DOM
}
async function base64ToMat(base64) {
  return cv.then(async (CV) => {
    return new Promise((resolve, reject) => {
      const cleanBase64 = base64.replace(/^data:image\/\w+;base64,/, "");
      const img = new Image();
      img.onload = () => {
        const canvas = document.createElement("canvas");
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);
        const imageData = ctx.getImageData(0, 0, img.width, img.height);
        const mat = CV.matFromImageData(imageData);
        resolve(mat);
      };
      img.onerror = () => reject(new Error("Image loading failed"));
      img.src = `data:image/jpeg;base64,${cleanBase64}`;
    });
  });
}

function createShadowMapAsBase64(sourceImage) {
  return cv.then((CV) => {
    // Convert to grayscale
    const grayImg = new CV.Mat();
    CV.cvtColor(sourceImage, grayImg, CV.COLOR_RGB2GRAY);

    // Create shadow map with multi-stage blur
    const shMap = new CV.Mat();

    // 1. Primary Gaussian blur
    CV.GaussianBlur(grayImg, shMap, new CV.Size(71, 71), 0);

    // 2. Median blur
    CV.medianBlur(shMap, shMap, 35);

    // 3. Secondary Gaussian blur
    CV.GaussianBlur(shMap, shMap, new CV.Size(45, 45), 0);

    // Convert to 8-bit for output (0-255 range)
    const blurred = new CV.Mat();
    shMap.convertTo(blurred, CV.CV_8U);

    // Create 1200x1200 output with letterboxing
    const output = new CV.Mat.zeros(1200, 1200, CV.CV_8UC1); // Black canvas

    // Calculate scaling and padding
    const scale = Math.min(1200 / blurred.cols, 1200 / blurred.rows);
    const scaledWidth = Math.round(blurred.cols * scale);
    const scaledHeight = Math.round(blurred.rows * scale);
    const offsetX = Math.floor((1200 - scaledWidth) / 2);
    const offsetY = Math.floor((1200 - scaledHeight) / 2);

    // Resize and copy to centered position
    const resized = new CV.Mat();
    CV.resize(
      blurred,
      resized,
      new CV.Size(scaledWidth, scaledHeight),
      0,
      0,
      CV.INTER_AREA
    );
    resized.copyTo(
      output.roi(new CV.Rect(offsetX, offsetY, scaledWidth, scaledHeight))
    );

    // // Resize with aspect ratio preservation
    // const targetWidth = 1200;
    // const resizedOutput = new CV.Mat();
    // const targetHeight = Math.floor(
    //   (init_shape[0] / init_shape[1]) * targetWidth
    // );
    // CV.resize(
    //   output,
    //   resizedOutput,
    //   new CV.Size(targetWidth, targetHeight),
    //   0,
    //   0,
    //   CV.INTER_AREA
    // );

    // Create canvas and convert to Base64
    const canvas = document.createElement("canvas");
    CV.imshow(canvas, output);
    const base64 = canvas.toDataURL("image/jpeg").split(",")[1];

    // Cleanup
    [grayImg, shMap, blurred, resized, output].forEach((m) => m.delete());

    return base64;
  });
}

